<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="JVM 调优工具及辅助工具, 技术博客 钟鸿鹏 honphan 阿钟">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="命令工具
¶jps(JVM Process Status Tool)
虚拟机进程状况工具。命令格式：
jps [ options ] [ hostid ]
jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态,参数hostid">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JVM 调优工具及辅助工具 | 阿钟的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">阿钟的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">阿钟的博客</div>
        <div class="logo-desc">
            
            keep going...
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JohnZhongg" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JohnZhongg" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        JVM 调优工具及辅助工具
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/JVM学习/" target="_blank">
                            <span class="chip bg-color">JVM学习</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/JVM学习/" class="post-category" target="_blank">
                            JVM学习
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-12-22
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    阿钟
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    49 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1>命令工具</h1>
<h2 id="jps-JVM-Process-Status-Tool"><a class="header-anchor" href="#jps-JVM-Process-Status-Tool">¶</a>jps(JVM Process Status Tool)</h2>
<p>虚拟机进程状况工具。命令格式：</p>
<p><code>jps [ options ] [ hostid ]</code></p>
<p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态,参数hostid为RMI注册表中注册的主机名。</p>
<h3 id="参数说明"><a class="header-anchor" href="#参数说明">¶</a>参数说明</h3>
<pre class="line-numbers language-language-shell"><code class="language-language-shell"># 列出Java程序进程ID和Main函数名称
jps
# 只输出进程ID
jps -q
# 输出传递给Java进程(主函数)的参数 
jps -m
# 输出主函数的完整路径
jps -l
# 显示传递给Java虚拟的参数
jps -v
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="jstat-JVM-Statistics-Monitoring-Tool"><a class="header-anchor" href="#jstat-JVM-Statistics-Monitoring-Tool">¶</a>jstat(JVM Statistics Monitoring Tool)</h2>
<p>jstat 是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>中的类加载、内存、垃圾收集、即时编译等运行时数据,在没有GUI图形界面、只提供了纯文本控制台环境的服务器上,它将是运行期定位虚拟机性能问题的常用工具。在实际生产环境中不一定可以使用图形界面,而且多数服务器管理员也都已经习惯了在文本控制台工作,直接在控制台中使用jstat命令依然是一种常用的监控方式。</p>
<p>jstat命令格式为：</p>
<p><code>jstat [ option vmid [interval[s|ms] [count]] ]</code></p>
<h3 id="参数说明-v2"><a class="header-anchor" href="#参数说明-v2">¶</a>参数说明</h3>
<p>对于命令格式中的VMID与LVMID需要特别说明一下:<strong>如果是本地虚拟机进程,VMID与LVMID 是一致的（为操作系统进程ID）</strong>;如果是远程虚拟机进程,那VMID的格式应当是:</p>
<p><code>[protocol:][//]lvmid[@hostname[:port]/servername]</code></p>
<p>参数interval和count代表查询间隔和次数,如果省略这2个参数,说明只查询一次。假设需要每250 毫秒查询一次进程2764垃圾收集状况,一共查询20次,那命令应当是:</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">jstat -gc 2764 250 20
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>选项option代表用户希望查询的虚拟机信息,主要分为三类:类加载、垃圾收集、运行期编译状况。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类加载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况,包括Eden区、2个 Survivor区、老年代、永久代等的容量已用空间,垃圾收集时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同,但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同,但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>与-gcutil功能一样,但是会额外输出导致上一次垃圾收集产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代垃圾收集状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gcnew基本相同,输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代垃圾收集状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同,输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出即时编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被即时编译的方法</td>
</tr>
<tr>
<td>-t</td>
<td>在输出信息前加上一个Timestamp列，显示程序的运行时间</td>
</tr>
<tr>
<td>-h</td>
<td>可以在周期性数据输出后，输出多少行数据后，跟着一个表头信息</td>
</tr>
<tr>
<td>interval</td>
<td>用于指定输出统计数据的周期，单位为毫秒</td>
</tr>
<tr>
<td>count</td>
<td>用于指定一个输出多少次数据</td>
</tr>
</tbody>
</table>
<h3 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h3>
<h4 id="jstat-gc"><a class="header-anchor" href="#jstat-gc">¶</a>jstat -gc</h4>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">zhonghongpeng@bogon ~ % jstat -gc 3230 250 4
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010
 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010
 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010
 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>输出列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0C</td>
<td>年轻代中第一个survivor(幸存区)的容量 (字节)</td>
</tr>
<tr>
<td>S1C</td>
<td>年轻代中第二个survivor(幸存区)的容量 (字节)</td>
</tr>
<tr>
<td>S0U</td>
<td>年轻代中第一个survivor(幸存区)目前已使用空间 (字节)</td>
</tr>
<tr>
<td>S1U</td>
<td>年轻代中第二个survivor(幸存区)目前已使用空间 (字节)</td>
</tr>
<tr>
<td>EC</td>
<td>年轻代中Eden(伊甸园)的容量 (字节)</td>
</tr>
<tr>
<td>EU</td>
<td>年轻代中Eden(伊甸园)目前已使用空间 (字节)</td>
</tr>
<tr>
<td>OC</td>
<td>Old代的容量 (字节)</td>
</tr>
<tr>
<td>OU</td>
<td>Old代目前已使用空间 (字节)</td>
</tr>
<tr>
<td>MC</td>
<td>metaspace(元空间)的容量 (字节)</td>
</tr>
<tr>
<td>MU</td>
<td>metaspace(元空间)目前已使用空间 (字节)</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间使用大小</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间(s)</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(全gc)gc次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT:从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
</tbody>
</table>
<h4 id="jstat-class"><a class="header-anchor" href="#jstat-class">¶</a>jstat -class</h4>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">zhonghongpeng@bogon ~ % jstat -class 3230
Loaded  Bytes  Unloaded  Bytes     Time
  4714  9787.2        0     0.0       1.28
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>输出列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loaded</td>
<td>已经装载的类的数量</td>
</tr>
<tr>
<td>Bytes</td>
<td>装载类所占用的字节数</td>
</tr>
<tr>
<td>Unloaded</td>
<td>已经卸载类的数量</td>
</tr>
<tr>
<td>Bytes</td>
<td>卸载类的字节数</td>
</tr>
<tr>
<td>Time</td>
<td>装载和卸载类所花费的时间</td>
</tr>
</tbody>
</table>
<h2 id="jinfo-Configuration-Info-for-Java"><a class="header-anchor" href="#jinfo-Configuration-Info-for-Java">¶</a>jinfo(Configuration Info for Java)</h2>
<p>Java配置信息工具的作用是实时查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表,但如果想知道未被显式指定的参数的系统默认值,除了去找资料外,就只能使用jinfo的-flag选项进行查询了(如果只限于JDK 6或以上版本的话,使用<code>java- XX:+PrintFlagsFinal</code>查看参数默认值也是一个很好的选择)。</p>
<p>在JDK 6中,jinfo对于Windows平台功能仍然有较大限制,只提供了最基本的-flag选项。</p>
<p>格式：<code>jinfo [option] &lt;pid&gt;</code></p>
<h3 id="参数说明-v3"><a class="header-anchor" href="#参数说明-v3">¶</a>参数说明</h3>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-flag &lt;name&gt;</code></td>
<td>打印JVM参数<code>&lt;name&gt;</code>的值</td>
</tr>
<tr>
<td><code>-flag [+/-]&lt;name&gt;</code></td>
<td>在运行期修改部分参数值的</td>
</tr>
<tr>
<td><code>-flag &lt;name&gt;=&lt;value&gt;</code></td>
<td>在运行期修改部分参数值的</td>
</tr>
<tr>
<td>-sysprops</td>
<td>把虚拟机进程的<code>System.getProperties()</code>的内容打印出来</td>
</tr>
<tr>
<td><code>&lt;no option&gt;</code></td>
<td>打印以上所有</td>
</tr>
<tr>
<td>-h/-help</td>
<td>帮助信息</td>
</tr>
</tbody>
</table>
<h2 id="jmap-Memory-Map-for-Java"><a class="header-anchor" href="#jmap-Memory-Map-for-Java">¶</a>jmap(Memory Map for Java)</h2>
<p>jmap命令用于生成堆转储快照(一般称为heapdump或dump文件)。如果不使用jmap命令,要想获取Java堆转储快照也还有一些比较“暴力”的手段:</p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>参数,可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件</li>
<li>通过<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件</li>
<li>又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机,也能顺利拿到堆转储快照。</li>
<li>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储。</li>
<li>使用 hprof 命令。</li>
</ul>
<p>jmap的作用并不仅仅是为了获取堆转储快照,它还可以查询finalize执行队列、Java堆和方法区的详细信息,如空间使用率、当前用的是哪种收集器等。和jinfo命令一样,jmap有部分功能在Windows平台下是受限的,除了生成堆转储快照的<code>-dump</code>选项和用于查看每个类的实例、空间占用统计的<code>-histo</code>选项在所有操作系统中都可以使用之外,其余选项都只能在Linux/Solaris中使用。</p>
<p>命令格式：</p>
<ul>
<li><code>jmap [option] &lt;pid&gt;</code></li>
<li><code>jmap [option] &lt;executable&gt; &lt;core&gt;</code></li>
<li><code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code></li>
</ul>
<h3 id="参数说明-v4"><a class="header-anchor" href="#参数说明-v4">¶</a>参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid</td>
<td>需要打印配置信息的进程ID。</td>
</tr>
<tr>
<td>executable</td>
<td>产生核心dump的Java可执行文件。</td>
</tr>
<tr>
<td>core</td>
<td>需要打印配置信息的核心文件。</td>
</tr>
<tr>
<td>server-id</td>
<td>可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。(VMID?)</td>
</tr>
<tr>
<td>remote server IP or hostname</td>
<td>远程调试服务器的IP地址或主机名。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no option</td>
<td>查看进程的内存映像信息,类似 Solaris pmap 命令。</td>
</tr>
<tr>
<td>-heap</td>
<td>显示Java堆详细信息,如使用哪种回收器、参数配置、分代状况等。只在 Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-dump</td>
<td>生成Java堆转储快照。格式为 <code>-dump:[live,]format=b,file= &lt;filename&gt;</code>, 其中live子参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待 Finalizer线程执行 finalize方法的对象。只在 Linux/ Solaris平下有效</td>
</tr>
<tr>
<td>-histo[:live]</td>
<td>显示堆中对象统计信息,包括类、实例数量、合计容量</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时,可使用这个选项强制生成dump快照。只在Linux/ Solaris平台下有效</td>
</tr>
<tr>
<td>-permstat</td>
<td>以 Classloader为统计口径显示永久代内存状态。只在 Linux/ Solaris平台下有效</td>
</tr>
<tr>
<td>-clstats</td>
<td>打印类加载器相关统计信息</td>
</tr>
<tr>
<td><code>-J&lt;flag&gt;</code></td>
<td>to pass <code>&lt;flag&gt;</code> directly to the runtime system</td>
</tr>
</tbody>
</table>
<h2 id="jhat-JVM-Heap-Analysis-Tool"><a class="header-anchor" href="#jhat-JVM-Heap-Analysis-Tool">¶</a>jhat(JVM Heap Analysis Tool)</h2>
<p>JDK提供jhat(JVM Heap Analysis Tool)命令与jmap搭配使用,来分析jmap生成的堆转储快照。<br>
jhat内置了一个微型的HTTP/Web服务器,生成堆转储快照的分析结果后,可以在浏览器中查看。不过实事求是地说,在实际工作中,除非手上真的没有别的工具可用,否则多数人是不会直接使用jhat命令来分析堆转储快照文件的,主要原因有两个方面：</p>
<ol>
<li>一般不会在部署应用程序的服务器上直接分析堆转储快照,即使可以这样做,也会尽量将堆转储快照文件复制到其他机器上进行分析,因为分析工作是一个耗时而且极为耗费硬件资源的过程,既然都要在其他机器上进行,就没有必要再受命令行工具的限制了</li>
<li>另外一个原因是jhat的分析功能相对来说比较简陋,如VisualVM以及专业用于分析堆转储快照文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具,都能实现比jhat更强大专业的分析功能。</li>
</ol>
<p>命令格式：<code>jhat [ options ] heap-dump-file</code></p>
<h3 id="参数说明-v5"><a class="header-anchor" href="#参数说明-v5">¶</a>参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>options</td>
<td>可选命令行参数</td>
</tr>
<tr>
<td>heap-dump-file</td>
<td>要查看的二进制Java堆转储文件(Java binary heap dump file)。 如果某个转储文件中包含了多份 heap dumps, 可在文件名之后加上 <code>#</code> 的方式指定解析哪一个 dump, 如: <code>myfile.hprof#3</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-stack false/true</td>
<td>关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true .</td>
</tr>
<tr>
<td>-refs false/true</td>
<td>关闭对象引用跟踪(tracking of references to objects)。 默认值为 true . 默认情况下, 返回的指针是指 向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的 所有对象。</td>
</tr>
<tr>
<td>-port port-number</td>
<td>设置 jhat HTTP server 的端口号. 默认值 7000 .</td>
</tr>
<tr>
<td>-exclude exclude-file</td>
<td>指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。</td>
</tr>
<tr>
<td>-baseline exclude-file</td>
<td>指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很 有用.</td>
</tr>
<tr>
<td>-debug int</td>
<td>设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.</td>
</tr>
<tr>
<td>-version</td>
<td>启动后只显示版本信息就退出</td>
</tr>
<tr>
<td>-help/-h</td>
<td>显示帮助信息并退出</td>
</tr>
<tr>
<td><code>-J&lt;flag&gt;</code></td>
<td>因为 jhat 命令实际上会启动一个JVM来执行, 通过 <code>-J</code> 可以在启动JVM时传入一些启动参数. 例如, <code>-JXmx512m</code> 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数, 则传入多个 <code>-Jxxxxxx</code>.</td>
</tr>
</tbody>
</table>
<h3 id="示例-v2"><a class="header-anchor" href="#示例-v2">¶</a>示例</h3>
<p>执行命令启动服务器</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">zhonghongpeng@bogon heapdump % jhat ./heapdump-1600348822631.hprof 
Reading from ./heapdump-1600348822631.hprof...
Dump file created Thu Sep 17 21:20:22 CST 2020
Snapshot read, resolving...
Resolving 38612 objects...
Chasing references, expect 7 dots.......
Eliminating duplicate references.......
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232437.png" alt="image-20200920093053766"></p>
<p>分析结果默认以包为单位进行分组显示,分析内存泄漏问题主要会使用到其中的“Heap Histogram”(与jmap-histo功能一样)与OQL页签的功能,前者可以找到内存中总容量最大的对象,后者是标准的对象查询语言,使用类似SQL的语法对内存中的对象进行查询统计。</p>
<p>jhat 启动后显示的 html ⻚面中包含有:</p>
<ul>
<li>All classes including platform:显示出堆中所包含的所有的类</li>
<li>Show all members of the rootset :从根集能引用到的对象</li>
<li>Show instance counts for all classes (including platform/excluding platform):显示平台包括的 所有类的实例数量</li>
<li>Show heap histogram:堆实例的分布表</li>
<li>Show finalizer summary:Finalizer 摘要</li>
<li>Execute Object Query Language (OQL) query:执行对象查询语句(OQL)</li>
</ul>
<h2 id="jstack-Stack-Trace-for-Java"><a class="header-anchor" href="#jstack-Stack-Trace-for-Java">¶</a>jstack(Stack Trace for Java)</h2>
<p>jstack命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合,生成线程快照的目的通常是定位线程出现长时间停顿的原因,如线程间死锁、死循环、请求外部资源导致的长时间挂起等,都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈, 就可以获知没有响应的线程到底在后台做些什么事情,或者等待着什么资源。</p>
<p>命令格式：</p>
<ul>
<li>
<p><code>jstack [ option ] pid</code>： 查看当前时间点，指定进程的dump堆栈信息。</p>
</li>
<li>
<p><code>jstack [ option ] pid &gt; 文件</code>： 将当前时间点的指定进程的dump堆栈信息，写入到指定文件中。</p>
<p>注:若该文件不存在，则会自动生成;若该文件存在，则会覆盖源文件。</p>
</li>
<li>
<p><code>jstack [ option ] executable core</code>： 查看当前时间点，core文件的dump堆栈信息。</p>
</li>
<li>
<p><code>jstack [ option ] [server_id@]&lt;remote server IP or hostname&gt;</code>： 查看当前时间点，远程 机器的dump堆栈信息。</p>
</li>
</ul>
<h3 id="参数说明-v6"><a class="header-anchor" href="#参数说明-v6">¶</a>参数说明</h3>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>当正常输出的请求不被响应时,强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外,显示关于锁的附加信息。⻓列表. 打印关于锁的附加信息。例如属于java.util.concurrent的ownable synchronizers 列表，会使得JVM停顿得⻓久得多(可能会差很多倍，比如普通的jstack可能几毫秒和一次GC没区别，加了-l 就是近一秒的时间)，-l 建议不要用。一般情况不需要使用。</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话,可以显示C/C++的堆栈，一般应用排查不需要使用。</td>
</tr>
</tbody>
</table>
<h3 id="在thread-dump中要留意的状态"><a class="header-anchor" href="#在thread-dump中要留意的状态">¶</a>在thread dump中要留意的状态</h3>
<ul>
<li>死锁，Deadlock(重点关注)</li>
<li>等待资源，Waiting on condition(重点关注)</li>
<li>等待获取监视器，Waiting on monitor entry(重点关注)</li>
<li>阻塞，Blocked(重点关注)</li>
<li>执行中，Runnable</li>
<li>暂停，Suspended</li>
<li>对象等待中，Object.wait() 或 TIMED_WAITING</li>
<li>停止，Parked</li>
</ul>
<h3 id="自己实现"><a class="header-anchor" href="#自己实现">¶</a>自己实现</h3>
<p>从JDK5起,<code>java.lang.Thread</code>类新增了一个<code>getAllStackTraces()</code>方法用于获取虚拟机中所有线程的<code>StackTraceElement</code>对象。使用这个方法可以通过简单的几行代码完成jstack的大部分功能,在实际项目中不妨调用这个方法做个管理员页面,可以随时使用浏览器来查看线程堆栈：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">        for (Map.Entry<Thread, StackTraceElement[]> stackTrace : Thread.getAllStackTraces().entrySet()) {
            Thread thread = (Thread) stackTrace.getKey();
            StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();
            if (thread.equals(Thread.currentThread())) {
                continue;
            }
            System.out.print("\n线程:" + thread.getName() + "\n");
            for (StackTraceElement element : stack) {
                System.out.print("\t" + element + "\n");
            }
        }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="hprof-Heap-CPU-Profiling-Tool"><a class="header-anchor" href="#hprof-Heap-CPU-Profiling-Tool">¶</a>hprof(Heap/CPU Profiling Tool)</h2>
<p>J2SE中提供了一个简单的命令行工具来对java程序的cpu和heap进行 profiling，叫做HPROF。 HPROF实际上是JVM中的一个native的库，它会在JVM启动的时候通过命令行参数来动态加载，并成为 JVM进程的一部分。若要在java进程启动的时候使用HPROF，用户可以通过各种命令行参数类型来使用 HPROF对java进程的heap或者 (和)cpu进行profiling的功能。HPROF产生的profiling数据可以是二 进制的，也可以是文本格式的。这些日志可以用来跟踪和分析 java进程的性能问题和瓶颈，解决内存使用上不优的地方或者程序实现上的不优之处。二进制格式的日志还可以被JVM中的HAT工具来进行浏览 和分析，用 以观察java进程的heap中各种类型和数据的情况。在J2SE 5.0以后的版本中，HPROF已经被 并入到一个叫做Java Virtual Machine Tool Interface(JVM TI)中。</p>
<p>命令格式：</p>
<ul>
<li><code>java -agentlib:hprof[=options] ToBeProfiledClass</code></li>
<li><code>java -Xrunprof[:options] ToBeProfiledClass</code></li>
<li><code>javac -J-agentlib:hprof[=options] ToBeProfiledClass</code></li>
</ul>
<h3 id="参数说明-v7"><a class="header-anchor" href="#参数说明-v7">¶</a>参数说明</h3>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>heap=dump|site|sall</td>
<td>heap profiling</td>
<td>all</td>
</tr>
<tr>
<td>cpu=samples|times|old</td>
<td>CPU usage</td>
<td>off</td>
</tr>
<tr>
<td>monitor=y|n</td>
<td>monitor contention</td>
<td>n</td>
</tr>
<tr>
<td>format=a|b</td>
<td>text(txt) or binary output</td>
<td>a</td>
</tr>
<tr>
<td><code>file=&lt;file&gt;</code></td>
<td>write data to file</td>
<td>java.hprof[.txt]</td>
</tr>
<tr>
<td><code>net=&lt;host&gt;:&lt;port&gt;</code></td>
<td>send data over a socket</td>
<td>off</td>
</tr>
<tr>
<td><code>depth=&lt;size&gt;</code></td>
<td>stack trace depth</td>
<td>4</td>
</tr>
<tr>
<td><code>interval=&lt;ms&gt;</code></td>
<td>sample interval in ms</td>
<td>10</td>
</tr>
<tr>
<td><code>cutoff=&lt;value&gt;</code></td>
<td>output cutoff point</td>
<td>0.0001</td>
</tr>
<tr>
<td>lineno=y|n</td>
<td>line number in traces?</td>
<td>y</td>
</tr>
<tr>
<td>thread=y|n</td>
<td>thread in traces?</td>
<td>n</td>
</tr>
<tr>
<td>doe=y|n</td>
<td>dump on exit?</td>
<td>y</td>
</tr>
<tr>
<td>msa=y|n</td>
<td>Solaris micro state accounting</td>
<td>n</td>
</tr>
<tr>
<td>force=y|n</td>
<td><code>force output to &lt;file&gt;</code></td>
<td>y</td>
</tr>
<tr>
<td>verbose=y|n</td>
<td>print messages about dumps</td>
<td>y</td>
</tr>
</tbody>
</table>
<h3 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a>示例</h3>
<p>命令示例：</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell"># 每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称 java.hprof.txt，在当前目录。
java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello

# CPU Usage Times Profiling(cpu=times)的例子，它相对于CPU Usage Sampling Profile能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术 (BCI):
javac -J-agentlib:hprof=cpu=times Hello.java

# Heap Allocation Profiling(heap=sites)的例子:
javac -J-agentlib:hprof=heap=sites Hello.java

# Heap Dump(heap=dump)的例子，它比上面的Heap Allocation Profiling能生成更详细的Heap Dump信息:
javac -J-agentlib:hprof=heap=dump Hello.java
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>统计方法耗时：</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">package demo;

/**
 * @author: honphan.john
 * @date: 2020/9/20 10:03
 * @description:
 */
public class HprofTest {

    // java -agentlib:hprof=cpu=times,interval=10 demo.HprofTest demo.HprofTest
    public void slowMethod() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void slowerMethod() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void fastMethod() {
        try {
            Thread.yield();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        HprofTest test = new HprofTest();
        test.fastMethod();
        test.slowMethod();
        test.slowerMethod();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="注"><a class="header-anchor" href="#注">¶</a>注</h3>
<p>虽然在JVM启动参数中加入<code>-Xrunprof:heap=sites</code>参数可以生成CPU/Heap Profile文件，但对JVM性能影响非常大，不建议在线上服务器环境使用。</p>
<h2 id="命令工具参考"><a class="header-anchor" href="#命令工具参考">¶</a>命令工具参考</h2>
<h3 id="基础工具"><a class="header-anchor" href="#基础工具">¶</a>基础工具</h3>
<p>用于支持基本的程序创建和运行</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>appletviewer</td>
<td>在不使用Web浏览器的情况下运行和调试 Applet,JDK11中被移除</td>
</tr>
<tr>
<td>extcheck</td>
<td>检査JAR冲突的工具,从JDK9中被移除</td>
</tr>
<tr>
<td>jar</td>
<td>创建和管理JAR文件</td>
</tr>
<tr>
<td>java</td>
<td>Java运行工具,用于运行 Class文件或JAR文件</td>
</tr>
<tr>
<td>javac</td>
<td>用于Java编程语言的编译器</td>
</tr>
<tr>
<td>javadoc</td>
<td>Java的API文档生成器</td>
</tr>
<tr>
<td>javah</td>
<td>C语言头文件和Stub函数生成器,用于编写JNI方法</td>
</tr>
<tr>
<td>javap</td>
<td>Java字节码分析工具</td>
</tr>
<tr>
<td>jlink</td>
<td>将Module和它的依赖打包成一个运行时镜像文件</td>
</tr>
<tr>
<td>jdb</td>
<td>基于JPDA协议的调试器,以类似于GDB的方式进行调试Java代码</td>
</tr>
<tr>
<td>jdeps</td>
<td>Java类依赖性分析器</td>
</tr>
<tr>
<td>ideprscan</td>
<td>用于搜索JAR包中使用了“ deprecated”的类,从JDK9开始提供</td>
</tr>
</tbody>
</table>
<h3 id="安全"><a class="header-anchor" href="#安全">¶</a>安全</h3>
<p>用于程序签名、设置安全测试</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>keytool</td>
<td>管理密钥库和证书。主要用于获取或缓存 Kerberos协议的票据授权票据。允许用户査看本地凭据缓存和密钥表中的条目(用于 Kerberos协议)</td>
</tr>
<tr>
<td>jarsigner</td>
<td>生成并验证JAR签名</td>
</tr>
<tr>
<td>policytool</td>
<td>管理策略文件的GUI工具,用于管理用户策略文件(java. policy),在JDK10中被移除</td>
</tr>
</tbody>
</table>
<h3 id="国际化"><a class="header-anchor" href="#国际化">¶</a>国际化</h3>
<p>用于创建本地语言文件</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>native2ascii</td>
<td>本地编码到ASCⅡ编码的转换器( Native-to-ASCII Converter),用于“任意受支持的字符编码和与之对应的“ASC编码和 Unicode转义”之间的相互转换</td>
</tr>
</tbody>
</table>
<h3 id="远程方法调用"><a class="header-anchor" href="#远程方法调用">¶</a>远程方法调用</h3>
<p>用于跨Web或网络的服务交互</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rmic</td>
<td>Java RMI编译器,为使用JRMP或IIOP协议的远程对象生成Stub、 Skeleton和Tie类,也用于生成 OMG IDL</td>
</tr>
<tr>
<td>rmiregistry</td>
<td>远程对象注册表服务,用于在当前主机的指定端口上创建并启动一个远程对象注册表</td>
</tr>
<tr>
<td>rmid</td>
<td>启动激活系统守护进程,允许在虚拟机中注册或激活对象</td>
</tr>
<tr>
<td>serialver</td>
<td>生成并返回指定类的序列化版本ID</td>
</tr>
</tbody>
</table>
<h3 id="Java-IDL与RMI-IOP"><a class="header-anchor" href="#Java-IDL与RMI-IOP">¶</a>Java IDL与RMI-IOP</h3>
<p>在JDK11中结束了十余年的 CORBA支持,这些工具不再提供</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>tnameserv</td>
<td>提供对命名服务的访问IDL转Java编译器(IDL-to- -Java Compiler),生成映射 OMG IDL接口的Java源文件,并启用以Java编程语言编写的使用 CORBA功能的应用程序的Java源文件。IDL意即接口定义语言(Interface Definition Language)</td>
</tr>
<tr>
<td>idlj</td>
<td>对象请求代理守护进程( Object Request Broker Daemon),提供从客户端查找和调用 CORBA 环境服务端上的持久化对象的功能。使用ORBD代替瞬态命名服务tnameserv。ORBD包括瞬态orb 命名服务和持久命名服务。ORBD工具集成了服务器管理器、互操作命名服务和引导名称服务器的功能。当客户端想进行服务器时定位、注册和激活功能时,可以与 servertool一起使用</td>
</tr>
<tr>
<td>servertool</td>
<td>为应用程序注册、注销、启动和关闭服务器提供易用的接口</td>
</tr>
</tbody>
</table>
<h3 id="部署工具"><a class="header-anchor" href="#部署工具">¶</a>部署工具</h3>
<p>用于程序打包、发布和部署</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>javapackager</td>
<td>打包、签名Java和 Javafx应用程序,在JDK11中被移除</td>
</tr>
<tr>
<td>pack200</td>
<td>使用 Java GZIP压缩器将JAR文件转换为压缩的Pack200文件。压缩的压缩文件是高度压缩的JAR,可以直接部署,节省带宽并减少下载时间</td>
</tr>
<tr>
<td>unpack200</td>
<td>将Pack200生成的打包文件解压提取为JAR文件</td>
</tr>
</tbody>
</table>
<h3 id="Java-Web-Start"><a class="header-anchor" href="#Java-Web-Start">¶</a>Java Web Start</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>javaws</td>
<td>启动 Java Web Start并设置各种选项的工具。在JDK11中被移除</td>
</tr>
</tbody>
</table>
<h3 id="性能监控和故障处理"><a class="header-anchor" href="#性能监控和故障处理">¶</a>性能监控和故障处理</h3>
<p>用于监控分析Java虚拟机运行信息,排查问题</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM Process Status Tool,显示指定系统内所有的 Hotspot虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM Statistics Monitoring Tool,用于收集 Hotspot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jstad</td>
<td>JVM Statistics Monitoring Tool Daemon, jstat的守护程序,启动一个RMI服务器应用程序, statd 用于监视测试的 Hotspot虚拟机的创建和终止,并提供一个界面,允许远程监控工具附加到在本地系统上运行的虚拟机。在JDK9中集成到了 JHSDB中</td>
</tr>
<tr>
<td>jinfo</td>
<td>Configuration Info for Java,显示虚拟机配置信息。在JDK9中集成到了 JHSDB中</td>
</tr>
<tr>
<td>jmap</td>
<td>Memory Map for Java,生成虚拟机的内存转储快照( headup文件)。在JDK9中集成到了JHSDB中</td>
</tr>
<tr>
<td>jhat</td>
<td>JVMHeapAnalysisTool,用于分析堆转储快照,它会建立一个HTTP/WEB服务器,让用户可以在浏览器上査看分析结果。在JDK9中被 JHSDB代替</td>
</tr>
<tr>
<td>jstack</td>
<td>stack Stack Trace for Java,显示虚拟机的线程快照。在JDK9中集成到了 JHSDB中</td>
</tr>
<tr>
<td>jhsdb</td>
<td>Java Hotspot Debugger,一个基于 Serviceability Agent的 Hotspot进程调试器,从JDK9开始提供</td>
</tr>
<tr>
<td>jsadebugd</td>
<td>Java Serviceability Agent Debug Daemon,适用于Java的可维护性代理调试守护程序,主要用于附加到指定的Java进程、核心文件,或充当一个调试服务器</td>
</tr>
<tr>
<td>jcmd</td>
<td>JVM Command,虚拟机诊断命令工具,将诊断命令请求发送到正在运行的Java虚拟机。从JDK7开始提供</td>
</tr>
<tr>
<td>jconsole</td>
<td>Java Console,用于监控Java虚拟机的使用JMX规范的图形工具。它可以监控本地和远程jconsole Java虚拟机,还可以监控和管理应用程序</td>
</tr>
<tr>
<td>jmc</td>
<td>Java Mission Control,包含用于监控和管理Java应用程序的工具,而不会引入与这些工具相Jmc 关联的性能开销。开发者可以使用jme命令来创建JMC工具,从JDK7 Update40开始集成到Oraclejdk中</td>
</tr>
<tr>
<td>jvisualvm</td>
<td>Java Visualvm,一种图形化工具,可在Java虚拟机中运行时提供有关基于Java技术的应用程序(Java应用程序)的详细信息。 Java Visualvm提供内存和CPU分析、堆转储分析、内存泄漏检测、 Mbean访问和垃圾收集。从JDK6 Update7开始提供;从JDK9开始不再打包入JDK 中,但仍保持更新发展,可以独立下载</td>
</tr>
</tbody>
</table>
<h3 id="Web-Service工具"><a class="header-anchor" href="#Web-Service工具">¶</a>Web Service工具</h3>
<p>与CORBA一起在JDK11中被移除</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>schemagen</td>
<td>用于XML绑定的 Schema生成器,用于生成 XML Schema文件</td>
</tr>
<tr>
<td>wsgen</td>
<td>XML Web Service2.0的 Java API,生成用于JAX- WS Web Service的JAX-WS便携式产物</td>
</tr>
<tr>
<td>wsimport</td>
<td>XML Web Service2.0的 Java API,主要用于根据服务端发布的WSDL文件生成客户端</td>
</tr>
<tr>
<td>xjc</td>
<td>主要用于根据 XML Schema文件生成对应的Java类</td>
</tr>
</tbody>
</table>
<h3 id="REPL和脚本工具"><a class="header-anchor" href="#REPL和脚本工具">¶</a>REPL和脚本工具</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jshell</td>
<td>基于Java的 Shell REPL(Read-Eval-Print Loop)交互工具</td>
</tr>
<tr>
<td>jjs</td>
<td>对 Nashorn引擎的调用入口。 Nashorn是基于Java实现的一个轻量级高性能 Javascript运行环境</td>
</tr>
<tr>
<td>jrunscript</td>
<td>Java命令行脚本外売工具( Command Line Script Shell),主要用于解释执行Javascript、 Groovy、 Ruby等脚本语言</td>
</tr>
</tbody>
</table>
<h1>图形化工具</h1>
<h2 id="JHSDB"><a class="header-anchor" href="#JHSDB">¶</a>JHSDB</h2>
<p>JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱,它们不仅整合了上面的所有基础工具所能提供的专项功能,而且由于有着“后发优势”,能够做得往往比之前的老工具们更好、更强大。</p>
<p>JHSDB虽然名义上是JDK 9中才正式提供,但之前已经以sa-jdi.jar包里面的HSDB(可视化工具)和CLHSDB(命令行工具)的形式存在了很长一段时间。它们两个都是JDK的正式成员,随着JDK一同发布,无须独立下载,使用也是完全免费的。准确来说是Linux和Solaris在OracleJDK 6就可以使用HSDB和CLHSDB了,Windows上要到Oracle-JDK 7才可以用。</p>
<p>JHSDB是一款基于服务性代理(Serviceability Agent,SA)实现的进程外调试工具。服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言(含少量JNI代码)实现的API集合。服务性代理以HotSpot内部的数据结构为参照物进行设计,把这些C<ins>的数据抽象出Java模型对象,相当于HotSpot的C</ins>代码的一个镜像。通过服务性代理的API,<strong>可以在一个独立的Java虚拟机的进程里分析其他HotSpot虚拟机的内部数据,或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节</strong>。服务性代理的工作原理跟Linux上的GDB或者Windows上的Windbg是相似的。</p>
<p>JCMD、JHSDB与原基础工具实现相同功能的简要对比：</p>
<table>
<thead>
<tr>
<th>基础工具</th>
<th>JCMD</th>
<th>JHSDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps -lm</td>
<td>jcmd</td>
<td>N/A</td>
</tr>
<tr>
<td>jmap -dump <code>&lt;pid&gt;</code></td>
<td>jcmd <code>&lt;pid&gt;</code> GC.heap_dump</td>
<td>jhsdb jmap --binaryheap</td>
</tr>
<tr>
<td>jmap -histo <code>&lt;pid&gt;</code></td>
<td>jcmd <code>&lt;pid&gt;</code> GC.classhistogram</td>
<td>jhsdb jmap --histo</td>
</tr>
<tr>
<td>jstack <code>&lt;pid&gt;</code></td>
<td>jcmd <code>&lt;pid&gt;</code> Thread.print</td>
<td>jhsdb jstack --locks</td>
</tr>
<tr>
<td>jinto -sysprops <code>&lt;pid&gt;</code></td>
<td>jcmd <code>&lt;pid&gt;</code> VM.system_properties</td>
<td>jhsdb info --sysprops</td>
</tr>
<tr>
<td>jinfo -flags <code>&lt;pid&gt;</code></td>
<td>jcmd <code>&lt;pid&gt;</code> VM.flags</td>
<td>jhsdb jinfo --flags</td>
</tr>
</tbody>
</table>
<h3 id="实战示例"><a class="header-anchor" href="#实战示例">¶</a>实战示例</h3>
<p>通过实验来回答一个简单问题:staticObj、instanceObj、localObj这三个变量本身(而不是它们所指向的对象)存放在哪里。</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">package demo;
/**
 * -Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops
 *
 * @author: honphan.john
 * @date: 2020/9/20 10:55
 * @description:
 */
public class JHSDB_TestCase {
    static class Test {
        static ObjectHolder staticObj = new ObjectHolder();
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() {
            ObjectHolder localObj = new ObjectHolder();
            System.out.println("done");    // 这里设一个断点
        }
    }
    private static class ObjectHolder {
    }
    public static void main(String[] args) {
        Test test = new JHSDB_TestCase.Test();
        test.foo();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先,我们要确保这三个变量已经在内存中分配好,然后将程序暂停下来,以便有空隙进行实验,这只要把断点设置在代码中加粗的打印语句上,然后在调试模式下运行程序即可。由于JHSDB本身对压缩指针的支持存在很多缺陷,建议用64位系统实验时禁用压缩指针,另外为了后续操作时可以加快在内存中搜索对象的速度,也建议限制一下Java堆的大小：<code>-Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops</code>。</p>
<p>程序执行后通过jps查询到测试程序的进程ID,具体如下:</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">zhonghongpeng@bogon jvm % jps    
6644 Launcher
6645 JHSDB_TestCase
6647 Jps
1119 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动JHSDB(本次试验基于Java8，在${JAVA_HOME}/bin下还没有JHSDB命令行工具，JDK9及之后使用<code>jhsdb hsdb --pid &lt;pid&gt;</code>)</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">sudo java -cp ,:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB 6645
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232500.png" alt="image-20200920114157856"></p>
<p>下面直接在堆中查找创建的三个对象</p>
<p>首先点击菜单中的<code>Tools-&gt;Heap Parameters</code>, 因为运行参数中指定了使用的是Serial收集器,图中我们看到了典型的Serial的分代内存布局,Heap Parameters窗口中清楚列出了新生代的Eden、S1、S2和老年代的容量(单位为字节)以及它们的虚拟内存地址起止范围。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232507.png" alt="image-20200920114430925"></p>
<p>开Windows-&gt;Console窗口,使用scanoops命令在Java堆的新生代(从Eden起始地址到To Survivor结束地址)范围内查找ObjectHolder的实例,结果如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232514.png" alt="image-20200920114738658"></p>
<p>果然找出了三个实例的地址,而且它们的地址都落到了Eden的范围之内,算是顺带验证了一般情况下新对象在Eden中创建的分配规则。接下来要根据堆中对象实例地址找出引用它们的指针,原本JHSDB的Tools菜单中有Compute Reverse Ptrs来完成这个功能，但是低版本的貌似都有问题，改为在console面板使用命令行替代(所有图形化操作都可以在console使用命令行替代，输入<code>help</code>获取帮助信息)。</p>
<p>在下图上半部分可以看到使用<code>revptrs</code>命令找到了一个引用了第一个对象&quot;0x000000010f465e70&quot;的对象地址&quot;0x000000010f454270&quot;，它存储的是一个<code>Class</code>对象**（一个&quot;.class&quot;文件会生成一个Java<code>Class</code>对象，一些静态成员会称为<code>Class</code>对象的成员，这些信息在JDK7之前在方法区/永久代，JDK7及之后和字符串常量池一起移到了堆/老年代）**。</p>
<p>下半部分使用Tools-&gt;Inspector功能根据找到的对象内存地址检查存放的对象。Inspector为我们展示了对象头和指向对象元数据的指针,里面包括了Java类型的名字、继承关系、实现接口关系,字段信息、方法信息、运行时常量池的指针、内嵌的虚方法表(vtable)以及接口方法表(itable)等。</p>
<p>可以看到这个对象有一个成员正是<code>staticObj</code>存储的内容就是&quot;0x000000010f465e70&quot;。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232521.png" alt="image-20200920115225042"></p>
<p>接着我们查找第二个对象被谁引用了。如下图可以看到是一个在内存地址为&quot;0x000000010f465e80&quot;的<code>JHSDB_TestCase$Test</code>对象的一个<code>instanceObj</code>存储了该对象的地址&quot;0x000000010f465e98&quot;。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232529.png" alt="image-20200920115931689"></p>
<p>尝试寻找最后一个对象的时候得到一个空指针，可能该命令还不支持栈上查找：</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">hsdb> revptrs 0x000000010f465ea8
null
null
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在Java Thread窗口选中main线程后点击Stack Memory按钮查看该线程的栈内存。可以直接在栈上找到了对该最后一个对象<code>localObj</code>的引用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232535.png" alt="image-20200920120439531"></p>
<h2 id="JConsole-Java-Monitoring-and-Management-Console"><a class="header-anchor" href="#JConsole-Java-Monitoring-and-Management-Console">¶</a>JConsole(Java Monitoring and Management Console)</h2>
<p>JConsole是一款基于JMX(Java Management Extensions)的可视化监视、管理工具。它的主要功能是通过JMX的MBean(Managed Bean)对系统进行信息收集和参数动态调整。JMX是一种开放性的技术,不仅可以用在虚拟机本身的管理上,还可以运行于虚拟机之上的软件中,典型的如中间件大多也基于JMX来实现管理与监控。虚拟机对JMX MBean的访问也是完全开放的,可以使用代码调用API、支持JMX协议的管理控制台,或者其他符合JMX规范的软件进行访问。</p>
<h3 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h3>
<h4 id="启动"><a class="header-anchor" href="#启动">¶</a>启动</h4>
<p>如果是从命令行启动，使 JDK 在 PATH 上，运行 <code>jconsole</code> 即可。<br>
如果从 GUI shell 启动，找到 JDK 安装路径，打开 bin 文件夹，双击 jconsole 。</p>
<h4 id="连接"><a class="header-anchor" href="#连接">¶</a>连接</h4>
<ul>
<li>jconsole启动后会自动搜索出本机运行的所有虚拟机进程,而不需要用户自己使用jps来查询。双击选择其中一个进程便可进入主界面开始监控。</li>
<li>JMX支持跨服务器的管理,也可以使用下面的“远程进程”功能来连接远程服务器,对远程虚拟机进行监控
<ul>
<li>通过<code>jconsole host:port</code>命令</li>
<li>也可以在已经打开的JConsole界面操作：连接-&gt;新建连接-&gt;选择远程进程-&gt;输入远程主机IP和端口号- &gt;点击“连接”</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232544.png" alt="image-20200920155644799"></p>
<h3 id="界面介绍"><a class="header-anchor" href="#界面介绍">¶</a>界面介绍</h3>
<p>进入视图后包括这六个标签:</p>
<h4 id="Overview"><a class="header-anchor" href="#Overview">¶</a>Overview:</h4>
<p>Displays overview information about the Java VM and monitored values.</p>
<h4 id="Memory-显示内存使用信息"><a class="header-anchor" href="#Memory-显示内存使用信息">¶</a>Memory: 显示内存使用信息</h4>
<p>“内存”页签的作用相当于可视化的jstat命令,用于监视被收集器管理的虚拟机内存(被收集器直接管理的Java堆和被间接管理的方法区)的变化趋势。包括Eden、Survivor、Ternuring、Metaspace等等维度的内存监控。</p>
<h4 id="Threads-显示线程使用信息"><a class="header-anchor" href="#Threads-显示线程使用信息">¶</a>Threads: 显示线程使用信息</h4>
<p>“线程”页签的功能就相当于可视化的jstack命令了,遇到线程停顿的时候可以使用这个页签的功能进行分析。如线程长时间停顿的主要原因有等待外部资源(数据库连接、网络资源、设备资源等)、死循环、锁等待等。</p>
<h5 id="示例："><a class="header-anchor" href="#示例：">¶</a>示例：</h5>
<pre class="line-numbers language-language-java"><code class="language-language-java">package demo.jconsole;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * @author: honphan.john
 * @date: 2020/9/20 15:55
 * @description:
 */
public class ThreadTest {
    /**
     * 线程死循环演示
     */
    public static void createBusyThread() {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true)   // 第19行
                {
                    ;
                }
            }
        }, "testBusyThread");
        thread.start();
    }

    /**
     * 线程锁等待演示
     */
    public static void createLockThread(final Object lock) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (lock) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }, "testLockThread");
        thread.start();
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        br.readLine();
        createBusyThread();
        br.readLine();
        Object obj = new Object();
        createLockThread(obj);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="主线程等待输入"><a class="header-anchor" href="#主线程等待输入">¶</a>主线程等待输入</h5>
<p>程序运行后,首先在“线程”页签中选择main线程。堆栈追踪显示BufferedReader的<code>readBytes()</code>方法正在等待<code>System.in</code>的键盘输入,这时候线程为Runnable状态,Runnable状态的线程仍会被分配运行时间,但<code>readBytes()</code>方法检查到流没有更新就会立刻归还执行令牌给操作系统,这种等待只消耗很小的处理器资源：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232552.png" alt="image-20200920160644113"></p>
<h5 id="死循环线程"><a class="header-anchor" href="#死循环线程">¶</a>死循环线程</h5>
<p>接着监控<code>testBusyThread</code>线程。<code>testBusyThread</code>线程一直在执行空循环,从堆栈追踪中看到一直在MonitoringTest.java代码的41行停留,19行的代码为while(true)。这时候线程为Runnable 状态,而且没有归还线程执行令牌的动作,所以会在空循环耗尽操作系统分配给它的执行时间,直到线程切换为止,这种等待会消耗大量的处理器资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232559.png" alt="image-20200920161217055"></p>
<h5 id="等待线程"><a class="header-anchor" href="#等待线程">¶</a>等待线程</h5>
<p><code>testLockThread</code>线程在等待lock对象的notify()或notifyAll()方法的出现,线程这时候处于WAITING状态,在重新唤醒前不会被分配执行时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232604.png" alt="image-20200920161417066"></p>
<h5 id="死锁检测"><a class="header-anchor" href="#死锁检测">¶</a>死锁检测</h5>
<p>下面是一段会产生死锁的代码</p>
<pre class="line-numbers language-language-java"><code class="language-language-java">package demo.jconsole;

/**
 * @author: honphan.john
 * @date: 2020/9/20 16:16
 * @description:
 */
public class DeadLock {
    /**
     * 线程死锁等待演示
     */
    static class SynAddRunalbe implements Runnable {
        int a, b;

        public SynAddRunalbe(int a, int b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public void run() {
            synchronized (Integer.valueOf(a)) {
                synchronized (Integer.valueOf(b)) {
                    System.out.println(a + b);
                }
            }
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(new SynAddRunalbe(1, 2)).start();
            new Thread(new SynAddRunalbe(2, 1)).start();
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用jconsole点击&quot;检测死锁&quot;即可显示死锁的线程，可以看到现在的线程是&quot;Blocked&quot;状态，和&quot;WAITING&quot;状态，它们是不同的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232610.png" alt="image-20200920161811620"></p>
<h4 id="Classes"><a class="header-anchor" href="#Classes">¶</a>Classes</h4>
<p>显示类装载信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232615.png" alt="image-20200920162217671"></p>
<h4 id="VM-Summary"><a class="header-anchor" href="#VM-Summary">¶</a>VM Summary</h4>
<p>显示java VM信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232623.png" alt="image-20200920162241281"></p>
<h4 id="MBeans-显示-MBeans"><a class="header-anchor" href="#MBeans-显示-MBeans">¶</a>MBeans: 显示 MBeans</h4>
<p>JMX监控指标。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232631.png" alt="image-20200920162439313"></p>
<h2 id="VisualVM-All-in-One-Java-Troubleshooting-Tool"><a class="header-anchor" href="#VisualVM-All-in-One-Java-Troubleshooting-Tool">¶</a>VisualVM(All-in-One Java Troubleshooting Tool)</h2>
<p>VisualVM是功能最强大的运行监视和故障处理程序之一, 曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。Oracle曾在VisualVM的软件说明中写上了“All-in-One”的字样,预示着它除了常规的运行监视、故障处理外,还将提供其他方面的能力,譬如性能分析(Profiling)。VisualVM的性能分析功能比起JProfiler、YourKit等专业且收费的Profiling工具都不遑多让。而且相比这些第三方工具,VisualVM还有一个很大的优点:不需要被监视的程序基于特殊Agent去运行,因此它的通用性很强,对应用程序实际性能的影响也较小,使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。</p>
<h3 id="插件"><a class="header-anchor" href="#插件">¶</a>插件</h3>
<p>VisualVM基于NetBeans平台开发工具,所以一开始它就具备了通过插件扩展功能的能力,有了插件扩展支持,VisualVM可以做到:</p>
<ul>
<li><strong>显示虚拟机进程以及进程的配置、环境信息</strong>(jps、jinfo)。</li>
<li><strong>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息</strong>(jstat、jstack)。</li>
<li><strong>dump以及加载分析堆转储快照(jmap、jhat)</strong>。</li>
<li><strong>方法级的程序运行性能分析,找出被调用最多、运行时间最长的方法</strong>。</li>
<li><strong>离线程序快照:收集程序的运行时配置、线程dump、内存dump等信息建立一个快照,可以将快照发送开发者处进行Bug反馈</strong>。</li>
<li><strong>查看JFR文件(JMC)</strong></li>
<li>其他插件带来的无限可能性。</li>
</ul>
<p>VisualVM自带插件安装系统，位置在&quot;Tools-&gt;Plugin&quot;，但是最近发现它的插件中心好像无法访问了，可以在<a href="https://github.com/oracle/visualvm/releases" target="_blank" rel="noopener">这个地址</a>进行VisualVM以及它的插件的下载，然后手动安装，插件为&quot;.nbm&quot;文件，每个版本不一定携带插件，如果最新版本没有找到插件列表就一直往下一个版本找。</p>
<h3 id="其中一些功能说明"><a class="header-anchor" href="#其中一些功能说明">¶</a>其中一些功能说明</h3>
<h4 id="分析程序性能"><a class="header-anchor" href="#分析程序性能">¶</a>分析程序性能</h4>
<p>在Profiler页签中,VisualVM提供了程序运行期间方法级的处理器执行时间分析以及内存分析。<strong>做Profiling分析肯定会对程序运行性能有比较大的影响,所以一般不在生产环境使用这项功能,或者改用JMC来完成,JMC的Profiling能力更强,对应用的影响非常轻微</strong>。</p>
<p>要开始性能分析,先选择“CPU”和“内存”按钮中的一个,然后切换到应用程序中对程序进行操作,VisualVM会记录这段时间中应用程序执行过的所有方法。如果是进行处理器执行时间分析,将会统计每个方法的执行次数、执行耗时;如果是内存分析,则会统计每个方法关联的对象数以及这些对象所占的空间。等要分析的操作执行结束后,点击“停止”按钮结束监控过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232646.png" alt="image-20200920173128281"></p>
<h4 id="BTrace插件动态日志跟踪"><a class="header-anchor" href="#BTrace插件动态日志跟踪">¶</a>BTrace插件动态日志跟踪</h4>
<p>BTrace是一个很神奇的VisualVM插件,它本身也是一个可运行的独立程序。BTrace的作用是在不中断目标程序运行的前提下,通过HotSpot虚拟机的Instrument功能动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义:如当程序出现问题时,排查错误的一些必要信息时(譬如方法参数、返回值等),在开发时并没有打印到日志之中以至于不得不停掉服务时,都可以通过调试增量来加入日志代码以解决问题。可惜在尝试安装VisualVM插件的时候发现好像不支持了。</p>
<p>不过BTrace同时也是一个独立运行的软件，这是<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">官方Github</a>。</p>
<p>BTrace能够实现动态修改程序行为,是因为它是基于Java虚拟机的Instrument开发的。Instrument是Java虚拟机工具接口(Java Virtual Machine Tool Interface,JVMTI)的重要组件,提供了一套代理(Agent)机制,使得第三方工具程序可以以代理的方式访问和修改Java虚拟机内部的数据。<strong>阿里巴巴开源的诊断工具Arthas也通过Instrument实现了与BTrace类似的功能</strong>。</p>
<h3 id="远程连接"><a class="header-anchor" href="#远程连接">¶</a>远程连接</h3>
<h4 id="配置JMX"><a class="header-anchor" href="#配置JMX">¶</a>配置JMX</h4>
<p>tomcat参数</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">CATALINA_OPTS="-xms800m -xmx800m -xmn350m -XX: Survivorratio=8 -XX: + HeapDumpOnOutOfMemoryError -Dcom.sun.management.jmxremote=true  -Djava.rmi.server.hostname=192.168.1.105 -Dcom.Sun.Management.jmxremote.port=6666 -Dcom.sun.management.jmxremote.ssl=false  -Dcom.Sun.Managementote.ssl=false -Dcom.Sun.management.jmxremote.authenticate=false"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="配置jstatd"><a class="header-anchor" href="#配置jstatd">¶</a>配置jstatd</h4>
<ol>
<li>自定义一个 <code>statd.policy</code> 文件，添加</li>
</ol>
<pre><code>grant codebase &quot;jrt:/jdk.jstatd&quot; {
	permission java.security.Allpermission;
};

grant codebase &quot;jrt:/jdk.Internal.jvmstat&quot; {
 	permission java.security.Allpermission;
}
</code></pre>
<ol start="2">
<li>然后在 <code>JDK_HOME/bin</code>下面运行<code>jstatd</code>，例如：</li>
</ol>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">./jstatd -J-Djava.rmi.hostname=192.168.1.102 -J-Djava.security.policy="上面配置的policy文件路径" -p 1099 &
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="客户端VisualVM连接"><a class="header-anchor" href="#客户端VisualVM连接">¶</a>客户端VisualVM连接</h4>
<p>然后在VisualVM分别连接即可</p>
<h2 id="JMC-Java-Mission-Control"><a class="header-anchor" href="#JMC-Java-Mission-Control">¶</a>JMC(Java Mission Control)</h2>
<p>除了大家熟知的面向通用计算(General Purpose Computing)可免费使用的Java SE外,Oracle公司还开辟过带商业技术支持的Oracle Java SE Support和面向独立软件供应商(ISV)的Oracle Java SE Advanced &amp; Suite产品线。</p>
<p>除去带有7×24小时的技术支持以及可以为企业专门定制安装包这些非技术类的增强服务外, Oracle Java SE Advanced &amp; Suite与普通Oracle Java SE在功能上的主要差别是前者包含了一系列的监控、管理工具,譬如用于企业JRE定制管理的AMC(Java Advanced Management Console)控制台、JUT(Java Usage Tracker)跟踪系统,用于持续收集数据的JFR(Java Flight Recorder)飞行记录仪和用于监控Java虚拟机的JMC(Java Mission Control)。这些功能全部都是需要商业授权才能在生产环境中使用,但根据Oracle Binary Code协议,在个人开发环境中,允许免费使用JMC和JFR,本节笔者将简要介绍它们的原理和使用。</p>
<h3 id="JFR-Java-Flight-Recorder"><a class="header-anchor" href="#JFR-Java-Flight-Recorder">¶</a>JFR(Java Flight Recorder)</h3>
<p>JFR是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜集框架,与其他的监控工具(如JProfiling)相比,Oracle特别强调它“可持续在线”(Always-On)的特性。JFR在生产环境中对吞吐量的影响一般不会高于1%(甚至号称是Zero Performance Overhead),而且JFR监控过程的开始、停止都是完全可动态的,即不需要重启应用。JFR的监控对应用也是完全透明的,即不需要对应用程序的源码做任何修改,或者基于特定的代理来运行。</p>
<p>JMC最初是BEA公司的产品,因此并没有像VisualVM那样一开始就基于自家的Net-Beans平台来开发,而是选择了由IBM捐赠的Eclipse RCP作为基础框架,现在的JMC不仅可以下载到<a href="https://www.oracle.com/java/technologies/javase/products-jmc7-downloads.html" target="_blank" rel="noopener">独立程序</a>,更常见的是作为Eclipse的插件来使用。JMC与虚拟机之间同样采取JMX协议进行通信,JMC一方面作为JMX控制台,显示来自虚拟机MBean提供的数据;另一方面作为JFR的分析工具,展示来自JFR的数据。</p>
<h3 id="启动JMC并连接JVM"><a class="header-anchor" href="#启动JMC并连接JVM">¶</a>启动JMC并连接JVM</h3>
<ul>
<li>
<p>本地JVM</p>
<p>打开JMC后在左侧的“JVM浏览器”面板中自动显示了通过JDP协议(Java Discovery Protocol)找到的本机正在运行的HotSpot虚拟机进程<img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232656.png" alt="image-20200920180627703"></p>
</li>
<li>
<p>远程JVM</p>
<ul>
<li>
<p>如果需要监控其他远程服务器上的虚拟机,可在“文件-&gt;连接”菜单中创建远程连接。然后根据引导输入远程连接信息，通常包括host、port、authenticatin等信息。</p>
</li>
<li>
<p>另外需要远程服务器的JVM启动时增加参数：</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">-Dcom.sun.management.jmxremote.port=9999 
-Dcom.sun.management.jmxremote.ssl=false 
-Dcom.sun.management.jmxremote.authenticate=false 
-Djava.rmi.server.hostname=192.168.31.4 
-XX:+UnlockCommercialFeatures 
-XX:+FlightRecorder
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="使用飞行记录仪"><a class="header-anchor" href="#使用飞行记录仪">¶</a>使用飞行记录仪</h3>
<p>双击“飞行记录器”,将会出现“启动飞行记录”窗口。</p>
<p>在启动飞行记录时,可以进行记录时间、垃圾收集器、编译器、方法采样、线程记录、异常记录、网络和文件I/O、事件记录等选项和频率设定。点击“完成”按钮后马上就会开始记录,记录时间结束以后会生成飞行记录报告：</p>
<p>飞行记录报告里包含以下几类信息:</p>
<ul>
<li>一般信息:关于虚拟机、操作系统和记录的一般信息。</li>
<li>内存:关于内存管理和垃圾收集的信息。</li>
<li>代码:关于方法、异常错误、编译和类加载的信息。</li>
<li>线程:关于应用程序中线程和锁的信息。</li>
<li>I/O:关于文件和套接字输入、输出的信息。</li>
<li>系统:关于正在运行Java虚拟机的系统、进程和环境变量的信息。</li>
<li>事件:关于记录中的事件类型的信息,可以根据线程或堆栈跟踪,按照日志或图形的格式查看。</li>
</ul>
<p>JFR的基本工作逻辑是开启一系列事件的录制动作,当某个事件发生时,这个事件的所有上下文数据将会以循环日志的形式被保存至内存或者指定的某个文件当中,循环日志相当于数据流被保留在一个环形缓存中,所以只有最近发生的事件的数据才是可用的。JMC从虚拟机内存或者文件中读取并展示这些事件数据,并通过这些数据进行性能分析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221232705.png" alt="image-20200920181646036"></p>
<p>即使不考虑对被测试程序性能影响方面的优势,JFR提供的数据质量通常也要比其他工具通过代理形式采样获得或者从MBean中取得的数据高得多。以垃圾搜集为例,HotSpot的MBean中一般有各个分代大小、收集次数、时间、占用率等数据(根据收集器不同有所差别),这些都属于“结果”类的信息,而JFR中还可以看到内存中这段时间分配了哪些对象、哪些在TLAB中(或外部)分配、分配速率和压力大小如何、分配归属的线程、收集时对象分代晋升的情况等,这些就是属于“过程”类的信息, 对排查问题的价值是难以估量的。</p>
<h3 id="使用命令行启动飞行记录仪"><a class="header-anchor" href="#使用命令行启动飞行记录仪">¶</a>使用命令行启动飞行记录仪</h3>
<p>解锁JDK的商业特性：</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">jcmd 1152 VM.unlock_commercial_features
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用命令行启动JFR</p>
<pre class="line-numbers language-language-shell"><code class="language-language-shell">jcmd 41250 JFR.start delay=10s duration=1m filename=/Users/cc/Desktop/log.jfr
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>保存下来的JFR文件除了JMC可以打开，VisualVm也可以打开。</p>
<h1>HotSpot虚拟机插件及工具</h1>
<p>一些HotSpot研发过程中编写的插件和工具，这些工具大多数都在JDK源码(存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下)中包含：</p>
<ul>
<li>Ideal Graph Visualizer:用于可视化展示C2即时编译器是如何将字节码转化为理想图,然后转化为机器码的。</li>
<li>Client Compiler Visualizer:用于查看C1即时编译器生成高级中间表示(HIR),转换成低级中间表示(LIR)和做物理寄存器分配的过程(源码其实从未进入过HotSpot的代码仓库)。</li>
<li>MakeDeps:帮助处理HotSpot的编译依赖的工具。</li>
<li>Project Creator:帮忙生成Visual Studio的.project文件的工具。</li>
<li>LogCompilation:将<code>-XX:+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li>
<li>HSDIS:即时编译器的反汇编插件(OpenJDK源码中的位置：hotspot/src/share/tools/hsdis/)。</li>
</ul>
<h2 id="HSDIS"><a class="header-anchor" href="#HSDIS">¶</a>HSDIS</h2>
<p>HSDIS是一个被官方推荐的HotSpot虚拟机即时编译代码的反汇编插件,它包含在HotSpot虚拟机的源码当中[2],在OpenJDK的网站[3]也可以找到单独的源码下载,但并没有提供编译后的程序。</p>
<p>HSDIS插件的作用是让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出,同时还会自动产生大量非常有价值的注释,这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p>
<ul>
<li>可以根据自己的操作系统和处理器型号,从网上直接搜索（<a href="http://hllvm.group.iteye.com" target="_blank" rel="noopener">HLLVM圈子有编译好的</a>）、下载编译好的插件,直接放到<code>JDK_HOME/jre/bin/server</code>目录(JDK 9以下)或<code>JDK_HOME/lib/amd64/server</code>(JDK 9或以上)中即可使用。</li>
<li>或者自己用源码编译一遍(网上能找到各种操作系统下的编译教程)。</li>
</ul>
<p>另外还有一点需要注意,如果读者使用的是SlowDebug或者FastDebug版的HotSpot,那可以直接通过<code>-XX:+PrintAssembly</code>指令使用的插件;如果读者使用的是Product版的HotSpot,则还要额外加入一个<code>-XX:+UnlockDiagnosticVMOptions</code>参数才可以工作。</p>
<h3 id="例子"><a class="header-anchor" href="#例子">¶</a>例子</h3>
<pre class="line-numbers language-language-java"><code class="language-language-java">package john;
/**
 * 参数：
 * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly //打印编译器的汇编
 * -Xcomp  //使用编译器模式
 * -XX:+TraceClassLoading -XX:+LogCompilation 
 * -XX:LogFile=./logfile.log    //将日志输出到一个文件 
 * -XX:CompileCommand=dontinline,*Bar.sum -XX:CompileCommand=compileonly,*Bar.sum   //不进行方法内联
 * 
 * @author: honphan.john
 * @date: 2020/9/19 08:34
 * @description:
 */
public class Bar {
    int a = 1;
    static int b = 2;

    public int sum(int c) {
        return a + b + c;
    }

    public static void main(String[] args) {
        new Bar().sum(3);
    }
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中测试代码比较简单,肉眼直接看日志中的汇编输出是可行的,但在正式环境中<code>-XX:+PrintAssembly</code>的日志输出量巨大,且难以和代码对应起来,这就必须使用工具来辅助了。</p>
<h3 id="JITWatch"><a class="header-anchor" href="#JITWatch">¶</a><a href="https://github.com/AdoptOpenJDK/jitwatch" target="_blank" rel="noopener">JITWatch</a></h3>
<p>JITWatch是HSDIS经常搭配使用的可视化的编译日志分析工具,为便于在JITWatch中读取。下载JITWatch后即可导入输出的汇编日志，即可进行Java源码、字节码、汇编的对比查看。</p>
<h1></h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>需要远程主机提供RMI支持,JDK中提供了jstatd工具可以很方便地建立远程RMI服务器 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《JVM 调优工具及辅助工具》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/12/22/jvm/diao-you/diao-you-gong-ju-ji-fu-zhu-gong-ju/" property="cc:attributionName"
               rel="cc:attributionURL">
                阿钟
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '466e387c08bce10f3f28',
        clientSecret: '5b2bf16f8a42bd72eef32e50187c7f2ccb105a1d',
        repo: 'azhong.github.io',
        owner: 'JohnZhongg',
        admin: "JohnZhongg",
        id: '2020/12/22/jvm/diao-you/diao-you-gong-ju-ji-fu-zhu-gong-ju/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/12/22/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/02-cheng-xu-ji-shu-ji-cun-qi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="02_程序计数寄存器">
                        
                        <span class="card-title">02_程序计数寄存器</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            02_程序计数寄存器
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JVM学习/" class="post-category" target="_blank">
                                    JVM学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM学习/" target="_blank">
                        <span class="chip bg-color">JVM学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/12/22/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/10-stringtable/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="10_StringTable">
                        
                        <span class="card-title">10_StringTable</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            10_StringTable
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JVM学习/" class="post-category" target="_blank">
                                    JVM学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JVM学习/" target="_blank">
                        <span class="chip bg-color">JVM学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2020- Azhong. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">632.8k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JohnZhongg" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:707845008@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/change-94-17" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=707845008&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


<!-- 


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 12, 20, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>