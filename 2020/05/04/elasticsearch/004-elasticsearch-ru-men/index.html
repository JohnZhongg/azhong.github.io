<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="004_Elasticsearch 入门, 技术博客 钟鸿鹏 honphan 阿钟">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="[toc]
一、基本概念：索引、文档和 REST API文档
Elasticsearch 是面向文档的，文档是所有可搜索数据的最小单位，以下都可以理解为一个文档

日志文件中的日志项
一本电影的具体信息、一张唱片的详细信息
MP3播放器里的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>004_Elasticsearch 入门 | 阿钟的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">阿钟的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">阿钟的博客</div>
        <div class="logo-desc">
            
            广东工业大学 | 计算机科学与技术
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JohnZhongg" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JohnZhongg" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        004_Elasticsearch 入门
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/ES学习/" target="_blank">
                            <span class="chip bg-color">ES学习</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/ES学习/" class="post-category" target="_blank">
                            ES学习
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-04
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    阿钟
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    51 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[toc]</p>
<h1 id="一、基本概念：索引、文档和-REST-API"><a href="#一、基本概念：索引、文档和-REST-API" class="headerlink" title="一、基本概念：索引、文档和 REST API"></a>一、基本概念：索引、文档和 REST API</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ol>
<li><p>Elasticsearch 是面向文档的，文档是所有可搜索数据的最小单位，以下都可以理解为一个文档</p>
<ul>
<li>日志文件中的日志项</li>
<li>一本电影的具体信息、一张唱片的详细信息</li>
<li>MP3播放器里的一首歌、一篇 PDF 文档中的具体内容</li>
</ul>
<p>从数据结构的定位上来讲可以类比到关系型数据库中的行或者记录(row/record)。</p>
</li>
<li><p>文档会被序列化成 JSON 格式，保存在 Elasticsearch 中</p>
<ul>
<li>JSON 对象由字段组成</li>
<li>每个字段都有对应的字段类型（字符串、数值、布尔、日期、二进制、范围类型）</li>
</ul>
<ul>
<li>JSON 文档，格式灵活，不需要预先定义格式，字段类型可以指定或者通过 Elasticsearch 自动推算</li>
<li>支持数组、支持嵌套</li>
</ul>
<p>下面是一个  CSV 文件的一行数据导入 Es 之后转换成的一个 JSON 文档:<img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010602.png" alt="image-20200424004733019"></p>
</li>
<li><p>每个文档都有一个 Unique ID</p>
<ul>
<li>可以自己指定 ID</li>
<li>或者通过 Elasticsearch 自动生成</li>
</ul>
</li>
<li><p>文档的元数据，用于标注文档的相关信息</p>
<ul>
<li>_index：文档所属的索引名</li>
<li>_type：文档的类型的名称</li>
<li>_id：文档唯一 ID</li>
<li>_source：文档的原始 JSON 数据</li>
<li>_all：整合所有字段内容到该字段，7.0开始已被废除。（早期是将所有这些字段整合到这一个字段，方便文档的检索）</li>
<li>_version：文档的版本信息（当有大量数据并发读写的时候，可以解决文档冲突问题）</li>
<li>_score：相关性打分</li>
</ul>
</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol>
<li><p>Index：索引是文档的容器，是一类相似文档的集合</p>
<ul>
<li>Index 体现了逻辑空间的概念：每个索引都有自己的 Mapping 定义，用于定义包含的文档的字段名和字段类型</li>
<li>Shard 体现了物理空间的概念：索引中的数据分散在 Shard 上。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010613.png" alt="image-20200424005500809"></p>
</li>
<li><p>索引的 Mapping 和 Settings</p>
<ul>
<li>Mapping 定义文档字段的类型</li>
<li>Setting 定义不同的数据分布（Shard）</li>
</ul>
</li>
<li><p>索引的不同语意</p>
<ul>
<li>名称：一个 Elasticsearch 集群中，可以创建很多不同的索引</li>
<li>动词：保存一个文档到 Elasticsearch 的过程也叫索引（indexing）<ul>
<li>ES 中，创建一个倒排索引的过程</li>
</ul>
</li>
<li>名称：一个 B 树索引，一个倒排索引</li>
</ul>
</li>
<li><p>Type</p>
<ul>
<li>在7.0之前，一个 Index 可以设置多个 Type，每个 Type 下面拥有一些相同结构的文档</li>
<li>6.0开始，Type 已经被 Deprecated。7.0开始，一个索引只能创建一个 Type–”_doc”。</li>
</ul>
<blockquote>
<p><a href="https://www.elastic.co/cn/blog/moving-from-types-to-typeless-apis-in-elasticsearch-7-0" target="_blank" rel="noopener">为什么不再支持单个Index下，多个Types</a></p>
</blockquote>
</li>
</ol>
<h2 id="抽象与类比"><a href="#抽象与类比" class="headerlink" title="抽象与类比"></a>抽象与类比</h2><ul>
<li><p>传统关系型数据库和 ES概念类比<img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010622.png" alt="image-20200424010237527"></p>
</li>
<li><p>两者区别：</p>
<ul>
<li>Elasticsearch：Schemaless、相关性、高性能全文检索</li>
<li>RDBMS：事务性、Join</li>
</ul>
</li>
</ul>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010630.png" alt="image-20200424010449342"></p>
<p>Elasticsearch 支持 Transport API 和 REST API，推荐使用 REST API。</p>
<h3 id="一些基本的-API"><a href="#一些基本的-API" class="headerlink" title="一些基本的 API"></a>一些基本的 API</h3><ul>
<li><p>Indices</p>
<ul>
<li>创建 Index<ul>
<li>PUT Movies</li>
</ul>
</li>
<li>查看所有 Index<ul>
<li>_cat/indices</li>
</ul>
</li>
</ul>
</li>
<li><p>API 尝试</p>
<pre><code>#查看索引相关信息
GET kibana_sample_data_ecommerce

#查看索引的文档总数
GET kibana_sample_data_ecommerce/_count

#查看前10条文档，了解文档格式
POST kibana_sample_data_ecommerce/_search
{
}

#_cat indices API
#查看indices
GET /_cat/indices/kibana*?v&amp;s=index

#查看状态为绿的索引
GET /_cat/indices?v&amp;health=green

#按照文档个数排序
GET /_cat/indices?v&amp;s=docs.count:desc

#查看具体的字段
GET /_cat/indices/kibana*?pri&amp;v&amp;h=health,index,pri,rep,docs.count,mt

#How much memory is used per index?
GET /_cat/indices?v&amp;h=i,tm&amp;s=tm:desc</code></pre></li>
</ul>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cat-indices.html" target="_blank" rel="noopener">CAT Index API</a></p>
</blockquote>
<h3 id="索引管理功能"><a href="#索引管理功能" class="headerlink" title="索引管理功能"></a>索引管理功能</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010638.png" alt="image-20200424010738677"></p>
<h1 id="二、基本概念：节点、集群、分片及副本"><a href="#二、基本概念：节点、集群、分片及副本" class="headerlink" title="二、基本概念：节点、集群、分片及副本"></a>二、基本概念：节点、集群、分片及副本</h1><h2 id="分布式系统的可用性与扩展性"><a href="#分布式系统的可用性与扩展性" class="headerlink" title="分布式系统的可用性与扩展性"></a>分布式系统的可用性与扩展性</h2><ol>
<li>高可用性<ul>
<li>服务可用性：允许有节点停止服务</li>
<li>数据可用性：部分节点丢失，不会丢失数据</li>
</ul>
</li>
<li>可扩展性<ul>
<li>请求量提升、数据的不断增长（将数据分布到所有节点上，实现水平扩展）</li>
</ul>
</li>
</ol>
<h2 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h2><ol>
<li>Elasticsearch 的分布式架构的好处<ul>
<li>存储的水平扩容</li>
<li>提高系统的可用性，部分节点停止服务，整个集群的服务不受影响</li>
</ul>
</li>
<li>Elasticsearach 的分布式架构<ul>
<li>不同的集群通过不同的名字来区分，默认名称”elasticsearch”</li>
<li>通过配置文件修改，或者在命令行<code>-E cluster.name=geektime</code> 进行设定</li>
<li>一个集群可以有一个或者多个节点</li>
</ul>
</li>
</ol>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><ol>
<li>节点是一个 Elasticsearch 的实例<ul>
<li>本质上就是一个 JAVA 进程</li>
<li>一台机器上可以运行多个 Elasticsearch 进程，但是生产环境一般建议一台机器上只运行一个 Elasticsearch 实例</li>
</ul>
</li>
<li>每一个节点都有名字，通过配置文件配置，或者启动的时候<code>-E node.name=node1</code>指定</li>
<li>每一个节点在启动之后，会分配一个 UID，保存在 data 目录下</li>
</ol>
<h3 id="Master-eligible-nodes-和-Master-Node"><a href="#Master-eligible-nodes-和-Master-Node" class="headerlink" title="Master-eligible nodes 和 Master Node"></a>Master-eligible nodes 和 Master Node</h3><ul>
<li>每个节点启动后，默认就是一个 Master eligible 节点<ul>
<li>可以设置<code>node.master:false</code>禁止</li>
</ul>
</li>
<li>Master-eligible 节点可以参加选主流程，称为 Master 节点</li>
<li>当第一个节点启动的时候，它会将自己选举成 Master 节点</li>
<li>每个节点上都保存了集群的状态，只有 Master 节点才能修改集群的状态信息<ul>
<li>集群状态（Cluster State），维护了一个集群中必要的信息<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的 Mapping 与 Setting 信息</li>
<li>分片的路由信息</li>
</ul>
</li>
<li>如果任意节点都能修改信息会导致数据的不一致性，使得集群变得混乱</li>
</ul>
</li>
</ul>
<h3 id="Data-Node-amp-Coordinating-Node"><a href="#Data-Node-amp-Coordinating-Node" class="headerlink" title="Data Node &amp; Coordinating Node"></a>Data Node &amp; Coordinating Node</h3><ul>
<li>Data Node<ul>
<li>可以保存数据的节点，叫做 Data Node。负责保存分片数据。在数据扩展是起到了至关重要的作用</li>
<li>当集群无法再分配数据的时候，可以增加一个数据节点来解决</li>
</ul>
</li>
<li>Coordinating Node<ul>
<li>负责接受 Client 的请求，将请求分发到合适的节点，最终把结果汇集到一起进行响应给调用的客户端</li>
<li>每个节点默认都起到了 Coordinating Node 的职责</li>
</ul>
</li>
</ul>
<h3 id="其他类型的节点"><a href="#其他类型的节点" class="headerlink" title="其他类型的节点"></a>其他类型的节点</h3><ul>
<li>Hot &amp; Warm Node<ul>
<li>不同硬件配置的 Data Node，用来实现 Hot &amp; Warm 架构，热数据存储在 Hot 节点（高配），冷数据存储在 Warm 节点（低配），降低集群部署的成本</li>
</ul>
</li>
<li>Machine Learning Node<ul>
<li>负责跑机器学习的 Job，用来做异常检测及告警</li>
</ul>
</li>
<li>Tribe Node<ul>
<li>（5.3开始使用 Cross Cluster Search）Tribe Node 连接到不同的 Elasticsearch 集群，并且支持将这些集群当成一个单独的集群处理</li>
</ul>
</li>
</ul>
<h3 id="配置节点类型"><a href="#配置节点类型" class="headerlink" title="配置节点类型"></a>配置节点类型</h3><ul>
<li>开发环境中一个节点可以承担多种角色</li>
<li>生产环境中，应该设置单一的角色的节点（dedicated node）<ul>
<li>可以有更好的性能</li>
<li>职责明确，根据不同节点配置不同硬件</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>配置参数</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Master eligible</td>
<td>node.master</td>
<td>true</td>
</tr>
<tr>
<td>data</td>
<td>node.data</td>
<td>true</td>
</tr>
<tr>
<td>ingest</td>
<td>node.ingest</td>
<td>true</td>
</tr>
<tr>
<td>coordinating only</td>
<td>无</td>
<td>每一个节点默认都是 coordinating 节点。设置其他类型全部为 false。</td>
</tr>
<tr>
<td>Machine learning</td>
<td>node.ml</td>
<td>True（需要 enable x=pack）</td>
</tr>
</tbody></table>
<h2 id="分片（Primary-Shard-amp-Replica-Shard）"><a href="#分片（Primary-Shard-amp-Replica-Shard）" class="headerlink" title="分片（Primary Shard &amp; Replica Shard）"></a>分片（Primary Shard &amp; Replica Shard）</h2><ol>
<li><p>主分片</p>
<p>用来解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内的所有节点之上</p>
<ul>
<li>一个分片是一个运行的 Lucene 的实例（索引）</li>
<li>主分片数在索引创建时指定，后续不允许修改，除非 Reindex</li>
</ul>
</li>
<li><p>副本分片</p>
<p>用来解决数据高可用的问题，避免部分节点不可用导致数据丢失。分片是主分片的拷贝</p>
<ul>
<li>副本分片数，可以动态调整</li>
<li>增加副本数，还可以在一定程度上提高服务的可用性（读取的吞吐）</li>
</ul>
</li>
<li><p>举例</p>
<p>一个3节点的集群中，blogs 索引的分片分布情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010648.png" alt="image-20200424070058325"></p>
</li>
<li><p>分片的设定</p>
<p>对于生产环境中分片的设定，需要提前做好容量规划</p>
<ul>
<li>分片数设置过小<ul>
<li>导致后续无法增加节点实现水平扩展</li>
<li>单个分片的数据量太大，导致数据重新分配耗时</li>
</ul>
</li>
<li>分片数设置过大，7.0开始，默认主分片从5改成1，解决了 over-sharding 的问题<ul>
<li>影响搜索结果的相关性打分，影响统计结果的准确性</li>
<li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="查看集群的健康状态"><a href="#查看集群的健康状态" class="headerlink" title="查看集群的健康状态"></a>查看集群的健康状态</h2><ol>
<li><p>REST API: <code>GET _cluster/health</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010653.png" alt="image-20200424070550671"></p>
<ul>
<li>Green：主分片与副本都正常分配</li>
<li>Yellow：主分片全部正常分配，有副本分片未正常分配</li>
<li>Red：有主分片未能分配<ul>
<li>例如，当服务器的磁盘容量超过85%时，去创建了一个新的索引</li>
</ul>
</li>
</ul>
</li>
<li><p>通过 Kibana 查看集群状态</p>
<ul>
<li><p>查看一个集群的健康状态</p>
<p><a href="http://myecs.com:9200/_cluster/health" target="_blank" rel="noopener">http://myecs.com:9200/_cluster/health</a></p>
</li>
<li><p>CAT API</p>
<ul>
<li>httpL//myecs.com:9200/_cat/nodes</li>
<li>查看索引和分片</li>
</ul>
</li>
<li><p>设置分片数</p>
</li>
</ul>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cat-nodes.html" target="_blank" rel="noopener">CAT Nodes API</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cluster.html" target="_blank" rel="noopener">Cluster API</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cat-shards.html" target="_blank" rel="noopener">CAT Shards API</a></p>
</blockquote>
<pre><code>GET _cat/nodes?v
GET /_nodes/es7_01,es7_02
GET /_cat/nodes?v
GET /_cat/nodes?v&amp;h=id,ip,port,v,m

</code></pre></li>
</ol>
<p>   GET _cluster/health<br>   GET _cluster/health?level=shards<br>   GET /_cluster/health/kibana_sample_data_ecommerce,kibana_sample_data_flights<br>   GET /_cluster/health/kibana_sample_data_flights?level=shards</p>
<h4 id="cluster-state"><a href="#cluster-state" class="headerlink" title="cluster state"></a>cluster state</h4><p>   The cluster state API allows access to metadata representing the state of the whole cluster. This includes information such as<br>   GET /_cluster/state</p>
<p>   #cluster get settings<br>   GET /_cluster/settings<br>   GET /_cluster/settings?include_defaults=true</p>
<p>   GET _cat/shards<br>   GET _cat/shards?h=index,shard,prirep,state,unassigned.reason</p>
<pre><code>
3.  通过 Cerebro 查看集群状态

   ![image-20200424072047317](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010704.png)

   当我们尝试停掉一个节点的时候，发现上面的长条变成了黄色

![image-20200424072222820](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010711.png)

# 三、文档的 CRUD与批量操作

## 文档的 CRUD

* Type名，约定都用_doc
* Create：如果 ID 已经存在，会失败
* Index：如果 ID 不存在，创建新的文档；否则，先删除现有的文档，再创建新的文档，版本会增加
* Update：文档必须已经存在，然后对相应字段做增量修改，版本号增加

&gt; [Document API](https://www.elastic.co/guide/en/elasticsearch/reference/7.1/docs.html)

![image-20200424073808066](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010720.png)

### create

* 支持自动生成文档 id 和指定文档 id 两种方式
* 通过调用`post /users/_doc`
  * 系统会自动生成 document id
* 使用 HTTP PUT user/\_create/1 创建时，URI中显示指定\_create，此时如果该 ID 的文档已经存在，操作失败

![image-20200424074516551](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010737.png)

### get

*  找到文档，返回 HTTP 200
  * 文档元信息
    * \_index、\_type
    *  版本信息，同一个 id 的文档，被删除，version 号不断增加
    * \_source 中默认包含了了文档的所有原始信息
* 找不到文档，返回 HTTP 404

![image-20200424074539766](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010750.png)

### index

* index 和 create 区别：如果文档(ID)已存在，前者会删除然后重建然后版本+1；后者会报错

![image-20200424074731377](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010759.png)

### update

* update 方法不会删除原来的文档，要求文档必须存在，否则失败。是实现真正的数据更新

* post 方法，在请求体中将信息包含在&quot;doc&quot;中

  ![image-20200424074841642](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010808.png)

### Bulk API

*  支持在一次 API 调用中，对不同的索引进行操作，减少网络请求
* 支持4种操作类型
  * index
  * create
  * update
  * delete
* 可以在 URI 中指定 index，也可以在请求的 payload 中进行
*  操作中单挑操作失败，并不会影响其他操作
* 返回结果包含了每一条操作执行的结果

![image-20200424075319487](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010812.png)

### mget-批量读取

批量操作，可以减少网络连接所产生的开销，提高性能

![image-20200424075501736](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010821.png)

![image-20200424075508922](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010831.png)

### msearch-批量查询

![image-20200424075601707](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010840.png)

&gt; 注意，虽然上面介绍了批量查询API，但是单次批量查询的数据过大也会引发性能问题。

### 操作的 API demo
</code></pre><p>############Create Document############</p>
<p>#create document. 自动生成 _id<br>POST users/_doc<br>{<br>    “user” : “Mike”,<br>    “post_date” : “2019-04-15T14:12:12”,<br>    “message” : “trying out Kibana”<br>}</p>
<p>#create document. 指定Id。如果id已经存在，报错<br>PUT users/_doc/1?op_type=create<br>{<br>    “user” : “Jack”,<br>    “post_date” : “2019-05-15T14:12:12”,<br>    “message” : “trying out Elasticsearch”<br>}</p>
<p>#create document. 指定 ID 如果已经存在，就报错<br>PUT users/_create/1<br>{<br>     “user” : “Jack”,<br>    “post_date” : “2019-05-15T14:12:12”,<br>    “message” : “trying out Elasticsearch”<br>}</p>
<h3 id="Get-Document-by-ID"><a href="#Get-Document-by-ID" class="headerlink" title="Get Document by ID"></a>Get Document by ID</h3><p>#Get the document by ID<br>GET users/_doc/1</p>
<h3 id="Index-amp-Update"><a href="#Index-amp-Update" class="headerlink" title="Index &amp; Update"></a>Index &amp; Update</h3><p>#Update 指定 ID  (先删除，在写入)<br>GET users/_doc/1</p>
<p>PUT users/_doc/1<br>{<br>    “user” : “Mike”</p>
<p>}</p>
<p>#GET users/_doc/1</p>
<p>#在原文档上增加字段<br>POST users/_update/1/<br>{<br>    “doc”:{<br>        “post_date” : “2019-05-15T14:12:12”,<br>        “message” : “trying out Elasticsearch”<br>    }<br>}</p>
<h3 id="Delete-by-Id"><a href="#Delete-by-Id" class="headerlink" title="Delete by Id"></a>Delete by Id</h3><h1 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h1><p>DELETE users/_doc/1</p>
<h3 id="Bulk-操作"><a href="#Bulk-操作" class="headerlink" title="Bulk 操作"></a>Bulk 操作</h3><p>#执行两次，查看每次的结果</p>
<p>#执行第1次<br>POST _bulk<br>{ “index” : { “_index” : “test”, “_id” : “1” } }<br>{ “field1” : “value1” }<br>{ “delete” : { “_index” : “test”, “_id” : “2” } }<br>{ “create” : { “_index” : “test2”, “_id” : “3” } }<br>{ “field1” : “value3” }<br>{ “update” : {“_id” : “1”, “_index” : “test”} }<br>{ “doc” : {“field2” : “value2”} }</p>
<p>#执行第2次<br>POST _bulk<br>{ “index” : { “_index” : “test”, “_id” : “1” } }<br>{ “field1” : “value1” }<br>{ “delete” : { “_index” : “test”, “_id” : “2” } }<br>{ “create” : { “_index” : “test2”, “_id” : “3” } }<br>{ “field1” : “value3” }<br>{ “update” : {“_id” : “1”, “_index” : “test”} }<br>{ “doc” : {“field2” : “value2”} }</p>
<h3 id="mget-操作"><a href="#mget-操作" class="headerlink" title="mget 操作"></a>mget 操作</h3><p>GET /_mget<br>{<br>    “docs” : [<br>        {<br>            “_index” : “test”,<br>            “_id” : “1”<br>        },<br>        {<br>            “_index” : “test”,<br>            “_id” : “2”<br>        }<br>    ]<br>}</p>
<p>#URI中指定index<br>GET /test/_mget<br>{<br>    “docs” : [<br>        {</p>
<pre><code>        &quot;_id&quot; : &quot;1&quot;
    },
    {

        &quot;_id&quot; : &quot;2&quot;
    }
]</code></pre><p>}</p>
<p>GET /_mget<br>{<br>    “docs” : [<br>        {<br>            “_index” : “test”,<br>            “_id” : “1”,<br>            “_source” : false<br>        },<br>        {<br>            “_index” : “test”,<br>            “_id” : “2”,<br>            “_source” : [“field3”, “field4”]<br>        },<br>        {<br>            “_index” : “test”,<br>            “_id” : “3”,<br>            “_source” : {<br>                “include”: [“user”],<br>                “exclude”: [“user.location”]<br>            }<br>        }<br>    ]<br>}</p>
<h3 id="msearch-操作"><a href="#msearch-操作" class="headerlink" title="msearch 操作"></a>msearch 操作</h3><p>POST kibana_sample_data_ecommerce/_msearch<br>{}<br>{“query” : {“match_all” : {}},”size”:1}<br>{“index” : “kibana_sample_data_flights”}<br>{“query” : {“match_all” : {}},”size”:2}</p>
<h3 id="清除测试数据"><a href="#清除测试数据" class="headerlink" title="清除测试数据"></a>清除测试数据</h3><p>#清除数据<br>DELETE users<br>DELETE test<br>DELETE test2</p>
<pre><code>


###  常见错误返回

![image-20200424075635645](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010850.png)

# 四、倒排索引介绍

## 正排索引和倒排索引

### 类比理解

假设现在有一本关于 Elasticsearch 的书籍，书籍中的每一页可以类比为 Elasticsearch 中的document，文档中所有字段从第一个到最后一个形成一个链条列表，拥有唯一的位置索引。

书籍的目录上记录了页码以及对应的内容名称，整本书可以理解为一个物理存储介质，页码让我们可以快速定位到我们想要找的文档。所以这个目录就是一个索引，而从 id 指向一个文档就是一个正排索引。

另外一些技术书籍会在最后几页放一些技术术语(单词，term)的列表，并标注了它在哪几页出现，这个将文档中的内容指向文档 id 再找到文档进行加载文档内容的过程就是一个倒排索引。

看下表，右边就是一个倒排索引。

![image-20200424094916737](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010857.png)

### 倒排索引的核心组成

倒排索引包含两个部分

* 单词词典(Term Directory)，记录所有文档的单词，记录单词到倒排列表的关联关系（**另外，需要注意，文档下面还有 Field 的概念，它是由 Field 构成的，而 Field 则由 Term 构成**）。单词词典一般比较大，可以通过 B+树或者哈希拉链实现存储，以满足高性能的插入与查询
* 倒排列表(Posting Lisrt)，记录了单词对应的文档集合，由**倒排索引项**组成：
  * 文档 ID
  * 词频 TF：该单词在文档中出现的次数，用于相关性评分
  * 位置（Position）：单词在文档中分词的位置。用于语句搜索（phrase query）
  * 偏移（Offset）：记录单词的开始结束位置，实现高亮显示

![image-20200424140003886](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010901.png)

### 一个例子

Term：&quot;Elasticsearch&quot;

![image-20200424101338760](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010917.png)

&gt; [维基百科倒排索引](https://zh.wikipedia.org/wiki/倒排索引)
&gt;
&gt; [Elasticsearch 官方倒排索引介绍](https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html)

### Elasticsearch 的倒排索引

* Elasticsearch 的 JSON 文档中的每个字段，都有自己的倒排索引
* 可以指定对**某些字段**不做索引
  * 优点：节省存储空间
  * 缺点：字段无法被搜索

# 五、通过 Analyzer 进行分词

## Analysis 与 Analyzer

1. Analyses（动词）：文本分析是把全文本转换一系列单次（term/token）的过程，也叫分词。

2. Analysis 是通过 Analyzer 来实现的， Analyzer 叫分析器也叫分词器，可以使用 Elasticsearch 内置的分词器，或者按需定制化分词器。

   在数据写入的时候，Es 对所有需要进行索引的字段或者字符串进行分词转换成词条（Term）并建立倒排索引，在匹配 Query 语句（例如用户搜索）的时候也需要用相同的分词器对查询语句进行分析

## Analyzer 的组成

分词器时专门处理分词的组件，Analyzer 由三部分组成

* Character Filters：针对原始文本处理，例如去除 html 标签等
* Tokenizer：按照规则切分为单词
* Token Filter：将切分的单词进行加工，例如转小写、删除`stopwords`、增加同义词等。

![image-20200424102801647](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010926.png)

## Elasticsearch 的内置分词器



* Standard Analyzer：默认分词器，按词切分，小写处理

  ![image-20200424103654570](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091441.png)

* Simple Analyzer：按照非字母切分（非字母字符被过滤），小写处理

  ![image-20200424103757386](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091450.png)

* Stop Analyzer：小写处理，过滤停用词（the，a，is 等）

  ![image-20200424103910533](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010942.png)

* Whitespace Analyzer：按照空格切分，不转小写

  ![image-20200424103844356](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010949.png)

* Keyword Analyzer：不分词，直接将输入当做输出

  ![image-20200424103930169](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010954.png)

* Patter Analyzer：按照正则表达式作为词条匹配进行分词，默认&quot;\W+&quot;（非字符分割）

  ![image-20200424103949168](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220010957.png)

* Customer Analyzer：自定义分词器

* Language：提供了30多种常见语言的分词器

  ![image-20200424104052168](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220011023.png)

## 特别的中文分词与非官方分词器

1. 中文分词的难点：
   - 中文句子不像英文这样单词之间有自然的空格作为分隔，也不能直接将一个句子直接切分一个个字。
   - 一句中文，在不同的上下文，有不同的理解。（&quot;这个苹果，不大好吃&quot;与&quot;这个苹果不大，好吃&quot;、&quot;他说的确实在理&quot;和&quot;这事的确定不下来&quot;的&quot;确实&quot;怎么分词）

2. ICU Analyzer：提供了 Unicode 的支持，更好的支持亚洲语言。它是一个插件，需要额外安装`Elasticsearch-plugin install analysis-icu`

   ![image-20200424104737117](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220011016.png)

   docker 容器安装 ICU Analyzer：

   ```shell
   [root@izwz920kp0myp15p982vp4z ~]# docker ps
   CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                              NAMES
   d9b19ed43e4c        kibana:7.1.0             &quot;/usr/local/bin/ki...&quot;   12 hours ago        Up 12 hours         0.0.0.0:5601-&gt;5601/tcp             kibana7
   d5e50115e6ad        elasticsearch:7.1.0      &quot;/usr/local/bin/do...&quot;   12 hours ago        Up 12 hours         0.0.0.0:9200-&gt;9200/tcp, 9300/tcp   es7_01
   cc44536c68b5        elasticsearch:7.1.0      &quot;/usr/local/bin/do...&quot;   12 hours ago        Up 12 hours         9200/tcp, 9300/tcp                 es7_02
   e99e24660b33        lmenezes/cerebro:0.8.3   &quot;/opt/cerebro/bin/...&quot;   12 hours ago        Up 12 hours         0.0.0.0:9000-&gt;9000/tcp             cerebro
   [root@izwz920kp0myp15p982vp4z ~]# docker exec -it es7_01 bash
   [root@d5e50115e6ad elasticsearch]# ./bin/elasticsearch-plugin install analysis-icu
   -&gt; Downloading analysis-icu from elastic
   [=================================================] 100%??
   WARNING: An illegal reflective access operation has occurred
   WARNING: Illegal reflective access by org.bouncycastle.jcajce.provider.drbg.DRBG (file:/usr/share/elasticsearch/lib/tools/plugin-cli/bcprov-jdk15on-1.61.jar) to constructor sun.security.provider.Sun()
   WARNING: Please consider reporting this to the maintainers of org.bouncycastle.jcajce.provider.drbg.DRBG
   WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
   WARNING: All illegal access operations will be denied in a future release
   -&gt; Installed analysis-icu
   [root@d5e50115e6ad elasticsearch]# exit
   exit
   [root@izwz920kp0myp15p982vp4z ~]# docker exec -it es7_02 bash
   [root@cc44536c68b5 elasticsearch]# ./bin/elasticsearch-plugin install analysis-icu
   -&gt; Downloading analysis-icu from elastic
   [=================================================] 100%??
   WARNING: An illegal reflective access operation has occurred
   WARNING: Illegal reflective access by org.bouncycastle.jcajce.provider.drbg.DRBG (file:/usr/share/elasticsearch/lib/tools/plugin-cli/bcprov-jdk15on-1.61.jar) to constructor sun.security.provider.Sun()
   WARNING: Please consider reporting this to the maintainers of org.bouncycastle.jcajce.provider.drbg.DRBG
   WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
   WARNING: All illegal access operations will be denied in a future release
   -&gt; Installed analysis-icu
   [root@cc44536c68b5 elasticsearch]# exit
   exit
   [root@izwz920kp0myp15p982vp4z ~]# cd /usr/local/software/elasticsearch/docker-es-7.x/
   [root@izwz920kp0myp15p982vp4z docker-es-7.x]# docker-compose restart
   Restarting kibana7 ... done
   Restarting es7_01  ... done
   Restarting es7_02  ... done
   Restarting cerebro ... done</code></pre><p>   <img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220011033.png" alt="image-20200424110740213"></p>
<p>   安装成功！</p>
<ol start="3">
<li><p>更多的中文分词器</p>
<ul>
<li><p><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">IK</a>：支持自定义词库，支持热更新分词字典。安装方法参考上面的<code>AnalysisICU</code>。</p>
<pre class="line-numbers language-shell"><code class="language-shell">[root@cc44536c68b5 elasticsearch]# bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.1.0/elasticsearch-analysis-ik-7.1.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220011039.png" alt="image-20200424111035461"></p>
<p>分词效果测试：</p>
<pre><code>POST _analyze
{
  &quot;analyzer&quot;: &quot;ik_smart&quot;
  , &quot;text&quot;: &quot;中华人民共和国国歌&quot;
}

POST _analyze
{
  &quot;analyzer&quot;: &quot;ik_max_word&quot;
  , &quot;text&quot;: &quot;中华人民共和国国歌&quot;
}</code></pre><p>结果：</p>
<ul>
<li><p>ik_max_word：会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合，适合 Term Query；</p>
</li>
<li><p>ik_smart：会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase 查询。</p>
</li>
</ul>
</li>
<li><p><a href="https://github.com/microbun/elasticsearch-thulac-plugin" target="_blank" rel="noopener">THULAC</a>：THU Lexucal Analyzer for Chinese，清华大学自然语言处理和社会人文计算实验室的一套中文分词器</p>
</li>
</ul>
</li>
</ol>
<h3 id="使用-analyzer-API"><a href="#使用-analyzer-API" class="headerlink" title="使用_analyzer API"></a>使用_analyzer API</h3><ol>
<li><p>直接指定 Analyzer 进行测试，并传入一个字符串看分词器对字符串的分词结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220011047.png" alt="image-20200424103412283"></p>
</li>
<li><p>指定索引的字段进行测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220084315.png" alt="image-20200424103444135"></p>
</li>
<li><p>自定义分词器进行测试（例如自定义它的”tokenizer”和”filter”）</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220084321.png" alt="image-20200424103504473"></p>
<p>测试请求：</p>
</li>
</ol>
<pre><code>#Simple Analyzer – 按照非字母切分（符号被过滤），小写处理
#Stop Analyzer – 小写处理，停用词过滤（the，a，is）
#Whitespace Analyzer – 按照空格切分，不转小写
#Keyword Analyzer – 不分词，直接将输入当作输出
#Patter Analyzer – 正则表达式，默认 \W+ (非字符分隔)
#Language – 提供了30多种常见语言的分词器
#2 running Quick brown-foxes leap over lazy dogs in the summer evening

#查看不同的analyzer的效果
#standard
GET _analyze
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}

#simpe
GET _analyze
{
  &quot;analyzer&quot;: &quot;simple&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}


GET _analyze
{
  &quot;analyzer&quot;: &quot;stop&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}


#stop
GET _analyze
{
  &quot;analyzer&quot;: &quot;whitespace&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}

#keyword
GET _analyze
{
  &quot;analyzer&quot;: &quot;keyword&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}

GET _analyze
{
  &quot;analyzer&quot;: &quot;pattern&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}


#english
GET _analyze
{
  &quot;analyzer&quot;: &quot;english&quot;,
  &quot;text&quot;: &quot;2 running Quick brown-foxes leap over lazy dogs in the summer evening.&quot;
}


POST _analyze
{
  &quot;analyzer&quot;: &quot;icu_analyzer&quot;,
  &quot;text&quot;: &quot;他说的确实在理”&quot;
}


POST _analyze
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;: &quot;他说的确实在理”&quot;
}


POST _analyze
{
  &quot;analyzer&quot;: &quot;icu_analyzer&quot;,
  &quot;text&quot;: &quot;这个苹果不大好吃&quot;
}

POST _analyze
{
  &quot;analyzer&quot;: &quot;ik_smart&quot;
  , &quot;text&quot;: &quot;中华人民共和国国歌&quot;
}

POST _analyze
{
  &quot;analyzer&quot;: &quot;ik_max_word&quot;
  , &quot;text&quot;: &quot;中华人民共和国国歌&quot;
}</code></pre><h1 id="六、Search-API"><a href="#六、Search-API" class="headerlink" title="六、Search API"></a>六、Search API</h1><h2 id="API-URI"><a href="#API-URI" class="headerlink" title="API URI"></a>API URI</h2><table>
<thead>
<tr>
<th>语法</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>/_search</td>
<td>集群上所有的索引</td>
</tr>
<tr>
<td>/index1/_search</td>
<td>index1</td>
</tr>
<tr>
<td>/index,index2/_search</td>
<td>index1和 index2</td>
</tr>
<tr>
<td>/index*/_search</td>
<td>以index 开头的索引</td>
</tr>
</tbody></table>
<h2 id="API-请求方式"><a href="#API-请求方式" class="headerlink" title="API 请求方式"></a>API 请求方式</h2><ol>
<li><p>URI Search（GET）</p>
<p>在 URL 中使用查询参数</p>
<ul>
<li><p>“q”为 http get 作为参数，”query string syntax”为 http get 参数值，内容为”key:value”</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220084329.png" alt="image-20200424113906460"></p>
</li>
</ul>
</li>
<li><p>Request Body Search（GET、POST）</p>
<p>使用 Elasticsearch 提供的，基于 JSON 格式的更加完备的 Query Domain Specific Language（DSL）</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220090939.png" alt="image-20200424113930239"></p>
</li>
</ol>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220090949.png" alt="image-20200424114052223"></p>
<h3 id="文档元信息：-score"><a href="#文档元信息：-score" class="headerlink" title="文档元信息：_score"></a>文档元信息：_score</h3><p>这个字段表示了这个文档的匹配打分，表示了其与搜索关键字的相关性（Relevance）。</p>
<ul>
<li><p>搜索是用户和搜索引擎的对话</p>
</li>
<li><p>用户关心的是搜索结果的相关性：</p>
<ol>
<li>是否可以找到所有相关的内容</li>
<li>有多少不相关的内容被返回了</li>
<li>文档的打分是否合理</li>
<li>结合业务需求，平衡结果排名</li>
</ol>
<p>例如搜索苹果，如果我想找的是苹果手机就不能返回水果的苹果</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220090957.png" alt="image-20200424114432782"></p>
</li>
</ul>
<h3 id="Web搜索"><a href="#Web搜索" class="headerlink" title="Web搜索"></a>Web搜索</h3><ul>
<li><p>Page Rank算法</p>
<ul>
<li>不仅仅是内容相关性</li>
<li>更重要的是内容的可信度</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091007.png" alt="image-20200424114907945"></p>
</li>
</ul>
<h3 id="电商搜索"><a href="#电商搜索" class="headerlink" title="电商搜索"></a>电商搜索</h3><ul>
<li><p>搜索引擎扮演-销售的角色</p>
<ul>
<li>提高用户购物体验</li>
<li>提升网站销售业绩</li>
<li>帮助仓库消除积压库存，需要对这些需要清仓的商品进行排序提升</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091014.png" alt="image-20200424114954157"></p>
</li>
</ul>
<h3 id="衡量相关性（Information-Retrieval）"><a href="#衡量相关性（Information-Retrieval）" class="headerlink" title="衡量相关性（Information Retrieval）"></a>衡量相关性（Information Retrieval）</h3><ul>
<li>Precision（查准率）：尽可能返回较少的无关文档</li>
<li>Recall（查全率）：尽量返回较多的相关文档</li>
<li>Ranking：是否能够按照相关度进行排序</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091022.png" alt="image-20200424115313132"></p>
<p>Elasticsearch 提供了很多参数来调整 Precision 和 Recall。</p>
<h2 id="URI-search-详解"><a href="#URI-search-详解" class="headerlink" title="URI search 详解"></a>URI search 详解</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091030.png" alt="image-20200424123444164"></p>
<ul>
<li>q指定查询语句，使用 Query String Syntax</li>
<li>df 默认字段，不指定时，会对所有字段进行查询</li>
<li>sort 排序</li>
<li>from、size 用于分页</li>
<li>Profile 可以查看查询是如何被执行的</li>
</ul>
<h3 id="Query-String-Syntax"><a href="#Query-String-Syntax" class="headerlink" title="Query String Syntax"></a>Query String Syntax</h3><ol>
<li><p>指定字段 v.s. 泛查询(DisjunctionMaxQuery)</p>
<p>q=title:2012、q=2012&amp;df=title</p>
<p>q=2012、没有指定字段，会对所有字段进行查询</p>
</li>
<li><p>TermQuery v.s. PhraseQuery（最严格的规则求尽量准的合集）</p>
<ul>
<li><p>TermQuery：最松懈的规则匹配的求尽量大的合集，也就是将查询字符串尽可能地拆分成最多的 Term 进行到倒排索引中检索文档，示例：</p>
<p>Beautiful Mind（等效于 Beautiful OR Mind）</p>
</li>
<li><p>PhraseQuery：最严格的规则求尽量准的合集，示例：</p>
<p>“Beautiful Mind”（<strong>用双引号包住</strong>，等效于 Beautiful AND Mind。还要求前后顺序保持一致）</p>
</li>
</ul>
</li>
<li><p>分组（圆括号）与引号</p>
<ul>
<li><p>title:Beautiful Mind</p>
<p>会对”Beautiful”做”title”字段的 TremQuery，对”Mind”做所有字段的 DisjunctionMaxQuery，和我们预计的对 title 字段做”Beautiful OR Mind”的操作不一致，此时需要用到 Elasticsearch 的分组的概念，就是用圆括号括住</p>
</li>
<li><p>title:(Beautiful Mind)</p>
<p>对字段 title 做”Beautiful OR Mind”的查询</p>
</li>
<li><p>title:(Beautilful AND Mind)</p>
</li>
<li><p>tile=”Beautiful Mind”（PhraseQuery）</p>
</li>
</ul>
</li>
<li><p>布尔操作</p>
<p>AND、OR、NOT 或者 &amp;&amp;、||、!</p>
<ul>
<li>必须大写</li>
<li>title:(matrix NOT reloaded)</li>
</ul>
</li>
<li><p>是否必须</p>
<ul>
<li>+表示 MUST（URI 编码之后为”%2B”）</li>
<li>-表示 MUST_NOT（同样也可以使用 URI 编码）</li>
<li>title:(+matrix -reloaded)</li>
</ul>
</li>
<li><p>范围查询</p>
<ul>
<li>[]：闭区间；{}开区间<ul>
<li>year:[2019 TO 2018]</li>
<li>year:[* TO 2018]</li>
</ul>
</li>
<li>算术符号<ul>
<li>year:&gt;2010</li>
<li>year:(&gt;2010 &amp;&amp; &lt;=2018)</li>
<li>year:(+&gt;2010 +&lt;=2018)</li>
</ul>
</li>
</ul>
</li>
<li><p>通配符查询</p>
<p>通配符查询效率低，占用内存大，不建议使用，特别是放查询条件在最前面</p>
<ul>
<li>? 表示 i个字符：title:mi?d</li>
<li>* 表示0个字符：title:be*</li>
</ul>
<p>正则表达</p>
<ul>
<li>title:[bt]oy</li>
</ul>
<p>模糊匹配与近似查询（通过波浪号调整 recall，后面的数字越大，recall 值越大，precision 越小）</p>
<ul>
<li>title:befutifl~1</li>
</ul>
</li>
<li><p>相关阅读</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-uri-request.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-uri-request.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-search.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-search.html</a></p>
</li>
<li><p>Kibana请求示例：</p>
</li>
</ol>
<pre><code>#基本查询
GET /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s

#带profile
GET /movies/_search?q=2012&amp;df=title
{
    &quot;profile&quot;:&quot;true&quot;
}

# 指定字段
GET /movies/_search?q=title:2012
{
    &quot;profile&quot;:&quot;true&quot;
}


#泛查询，正对_all,所有字段
GET /movies/_search?q=2012
{
    &quot;profile&quot;:&quot;true&quot;
}

#指定字段
GET /movies/_search?q=title:2012&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s
{
    &quot;profile&quot;:&quot;true&quot;
}


# 查找美丽心灵, Mind为泛查询
GET /movies/_search?q=title:Beautiful Mind
{
    &quot;profile&quot;:&quot;true&quot;
}


#使用引号，Phrase查询
GET /movies/_search?q=title:&quot;Beautiful Mind&quot;
{
    &quot;profile&quot;:&quot;true&quot;
}

#分组，Bool查询
GET /movies/_search?q=title:(Beautiful Mind)
{
    &quot;profile&quot;:&quot;true&quot;
}


#布尔操作符
# 查找美丽心灵
GET /movies/_search?q=title:(Beautiful AND Mind)
{
    &quot;profile&quot;:&quot;true&quot;
}

# 查找美丽心灵
GET /movies/_search?q=title:(Beautiful NOT Mind)
{
    &quot;profile&quot;:&quot;true&quot;
}

# 查找美丽心灵
GET /movies/_search?q=title:(Beautiful %2BMind)
{
    &quot;profile&quot;:&quot;true&quot;
}


#范围查询 ,区间写法
GET /movies/_search?q=title:beautiful AND year:[2002 TO 2018%7D
{
    &quot;profile&quot;:&quot;true&quot;
}


#通配符查询
GET /movies/_search?q=title:[bt]oy
{
    &quot;profile&quot;:&quot;true&quot;
}

//模糊匹配&amp;近似度匹配
GET /movies/_search?q=title:beatifl~2
{
    &quot;profile&quot;:&quot;true&quot;
}

GET /movies/_search?q=title:&quot;Lord Rings&quot;~6
{
    &quot;profile&quot;:&quot;true&quot;
}</code></pre><h2 id="Request-Body-与-Query-DSL-简介"><a href="#Request-Body-与-Query-DSL-简介" class="headerlink" title="Request Body 与 Query DSL 简介"></a>Request Body 与 Query DSL 简介</h2><p>前面介绍了 URI 的 search 方式，另外我们还可以将查询语句（<strong>Query DSL</strong>）通过 HTTP 将 Request Body 发送给 Elasticsearch 进行 query。在 Elasticsearch 中，一些高阶的 search 操作只能在 Request Body 中做，所以建议使用 Request Body 的方式进行query 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091040.png" alt="image-20200424140444451"></p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>在请求体第一层属性设置 from 和 size，from 从0开始，默认 size 是10。<strong>另外获取靠后的翻页成本较高</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091046.png" alt="image-20200424140545527"></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>在请求体第一层属性设置 sort 属性。<strong>最好在”数字型”与”日期型”字段上排序</strong></p>
<p>因为由于多值类型或分析过的字段排序，系统会选一个值，无法得知该值？</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091053.png" alt="image-20200424140745331"></p>
<h3 id="source-filtering"><a href="#source-filtering" class="headerlink" title="_source filtering"></a>_source filtering</h3><p>Es 默认返回的是匹配的文档的所有 Field，如果我们只需要特定的 Field，可以在请求体第一层设置_source属性</p>
<ul>
<li>如果设置_source为空 ，那就只返回匹配的文档的元数据</li>
<li>_source 支持使用通配符：_source[“name*, desc*”]</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091100.png" alt="image-20200424140924145"></p>
<h3 id="脚本字段"><a href="#脚本字段" class="headerlink" title="脚本字段"></a>脚本字段</h3><p>我们根据提供的脚本计算得到一个值作为一个新字段进行输出，示例：</p>
<p>订单中有不同的汇率，需要结合汇率对，订单价格进行排序。下面通过 Es 的”painless”脚本对文档中的订单日期字段拼接上一个 hello：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091115.png" alt="image-20200424141519876"></p>
<h3 id="使用查询表达式：Match"><a href="#使用查询表达式：Match" class="headerlink" title="使用查询表达式：Match"></a>使用查询表达式：Match</h3><p>如下所示：</p>
<ul>
<li>第一个示例中 comment 直接输入一个字符串，则会默认对该字符串进行分词之后得到的 term 进行 or 匹配。</li>
<li>如果想进行 AND 匹配，则看第二个示例，comment 需要传入一个 JSON 对象，这个对象的 query 属性是要查询的字符串，operator 属性指定了 AND 逻辑。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091122.png" alt="image-20200424141832507"></p>
<h3 id="短语搜索：Match-Phrase"><a href="#短语搜索：Match-Phrase" class="headerlink" title="短语搜索：Match Phrase"></a>短语搜索：Match Phrase</h3><p>这里会导致 query 属性进行 Phrase Query，所有 Term 都要匹配并且顺序一致。</p>
<p>另外通过指定一个 slop 字段来指定 Term 之间可以插入的字符数量</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091145.png" alt="image-20200424142153515"></p>
<h3 id="Kibana-测试请求"><a href="#Kibana-测试请求" class="headerlink" title="Kibana 测试请求"></a>Kibana 测试请求</h3><pre><code>#ignore_unavailable=true，可以忽略尝试访问不存在的索引“404_idx”导致的报错
#查询movies分页
POST /movies,404_idx/_search?ignore_unavailable=true
{
  &quot;profile&quot;: true,
    &quot;query&quot;: {
        &quot;match_all&quot;: {}
    }
}

POST /kibana_sample_data_ecommerce/_search
{
  &quot;from&quot;:10,
  &quot;size&quot;:20,
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}


#对日期排序
POST kibana_sample_data_ecommerce/_search
{
  &quot;sort&quot;:[{&quot;order_date&quot;:&quot;desc&quot;}],
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }

}

#source filtering
POST kibana_sample_data_ecommerce/_search
{
  &quot;_source&quot;:[&quot;order_date&quot;],
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}


#脚本字段
GET kibana_sample_data_ecommerce/_search
{
  &quot;script_fields&quot;: {
    &quot;new_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;doc[&#39;order_date&#39;].value+&#39;hello&#39;&quot;
      }
    }
  },
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}


POST movies/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;title&quot;: &quot;last christmas&quot;
    }
  }
}

POST movies/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;title&quot;: {
        &quot;query&quot;: &quot;last christmas&quot;,
        &quot;operator&quot;: &quot;and&quot;
      }
    }
  }
}

POST movies/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;title&quot;:{
        &quot;query&quot;: &quot;one love&quot;

      }
    }
  }
}

POST movies/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;title&quot;:{
        &quot;query&quot;: &quot;one love&quot;,
        &quot;slop&quot;: 1

      }
    }
  }
}</code></pre><h3 id="Query-String-amp-Simple-Query-String-查询"><a href="#Query-String-amp-Simple-Query-String-查询" class="headerlink" title="Query String &amp; Simple Query String 查询"></a>Query String &amp; Simple Query String 查询</h3><ul>
<li><p>Query String：类似 URI Query</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091152.png" alt="image-20200424143218072"></p>
</li>
<li><p>Simple Query String</p>
<ul>
<li>类似 Query String，但是会忽略错误的语法，同时只支持部分查询语法</li>
<li>不支持 AND、OR、NOT，会当成字符串处理</li>
<li>Term 之间默认的关系是 OR，可以指定 Operator</li>
<li>支持部分逻辑：+替代 AND、|替代 OR、-替代 NOT</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091158.png" alt="image-20200424143404916"></p>
</li>
<li><p>Kibana测试请求</p>
<pre><code>PUT /users/_doc/1
{
  &quot;name&quot;:&quot;Ruan Yiming&quot;,
  &quot;about&quot;:&quot;java, golang, node, swift, elasticsearch&quot;
}

PUT /users/_doc/2
{
  &quot;name&quot;:&quot;Li Yiming&quot;,
  &quot;about&quot;:&quot;Hadoop&quot;
}

</code></pre></li>
</ul>
<p>  POST users/_search<br>  {<br>    “query”: {<br>      “query_string”: {<br>        “default_field”: “name”,<br>        “query”: “Ruan AND Yiming”<br>      }<br>    }<br>  }</p>
<p>  POST users/_search<br>  {<br>    “query”: {<br>      “query_string”: {<br>        “fields”:[“name”,”about”],<br>        “query”: “(Ruan AND Yiming) OR (Java AND Elasticsearch)”<br>      }<br>    }<br>  }</p>
<p>  #Simple Query 默认的operator是 Or<br>  POST users/_search<br>  {<br>    “query”: {<br>      “simple_query_string”: {<br>        “query”: “Ruan AND Yiming”,<br>        “fields”: [“name”]<br>      }<br>    }<br>  }</p>
<p>  POST users/_search<br>  {<br>    “query”: {<br>      “simple_query_string”: {<br>        “query”: “Ruan Yiming”,<br>        “fields”: [“name”],<br>        “default_operator”: “AND”<br>      }<br>    }<br>  }</p>
<p>  GET /movies/_search<br>  {<br>      “profile”: true,<br>      “query”:{<br>          “query_string”:{<br>              “default_field”: “title”,<br>              “query”: “Beafiful AND Mind”<br>          }<br>      }<br>  }</p>
<h1 id="多fields"><a href="#多fields" class="headerlink" title="多fields"></a>多fields</h1><p>  GET /movies/_search<br>  {<br>      “profile”: true,<br>      “query”:{<br>          “query_string”:{<br>              “fields”:[<br>                  “title”,<br>                  “year”<br>              ],<br>              “query”: “2012”<br>          }<br>      }<br>  }</p>
<p>  GET /movies/_search<br>  {<br>      “profile”:true,<br>      “query”:{<br>          “simple_query_string”:{<br>              “query”:”Beautiful +mind”,<br>              “fields”:[“title”]<br>          }<br>      }<br>  }</p>
<pre><code>
# 七、Dynamic Mapping 和常见字段类型

## 1、什么是 Mapping

Mapping 类似数据库中的 schema 的定义，作用如下：

* 定义索引中包含的字段名称（即哪些字段可以被索引）
* 定义可索引字段的数据类型，例如字符串，数字，布尔... ...
* 字段，倒排索引的相关配置（ Analyzed or Not Analyzed、分词器）

Mapping 会把 JSON 文档映射成 Lucene 所需要的扁平格式

在第一节中提到，在7.0之前，一个索引可以有多个 Type，每一个 Type 对应一个 Mapping 定义，Mapping 定义了这个 Type 下面被索引的文档需要满足的结构（文档只会属于一个 type），所以文档在索引中被 Type 进行了分组。（也就说，在以前应该是可以同一个字段可以定义多种类型在一个 Index 下多个 Type 中的 Mapping 的，这样是的索引更加抽象，可以兼容更多结构的数据）

但是在7.0之后，一个索引只会有一个 Type，即&quot;_DOC&quot;，这样就会导致一个字段在一个索引中只能是一种类型。也因为只有一个Type，所以不需要在 Mapping 定义中指定 type 信息。

## 2、字段的数据类型

简单类型

- Text、Keyword
- Date
- Integer、Floating
- Boolean
- IPv4 &amp; IPv6

复杂类型（对象和嵌套对象）

* 对象类型、嵌套类型

特殊类型

* geo_point &amp; geo_shape、percolator(过滤器？)

## 3、Dynamic Mapping

1. 在写入文档时，如果索引不存在，会自动创建索引
2. Dynamic Mapping 的机制，使得我们无需手动定义 Mappinigs。Elasticsearch 会自动根据文档信息，推算出字段类型
3. 但是有时候会推算得不对，例如地理位置信息
4. 当类型如果设置不对时，会导致一些功能无法正常运行，例如 Range 查询。

##  4、类型识别

| JSON 类型 | Elasticsearch 类型                                           |
| --------- | ------------------------------------------------------------ |
| 字符串    | 1. 匹配日期格式，设置成 Date，这个也是可以配置的，默认是开启的；2. 通过配置是的其识别数字设置成 float 或者 long，该选项默认关闭；3. 设置为 Text，并且增加 keyword 子字段 |
| 布尔值    | boolean                                                      |
| 浮点型    | float                                                        |
| 整数      | long                                                         |
| 对象      | Object                                                       |
| 数组      | 由第一个非空数字得类型所决定                                 |
| 空值      | 忽略                                                         |
|           |                                                              |

我们看一下下面的示例：uid 和 isAdmin 字段都将被设置成 text，因为默认下是没有开启自动识别数字字符串的，而对于 boolean 值字符串是更加不会自动转换了
![image-20200424152015964](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091210.png)

## 5、能否更改 Mapping 的字段类型

### 新增字段

* 如果 Dynamic 设置为 true时，一旦有新增字段的文档写入，Mapping 也同时被更新
* Dynamic 设为 false，Mapping 不会被更新，新增字段不会被索引，如果用户根据指定这个字段来搜索信息，就会报错（如果不指定该字段搜索，不会报错，但是不会检索该字段内容）；但是字段的信息会被随着文档存储到 Elasticsearch 中，如果这个文档其他字段被索引了，那么这个文档还是可以被搜索出来，该字段也会出现在文档的\_source 中
* Dynamic 设置为 Strict，这个文档写入动作将直接抛出错误 400

![image-20200424152951556](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091217.png)

### 已有字段

* 对已有字段，**一旦已经有数据写入**，就不再支持修改字段定义（Lucene 实现的倒排索引，一旦生成后，就不允许修改）
* 如果希望修改字段类型，必须 ReIndex API，重新索引

### 原因

* 如果修改了字段的数据类型，会导致已被索引的索引无法被搜索
* 但是如果是增加新的字段，就不会有这样的影响

### Kibana 测试请求数据
</code></pre><p>#写入文档，查看 Mapping<br>PUT mapping_test/_doc/1<br>{<br>  “firstName”:”Chan”,<br>  “lastName”: “Jackie”,<br>  “loginDate”:”2018-07-24T10:29:48.103Z”<br>}</p>
<p>#查看 Mapping文件<br>GET mapping_test/_mapping</p>
<p>#Delete index<br>DELETE mapping_test</p>
<p>#dynamic mapping，推断字段的类型<br>PUT mapping_test/_doc/1<br>{<br>    “uid” : “123”,<br>    “isVip” : false,<br>    “isAdmin”: “true”,<br>    “age”:19,<br>    “heigh”:180<br>}</p>
<p>#查看 Dynamic<br>GET mapping_test/_mapping</p>
<p>#默认Mapping支持dynamic，写入的文档中加入新的字段<br>PUT dynamic_mapping_test/_doc/1<br>{<br>  “newField”:”someValue”<br>}</p>
<p>#该字段可以被搜索，数据也在_source中出现<br>POST dynamic_mapping_test/_search<br>{<br>  “query”:{<br>    “match”:{<br>      “newField”:”someValue”<br>    }<br>  }<br>}</p>
<p>#修改为dynamic false<br>PUT dynamic_mapping_test/_mapping<br>{<br>  “dynamic”: false<br>}</p>
<p>#新增 anotherField<br>PUT dynamic_mapping_test/_doc/10<br>{<br>  “anotherField”:”someValue”<br>}</p>
<p>#该字段不可以被搜索，因为dynamic已经被设置为false<br>POST dynamic_mapping_test/_search<br>{<br>  “query”:{<br>    “match”:{<br>      “anotherField”:”someValue”<br>    }<br>  }<br>}</p>
<p>get dynamic_mapping_test/_doc/10</p>
<p>#修改为strict<br>PUT dynamic_mapping_test/_mapping<br>{<br>  “dynamic”: “strict”<br>}</p>
<p>#写入数据出错，HTTP Code 400<br>PUT dynamic_mapping_test/_doc/12<br>{<br>  “lastField”:”value”<br>}</p>
<p>DELETE dynamic_mapping_test</p>
<pre><code>
## 6、显式 Mapping 设置与常见参数介绍

### 如何定义一个 Mapping

![image-20200424154409744](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091224.png)

1. 可以参考 API 手册，纯手写

   [https://www.elastic.co/guide/en/elasticsearch/reference/7.1/dynamic-mapping.html](https://www.elastic.co/guide/en/elasticsearch/reference/7.1/dynamic-mapping.html)

2. 为了减少输入的工作量，减少出错率，可以依照以下步骤

   - 创建一个临时的 index，写入一些样本数据
   - 通过访问 Mapping API获得临时文件的动态 Mapping 定义
   - 修改后用，使用该配置创建你的索引
   - 删除临时索引

### Mapping 参数设置([官网介绍](https://www.elastic.co/guide/en/elasticsearch/reference/7.1/mapping-params.html))

* 通过字段的 index 属性设置控制当前字段是否被索引，默认为 true，即可被索引

  ![image-20200424154722660](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091231.png)

  设置为 false 之后，如果还指定该字段进行索引，将会遇到以下报错

  ![image-20200424154820530](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091237.png)

* 通过 index_options 属性设置字段索引的级别

  1. docs：记录 doc id
  2. freqs：记录 doc id 和 term frequencies
  3. position：记录 doc id 、term frequencies 和 term position
  4. offsets：记录 doc id、term frequencies、term position 和 character offsets

  Text 类型默认记录 positions，其他默认为 docs。（记录内容越多，占用存储空间越大）

* 实现对字段进行 null 值搜索

  通过设定索引字段的&quot;null_value&quot;属性为字符串&quot;NULL&quot;，即可进行 NULL 值搜索。（**注意：只有 Keyword 类型支持设定 Null_value**）

  ![image-20200424155413611](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091244.png)

* 通过 copy_to 属性指定一个字段表示将当前字段的索引映射到该字段，从而可以实现一个字段索引其他多个字段的内容

  1. copy_to 将字段的数值拷贝到目标字段，实现类似\_all的作用
  2. 之前的\_all 字段，在7中已经被 copy_to 所替代
  3. 满足一些特定的搜索需求
  4. copy_to 的目标字段不出现在\_source 中

  ![image-20200424155747257](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091252.png)

### 数组类型

Elasticsearch 中不提供专门的数组类型。但是任何字段，都可以包含多个相同类型的数据。可以看下以下测试内容，第一个请求执行之后，插入了一个 text 类型的 interests 的字段，第二个请求也是可以执行成功，我们看一下此时的 Mapping 定义，发现这个字段的类型还是 text，并不是一个数组，同时也符合我们前面讲到的，Mapping 的字段类型在该字段已经有数据被索引之后是不可以被修改的

![image-20200424155935807](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091300.png)

![image-20200424160319336](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091307.png)

### 多字段类型

当我们为一个索引定义 mapping的时候，可以为索引字段定义子字段，而 Elasticsearch 本身对于 text 类型的字段都会加上一个&quot;keyword&quot;类型的子字段。

这个多字段的特性使得我们可以为一个字段定制更多其他的索引以及检索方式（通过指定不同的 analyzer）：

* 例如一个字段同时支持不同语言的搜索
* 对字段支持 pinyin 的搜索
* 还支持设置在搜索和索引的时候使用不同的 analyzer

![image-20200424163132903](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091313.png)

### Exact Values v.s. Full Text

精确值与全文本

* Exact Value：包括数字、日期、具体一个字符串（例如&quot;App Store&quot;，这是一个业务意义上的最小单元短语，**这在 Elasticsearch 中类型为 keyword**）
* Full Text：非结构化的文本数据（**Elasticsearch 中的 text**）

对于 keyword 类型的数据来说，是没有必要再进行分词处理的了，在 Elasticsearch 中定义了 keyword 类型就是为了避免不必要的分词处理，所以 Elasticsearch 在对每一个字段进行检索的时候如果遇到 Exact Value（如果是创建的时候遇到了自定义了 keyword 类型的字段呢？），不需要做特殊的分词处理，较少性能的浪费。

![image-20200424171205492](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091320.png)

### 自定义分词

当 Elasticsearch 自带的分词器无法满足时，可以自定义分词器。通过自组合不同的组件实现：

* Character Filter

  在 Tokenizer 之前对文本进行处理，例如增加删除及替换字符。可以配置多个 Character Filters。会影响 Tokenizer 的 position 和 offset 信息。以下是一些 Es 自带的 Character FIlters：

  * HTML strip：去掉 html 标签
  * Mapping：字符串替换
  * Pattern replace：正则匹配替换

* Tokenizer

  将原始文本按照一定的规则，切分为词（Term or token），以下是一些 Es 内置的 Tokenizer，当然也可以自己使用 Java 开发实现自己的 Tokenizer：

  * whitespace
  * standard
  * uax_url_email
  * pattern
  * keyword：不做任何处理
  * path hierarchy

* Token Filter

  将 Tokenizer 输出的单词（term）进行增加修改删除，以下时自带的一些 Token FIlters：

  - Lowercase
  - stop
  - synonym（添加同义词）

在定义索引的 mapping 的时候通过组合以上三种组件定义自己想要的分词器

![image-20200424172350477](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091330.png)

Kibana 请求参数测试：
</code></pre><p>PUT logs/_doc/1<br>{“level”:”DEBUG”}</p>
<p>GET /logs/_mapping</p>
<p>POST _analyze<br>{<br>  “tokenizer”:”keyword”,<br>  “char_filter”:[“html_strip”],<br>  “text”: “<b>hello world</b>“<br>}</p>
<p>POST _analyze<br>{<br>  “tokenizer”:”path_hierarchy”,<br>  “text”:”/user/ymruan/a/b/c/d/e”<br>}</p>
<p>#使用char filter进行替换<br>POST _analyze<br>{<br>  “tokenizer”: “standard”,<br>  “char_filter”: [<br>      {<br>        “type” : “mapping”,<br>        “mappings” : [ “- =&gt; _”]<br>      }<br>    ],<br>  “text”: “123-456, I-test! test-990 650-555-1234”<br>}</p>
<p>//char filter 替换表情符号<br>POST _analyze<br>{<br>  “tokenizer”: “standard”,<br>  “char_filter”: [<br>      {<br>        “type” : “mapping”,<br>        “mappings” : [ “:) =&gt; happy”, “:( =&gt; sad”]<br>      }<br>    ],<br>    “text”: [“I am felling :)”, “Feeling :( today”]<br>}</p>
<p>// white space and snowball<br>GET _analyze<br>{<br>  “tokenizer”: “whitespace”,<br>  “filter”: [“stop”,”snowball”],<br>  “text”: [“The gilrs in China are playing this game!”]<br>}</p>
<p>// whitespace与stop<br>GET _analyze<br>{<br>  “tokenizer”: “whitespace”,<br>  “filter”: [“stop”,”snowball”],<br>  “text”: [“The rain in Spain falls mainly on the plain.”]<br>}</p>
<p>//remove 加入lowercase后，The被当成 stopword删除<br>GET _analyze<br>{<br>  “tokenizer”: “whitespace”,<br>  “filter”: [“lowercase”,”stop”,”snowball”],<br>  “text”: [“The gilrs in China are playing this game!”]<br>}</p>
<p>//正则表达式<br>GET _analyze<br>{<br>  “tokenizer”: “standard”,<br>  “char_filter”: [<br>      {<br>        “type” : “pattern_replace”,<br>        “pattern” : “http://(.*)”,<br>        “replacement” : “$1”<br>      }<br>    ],<br>    “text” : “<a href="http://www.elastic.co&quot;" target="_blank" rel="noopener">http://www.elastic.co&quot;</a><br>}</p>
<pre><code>
## 7、Index Template和 Dynamic Template

### [Index Template](https://www.elastic.co/guide/en/elasticsearch/reference/7.1/indices-templates.html)

帮助你设定 Mappings 和 Settings，并按照一定的规则，自动匹配到新创建的索引之上（**其匹配属性是一个数组，即可以设定多个匹配规则**）

* 模板仅在一个索引被新创建之前存在，才会对这个准备新建的索引产生作用。修改模板不会影响已创建的索引。
* 你可以设定多个索引模板，这些设置会被&quot;merge&quot;在一起
* 你可以指定&quot;order&quot;的数值，控制&quot;merging&quot;的过程

#### 两个 Index Templates 例子：

* 第一个例子中设定了所有索引的创建都设定主分片和副本分片数量是1
* 第二个例子中设定了以test 开头的索引的主分片数量是1，副本分片数量是2；另外我们将 Es 自动识别日期字符串且转换类型的功能关闭，然后把自动识别数值字符串且转换类型的功能启用。

![image-20200424180915555](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091338.png)

####  Index Template 的工作方式

当一个索引被新创建时，会按照一下步骤设置 Mappings：

1. 应用 Elasticsearch 默认的 settings 和 mappings
2. 应用 order 数值低的 index template 中的设定，之前的设定会被覆盖
3. 应用 order 高的 index template 中的设定，之前的设定会被覆盖
4. 如果用户创建索引的时候自己指定了 Settings 和 Mappings，则覆盖其设置的设定到之前的设定中。

### [Dynamic Template](https://www.elastic.co/guide/en/elasticsearch/reference/7.1/dynamic-mapping.html)

上面提到的 Index Template 是应用在所有索引上面的，它是定义在一个_template 的命名空间的，index_patterns 是它的其中一个匹配属性（**其匹配属性也是一个数组，即可以设定多个匹配规则**），该属性匹配的是索引对象；

而 Dynamic Template 是定义在一个具体的索引上的，同样它也有匹配属性，但是它的匹配属性匹配的是当前这个 Mapping 的字段，也就是说 Dynamic Template 是直接应用在当前 Index 的字段上的，所以我们可以使用 Dynamic Template 设置字段匹配规则对特定的字段进行特定 mapping 设定，从而实现一个&quot;动态的索引&quot;。例如可以实现以下需求：

* 所有的字符串类型都设定成 Keyword，或者关闭 keyword 字段。
* is 开头的字段都设置成 boolean
* long_开头的都设置成 long 类型

下面是三个 Dynamic Template 的例子：

* 第一个 Index 中定义了两个 Dynamic Template，它们的名字分别是&quot;strings_as_boolean&quot;和&quot;strings_as_keywords&quot;，前者将所有 is 开头的字符串设置成 boolean 类型，后者将其他类型转成 keyword 类型（所以 templates 的应用优先顺序应该是和定义顺序是一样的）
* 第二个 Index 定义了一个 Dynamic Template，将 name.开头，非.middle 结尾的字段设置为 text 类型并链接索引到一个 full_name 字段

![image-20200424182832139](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091346.png)

![image-20200424182839704](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091352.png)

### Kibana 测试请求
</code></pre><p>#数字字符串被映射成text，日期字符串被映射成日期<br>PUT ttemplate/_doc/1<br>{<br>    “someNumber”:”1”,<br>    “someDate”:”2019/01/01”<br>}<br>GET ttemplate/_mapping</p>
<p>#Create a default template<br>PUT _template/template_default<br>{<br>  “index_patterns”: [“*”],<br>  “order” : 0,<br>  “version”: 1,<br>  “settings”: {<br>    “number_of_shards”: 1,<br>    “number_of_replicas”:1<br>  }<br>}</p>
<p>PUT /_template/template_test<br>{<br>    “index_patterns” : [“test*”],<br>    “order” : 1,<br>    “settings” : {<br>        “number_of_shards”: 1,<br>        “number_of_replicas” : 2<br>    },<br>    “mappings” : {<br>        “date_detection”: false,<br>        “numeric_detection”: true<br>    }<br>}</p>
<p>#查看template信息<br>GET /_template/template_default<br>GET /_template/temp*</p>
<p>#写入新的数据，index以test开头<br>PUT testtemplate/_doc/1<br>{<br>    “someNumber”:”1”,<br>    “someDate”:”2019/01/01”<br>}<br>GET testtemplate/_mapping<br>get testtemplate/_settings</p>
<p>PUT testmy<br>{<br>    “settings”:{<br>        “number_of_replicas”:5<br>    }<br>}</p>
<p>put testmy/_doc/1<br>{<br>  “key”:”value”<br>}</p>
<p>get testmy/_settings<br>DELETE testmy<br>DELETE /_template/template_default<br>DELETE /_template/template_test</p>
<p>#Dynaminc Mapping 根据类型和字段名<br>DELETE my_index</p>
<p>PUT my_index/_doc/1<br>{<br>  “firstName”:”Ruan”,<br>  “isVIP”:”true”<br>}</p>
<p>GET my_index/_mapping<br>DELETE my_index<br>PUT my_index<br>{<br>  “mappings”: {<br>    “dynamic_templates”: [<br>            {<br>        “strings_as_boolean”: {<br>          “match_mapping_type”:   “string”,<br>          “match”:”is*”,<br>          “mapping”: {<br>            “type”: “boolean”<br>          }<br>        }<br>      },<br>      {<br>        “strings_as_keywords”: {<br>          “match_mapping_type”:   “string”,<br>          “mapping”: {<br>            “type”: “keyword”<br>          }<br>        }<br>      }<br>    ]<br>  }<br>}</p>
<p>DELETE my_index</p>
<p>#结合路径<br>PUT my_index<br>{<br>  “mappings”: {<br>    “dynamic_templates”: [<br>      {<br>        “full_name”: {<br>          “path_match”:   “name.<em>“,<br>          “path_unmatch”: “</em>.middle”,<br>          “mapping”: {<br>            “type”:       “text”,<br>            “copy_to”:    “full_name”<br>          }<br>        }<br>      }<br>    ]<br>  }<br>}</p>
<p>PUT my_index/_doc/1<br>{<br>  “name”: {<br>    “first”:  “John”,<br>    “middle”: “Winston”,<br>    “last”:   “Lennon”<br>  }<br>}</p>
<p>GET my_index/_search?q=full_name:John</p>
<pre><code>
# 八、Elasticsearch 聚合分析简介（[官方介绍地址](https://www.elastic.co/guide/en/elasticsearch/reference/7.1/search-aggregations.html)）

Elasticsearch 除搜索以外，提供的针对 ES 数据进行统计分析的功能

- 实时性高
- Hadoop（T+1）

通过聚合，我们会得到一个数据的概览，是分析和总结全套的数据，而不是寻找单个文档

- 尖沙咀和香港岛的客户数量
- 不同的价格区间，可预定的经济型酒店和五星级酒店的数量

高性能，只需要一条语句，就可以从 Elasticsearch 得到分析结果，无需在客户端自己去实现分析逻辑

![image-20200424185029724](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091359.png)

## 集合的分类

### Bucket 和 Metric

1. Bucket Aggregation：一系列满足特定条件的文档的集合

  * 一些例子：
    * 杭州属于浙江、一个演员属于男性或者女性
    * 嵌套关系：杭州属于浙江属于中国属于亚洲
  * Elasticsearch 提供了很多类型的 Bucket，帮助你用多种方式划分文档。（如 Term 或者 Range，按照时间、年龄区间、地理位置进行划分等）

  ![image-20200424185849559](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091407.png)

  ![image-20200424190233006](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091414.png)

2. Metric Aggregation：一些数学运算，可以对文档字段进行统计分析

  * Metric 会基于数据集计算结果，除了支持在字段上进行计算，同样也支持在脚本（painless script）产生的结果之上进行计算
  * 大多数 Metric 是数学计算，仅输出一个值：min、max、sum、avg、cardinlity
  * 部分 Metric 支持输出多个数值：stats、percentiles、precentille_ranks

3. 两者类比

![image-20200424185407354](https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201220091422.png)

4. Kibana 测试请求
</code></pre><p>#按照目的地进行分桶统计<br>GET kibana_sample_data_flights/_search<br>{<br>    “size”: 0,<br>    “aggs”:{<br>        “flight_dest”:{<br>            “terms”:{<br>                “field”:”DestCountry”<br>            }<br>        }<br>    }<br>}</p>
<p>#查看航班目的地的统计信息，增加平均，最高最低价格<br>GET kibana_sample_data_flights/_search<br>{<br>    “size”: 0,<br>    “aggs”:{<br>        “flight_dest”:{<br>            “terms”:{<br>                “field”:”DestCountry”<br>            },<br>            “aggs”:{<br>                “avg_price”:{<br>                    “avg”:{<br>                        “field”:”AvgTicketPrice”<br>                    }<br>                },<br>                “max_price”:{<br>                    “max”:{<br>                        “field”:”AvgTicketPrice”<br>                    }<br>                },<br>                “min_price”:{<br>                    “min”:{<br>                        “field”:”AvgTicketPrice”<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}</p>
<p>#价格统计信息+天气信息<br>GET kibana_sample_data_flights/_search<br>{<br>    “size”: 0,<br>    “aggs”:{<br>        “flight_dest”:{<br>            “terms”:{<br>                “field”:”DestCountry”<br>            },<br>            “aggs”:{<br>                “stats_price”:{<br>                    “stats”:{<br>                        “field”:”AvgTicketPrice”<br>                    }<br>                },<br>                “wather”:{<br>                  “terms”: {<br>                    “field”: “DestWeather”,<br>                    “size”: 5<br>                  }<br>                }</p>
<pre><code>        }
    }
}</code></pre><p>}</p>
<pre><code>


* Pipeline Aggregation：对其他的聚合结果进行二次聚合



* Matrix Aggregation：支持对多个字段的操作并提供一个结果矩阵


</code></pre>
            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《004_Elasticsearch 入门》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/05/04/elasticsearch/004-elasticsearch-ru-men/" property="cc:attributionName"
               rel="cc:attributionURL">
                阿钟
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '466e387c08bce10f3f28',
        clientSecret: '5b2bf16f8a42bd72eef32e50187c7f2ccb105a1d',
        repo: 'azhong.github.io',
        owner: 'JohnZhongg',
        admin: "JohnZhongg",
        id: '2020/05/04/elasticsearch/004-elasticsearch-ru-men/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/04/elasticsearch/006-fen-bu-shi-te-xing-ji-fen-bu-shi-sou-suo-de-ji-zhi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="006_分布式特性及分布式搜索的机制">
                        
                        <span class="card-title">006_分布式特性及分布式搜索的机制</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ES学习
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ES学习/" class="post-category" target="_blank">
                                    ES学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES学习/" target="_blank">
                        <span class="chip bg-color">ES学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/04/elasticsearch/005-shen-ru-sou-suo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="005_深入搜索">
                        
                        <span class="card-title">005_深入搜索</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ES学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ES学习/" class="post-category" target="_blank">
                                    ES学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES学习/" target="_blank">
                        <span class="chip bg-color">ES学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 阿钟的博客<br />'
            + '作者: 阿钟<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2020- Azhong. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">627k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/https://github.com/JohnZhongg" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:707845008@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/change-94-17" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=707845008&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


<!-- 


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 12, 20, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>