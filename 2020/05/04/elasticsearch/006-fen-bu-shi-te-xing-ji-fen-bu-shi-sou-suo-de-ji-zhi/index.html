<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="006_分布式特性及分布式搜索的机制, 技术博客 钟鸿鹏 honphan 阿钟">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="[TOC]
一、配置跨集群搜索1、水平扩展的痛点如果 Es 一直以单集群的状态运行的时候，当水平扩展的时候，节点数不能无限增加。因为随着节点数的增加，集群的 meta 信息（节点、索引、集群状态）过多，会导致更新压力变大，单个 Active">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>006_分布式特性及分布式搜索的机制 | 阿钟的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">阿钟的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">阿钟的博客</div>
        <div class="logo-desc">
            
            keep going...
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JohnZhongg" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JohnZhongg" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        006_分布式特性及分布式搜索的机制
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/ES学习/" target="_blank">
                            <span class="chip bg-color">ES学习</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/ES学习/" class="post-category" target="_blank">
                            ES学习
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-04
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    阿钟
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    38 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<h1 id="一、配置跨集群搜索"><a href="#一、配置跨集群搜索" class="headerlink" title="一、配置跨集群搜索"></a>一、配置跨集群搜索</h1><h3 id="1、水平扩展的痛点"><a href="#1、水平扩展的痛点" class="headerlink" title="1、水平扩展的痛点"></a>1、水平扩展的痛点</h3><p>如果 Es 一直以单集群的状态运行的时候，当水平扩展的时候，节点数不能无限增加。因为随着节点数的增加，集群的 meta 信息（节点、索引、集群状态）过多，会导致更新压力变大，单个 Active Master 会称为性能瓶颈，导致整个集群无法正常工作。</p>
<p>在早期版本，通过 Tribe Node 可以实现多集群访问的需求，但是还是存在一定的问题：</p>
<ul>
<li>当前集群的 Tribe Node 会以 Client Node 的方式加入其他每个集群。其他集群中 Master节点的任务变更需要当前集群的 Tribe Node 的回应才能继续。</li>
<li>Tribe Node 不保存 Cluster State 信息，一旦重启，初始化很慢</li>
<li>当多个集群存在索引重名的情况时，只能设置一种 Prefer 规则</li>
</ul>
<h3 id="2、Cross-Cluster-Search（跨集群搜索）"><a href="#2、Cross-Cluster-Search（跨集群搜索）" class="headerlink" title="2、Cross Cluster Search（跨集群搜索）"></a>2、Cross Cluster Search（跨集群搜索）</h3><p>早期 Tribe Node 的方案存在一定的问题，现已被 Deprecated。在 Elasticsearch 5.3 引入了跨集群搜索的功能（Cross Cluster Search），推荐使用：</p>
<ul>
<li>允许任何节点扮演 federated 节点，以轻量的方式，将搜索请求进行代理</li>
<li>不需要以 Client Node 的形式加入其他集群</li>
</ul>
<h3 id="3、设定步骤"><a href="#3、设定步骤" class="headerlink" title="3、设定步骤"></a>3、设定步骤</h3><ol>
<li><p>分别启动各个 Cluster（前面也提到过这个启动命令，这里的区别是我们指定了3个集群名称，每个集群只有一个节点）</p>
<pre class="line-numbers language-shell"><code class="language-shell">//启动3个集群
bin/elasticsearch -E node.name=cluster0node -E cluster.name=cluster0 -E path.data=cluster0_data -E discovery.type=single-node -E http.port=9200 -E transport.port=9300
bin/elasticsearch -E node.name=cluster1node -E cluster.name=cluster1 -E path.data=cluster1_data -E discovery.type=single-node -E http.port=9201 -E transport.port=9301
bin/elasticsearch -E node.name=cluster2node -E cluster.name=cluster2 -E path.data=cluster2_data -E discovery.type=single-node -E http.port=9202 -E transport.port=9302<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>通过_cluster/setting api 设定 Cross Cluster Search</strong>（persistent.cluster.remote.${clustername}.seeds:”ip:port”），另外我们可以在各个集群的配置中进行一些定制化配置，例如下面集群0的<code>transport.ping_schedule=30s</code>、集群1的<code>transport.compress=true</code>和<code>skip_unavailable=true</code>（表示当前集群如果挂了，无响应，可以跳过它）… …</p>
<p>参考模板</p>
<pre class="line-numbers language-shell"><code class="language-shell">//在每个集群上设置动态的设置
PUT _cluster/settings
{
  "persistent": {
    "cluster": {
      "remote": {
        "cluster0": {
          "seeds": [
            "127.0.0.1:9300"
          ],
          "transport.ping_schedule": "30s"
        },
        "cluster1": {
          "seeds": [
            "127.0.0.1:9301"
          ],
          "transport.compress": true,
          "skip_unavailable": true
        },
        "cluster2": {
          "seeds": [
            "127.0.0.1:9302"
          ]
        }
      }
    }
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们通过以下<code>curl</code>命令进行 cross cluster search 的设置：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#CURL
curl -XPUT "http://localhost:9200/_cluster/settings" -H 'Content-Type: application/json' -d'
{"persistent":{"cluster":{"remote":{"cluster0":{"seeds":["127.0.0.1:9300"],"transport.ping_schedule":"30s"},"cluster1":{"seeds":["127.0.0.1:9301"],"transport.compress":true,"skip_unavailable":true},"cluster2":{"seeds":["127.0.0.1:9302"]}}}}}'

curl -XPUT "http://localhost:9201/_cluster/settings" -H 'Content-Type: application/json' -d'
{"persistent":{"cluster":{"remote":{"cluster0":{"seeds":["127.0.0.1:9300"],"transport.ping_schedule":"30s"},"cluster1":{"seeds":["127.0.0.1:9301"],"transport.compress":true,"skip_unavailable":true},"cluster2":{"seeds":["127.0.0.1:9302"]}}}}}'

curl -XPUT "http://localhost:9202/_cluster/settings" -H 'Content-Type: application/json' -d'
{"persistent":{"cluster":{"remote":{"cluster0":{"seeds":["127.0.0.1:9300"],"transport.ping_schedule":"30s"},"cluster1":{"seeds":["127.0.0.1:9301"],"transport.compress":true,"skip_unavailable":true},"cluster2":{"seeds":["127.0.0.1:9302"]}}}}}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>分别为各个集群添加文档数据到具有相同索引名称”users”的索引中</p>
<pre class="line-numbers language-shell"><code class="language-shell">#创建测试数据
curl -XPOST "http://localhost:9200/users/_doc" -H 'Content-Type: application/json' -d'
{"name":"user1","age":10}'

curl -XPOST "http://localhost:9201/users/_doc" -H 'Content-Type: application/json' -d'
{"name":"user2","age":20}'

curl -XPOST "http://localhost:9202/users/_doc" -H 'Content-Type: application/json' -d'
{"name":"user3","age":30}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在查询的时候可以通过指定”集群名称:索引名”来进行搜索，如果不指定”集群名称”，默认在当前集群内进行搜索：</p>
<pre class="line-numbers language-shell"><code class="language-shell">#查询
GET /users,cluster1:users,cluster2:users/_search
{
  "query": {
    "range": {
      "age": {
        "gte": 20,
        "lte": 40
      }
    }
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而返回结果中也包含了索引的完整名字”${集群名字}:索引名”</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093121.png" alt="image-20200426141114160"></p>
</li>
<li><p>设置 Kibana 中的”索引管理”对多集群可见</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093122.png" alt="image-20200426140800887"></p>
<p>进入 Discover 面板可以看到多集群中的 users 索引 的信息了：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093123.png" alt="image-20200426141003924"></p>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><p><a href="https://kelonsoftware.com/cross-cluster-search-kibana/" target="_blank" rel="noopener">https://kelonsoftware.com/cross-cluster-search-kibana/</a></p>
</li>
</ol>
<h1 id="二、集群分布式模型及选主与脑裂问题"><a href="#二、集群分布式模型及选主与脑裂问题" class="headerlink" title="二、集群分布式模型及选主与脑裂问题"></a>二、集群分布式模型及选主与脑裂问题</h1><h3 id="1、分布式特性"><a href="#1、分布式特性" class="headerlink" title="1、分布式特性"></a>1、分布式特性</h3><p>Elasticsearch 的分布式架构带来了以下好处：</p>
<ul>
<li>存储的水平扩容，支持 PB 级数据</li>
<li>提高系统的可用性，部分节点停止服务，整个集群的服务不受影响</li>
</ul>
<p>Elasticsearch 的分布式架构</p>
<ul>
<li>不同的集群通过不同的名字来区分，默认名字”elasticsearch”</li>
<li>通过配置文件(elasticsearch.yml)修改，或者在命令行<code>-E cluster.name=geektime</code> 进行设定</li>
</ul>
<h3 id="2、Elasticsearch-中的节点"><a href="#2、Elasticsearch-中的节点" class="headerlink" title="2、Elasticsearch 中的节点"></a>2、Elasticsearch 中的节点</h3><p>节点是一个 Elasticsearch 实例，其本质上就是一个 Java 进程。一台机器上可以运行多个 Elasticsearch 进程，但是生产环境一般建议一台机器上就运行一个 Elasticsearch 实例。</p>
<p>每个节点都有名字，通过配置文件(elasticsearch.yml)配置，或者启动时<code>-E node.name=geektime</code> 指定</p>
<p>每一个节点在启动之后，会分配一个 UID，保存在 data 目录下</p>
<h3 id="3、Coordinating-Node"><a href="#3、Coordinating-Node" class="headerlink" title="3、Coordinating Node"></a>3、Coordinating Node</h3><p>处理请求的节点，叫 Coordinating Node。它负责路由请求到正确的节点，例如创建索引的请求，需要路由到 Master节点。</p>
<p>默认情况下，所有节点都是 Coordinating Node，我们可以通过将<code>node.xxxx</code>的参数全部设置为 false，使其成为 Dedicated Coordinating Node（专职）。<strong>但是不能取消任何一个节点作为 Coordinating Node的功能！</strong></p>
<h3 id="4、Data-Node"><a href="#4、Data-Node" class="headerlink" title="4、Data Node"></a>4、Data Node</h3><p>可以保存数据的节点，叫做 Data Node。节点启动后，默认就是数据节点。可以设置 node.data:false 禁止其称为 Data Node。</p>
<p>Data Node 的职责是保存分片数据。在数据扩展上起到了至关重要的作用（由Master Node 决定如何把分片分发到数据节点上），通过增加数据节点，可以解决<strong>数据水平扩展</strong>和解决<strong>数据单点</strong>问题。</p>
<h3 id="5、Master-Node"><a href="#5、Master-Node" class="headerlink" title="5、Master Node"></a>5、Master Node</h3><p>Master Node 的职责是</p>
<ul>
<li>处理创建，删除索引等请求</li>
<li>决定分片被分配到哪个节点</li>
<li>维护并且更新 Cluster State</li>
</ul>
<p>Master Node 的最佳实践</p>
<p>Master 节点非常重要，在部署上需要考虑解决单点的问题。为一个集群设置多个 Master（Eligible、备选）节点，每个节点只承担 Master 的单一角色，如果 Master 节点发生故障，其他备选 Master 节点就可以顶上。</p>
<h4 id="Master-Eligible-Nodes"><a href="#Master-Eligible-Nodes" class="headerlink" title="Master Eligible Nodes"></a>Master Eligible Nodes</h4><p>一个集群，支持配置多个 Master Eligible 节点。这些节点可以在必要时（Master 节点出现故障，网络故障时）参与选主流程，称为 Master 节点。</p>
<p>每个节点启动后，默认就是一个 Master Eligible 节点，我们可以通过设置<code>node.master:flase</code>禁止。这样该节点可以加入集群，但是不会参与 Master 节点选主称为 Master 节点。</p>
<h4 id="选主流程"><a href="#选主流程" class="headerlink" title="选主流程"></a>选主流程</h4><ul>
<li>当集群内第一个 Master Eligible 节点启动的时候，它会将自己选举称为 Master 节点。</li>
<li>一旦发现被选中的主节点丢失，就会选举出新的 Master 节点，所有节点互相 ping 对方，Node Id 低的会被选举为 Master。</li>
</ul>
<h3 id="6、集群状态"><a href="#6、集群状态" class="headerlink" title="6、集群状态"></a>6、集群状态</h3><p>集群状态信息（Cluster State）维护了一个集群中必要的信息：</p>
<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的 Mapping 与 Setting 信息</li>
<li>分片的路由信息</li>
</ul>
<p>在每个节点上都保存了集群的状态信息，但是只有 Master 节点才能修改集群的状态信息，并负责同步给其他节点，因为任意节点都能修改信息会导致 Cluster State 信息的不一致。</p>
<h3 id="7、脑裂问题-Split-Brain"><a href="#7、脑裂问题-Split-Brain" class="headerlink" title="7、脑裂问题(Split-Brain)"></a>7、脑裂问题(Split-Brain)</h3><p>这是分布式系统的经典网络问题。我们看下面示例：当出现网络问题，一个节点node1和其他节点 node2 和 node3 无法连接：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093124.png" alt="image-20200426154857050"></p>
<ul>
<li>Node2和 Node3会重新选举 Master</li>
<li>Node1自己还是作为 Master，组成一个集群，同时更新 Cluster State</li>
<li>导致2个 master 维护不同的 Cluster State，当网络恢复的时候，造成混乱，无法正确恢复集群状态。</li>
</ul>
<p>针对这个问题，我们需要限定一个选举条件，设置 quorum（仲裁），只有在 Master eligible 节点数大于 quorum 时才能进行选举：</p>
<ul>
<li>Quorum = (Master Eligible 节点总数 / 2) + 1。</li>
<li>当3个 master eligible 时，设置 <code>discovery.zen.minimum_master_nodes=2</code>，即可避免脑裂。（其他节点数量视情况而设定）</li>
</ul>
<p>从ES7.0开始，无需进行这个配置，它移除了 <code>minimum_master_nodes</code>参数，让 Elasticsearch 自己选择可以形成仲裁的节点。典型的主节点选举现在只需要很短的时间就可以完成。集群的伸缩变得更安全、更容易，并且可能造成丢失数据的系统配置选项更少了。节点更清除地记录它们的状态，有助于诊断为什么它们不能加入集群或为什么无法选举出主节点。</p>
<h3 id="8、通过-Cerebro-观察集群状态"><a href="#8、通过-Cerebro-观察集群状态" class="headerlink" title="8、通过 Cerebro 观察集群状态"></a>8、通过 Cerebro 观察集群状态</h3><ol>
<li><p>通过命令行方式启动一个 ES 集群</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093125.png" alt="image-20200426160933084"></p>
</li>
<li><p>启动 cerebro </p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093126.png" alt="image-20200426161022552"></p>
</li>
<li><p>进入 cerebro 界面，可以看到只有一个节点，索引、分片、文档等都是空的。该节点也是一个 master 节点</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093127.png" alt="image-20200426161110351"></p>
</li>
<li><p>通过 more-create index 创建索引</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093128.png" alt="image-20200426161221166"></p>
</li>
<li><p>创建一个 “test” 索引，有3个主分片，1个副本分片，点击创建，返回成功。但是我们留意到上面的状态条变成了黄色。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093129.png" alt="image-20200426161345627"></p>
</li>
<li><p>回到主界面，我们可以发现刚刚我们创建的 test 索引已经显示出来了，我们指定了三个主分片也分片到了 Master 节点上。但是我们指定的3份副本分片（每个主分片都有一个副本，所有是3个）是一个待分配状态，因为现在集群中只有一个节点，所以无法分配副本分片。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093130.png" alt="image-20200426161546194"></p>
</li>
<li><p>这时候我们再启动一个节点</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093131.png" alt="image-20200426161840329"></p>
</li>
<li><p>切换 cerebro 界面进行刷新。我们可以发现状态条恢复绿色。有一个节点加入了集群，副本分片也分配到了该节点上。这样，当另一个节点发生故障的时候，数据不会发生丢失。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093132.png" alt="image-20200426161936831"></p>
</li>
</ol>
<h3 id="9、配置节点类型"><a href="#9、配置节点类型" class="headerlink" title="9、配置节点类型"></a>9、配置节点类型</h3><p>一个节点默认情况下时一个 Master Eligible、Data And Ingest Node。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093133.png" alt="image-20200426162125107"></p>
<blockquote>
<p>所有的节点都是默认支持ingest的，任何节点都可以处理ingest请求，也可以创建一个专门的Ingest nodes。</p>
</blockquote>
<h3 id="10、相关阅读"><a href="#10、相关阅读" class="headerlink" title="10、相关阅读"></a>10、相关阅读</h3><p><a href="https://www.elastic.co/cn/blog/a-new-era-for-cluster-coordination-in-elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/blog/a-new-era-for-cluster-coordination-in-elasticsearch</a></p>
<h1 id="三、分片与集群的故障转移"><a href="#三、分片与集群的故障转移" class="headerlink" title="三、分片与集群的故障转移"></a>三、分片与集群的故障转移</h1><p>分片是 Elasticsearch 分布式集群存储的基石，其中分为主分片和副本分片。</p>
<h3 id="1、Primary-Shard"><a href="#1、Primary-Shard" class="headerlink" title="1、Primary Shard"></a>1、Primary Shard</h3><p>通过主分片，ES 将数据分布在所有Data Ndoe上，实现存储的水平扩展。主分片数在索引创建的时候指定，后续默认不能修改，如要修改，需要重建索引。</p>
<h3 id="2、Replica-Shard"><a href="#2、Replica-Shard" class="headerlink" title="2、Replica Shard"></a>2、Replica Shard</h3><p>副本分片可以提高数据的可用性。一旦主分片丢失，副本分片可以 Promote 成主分片。副本分片数可以动态调整。每个节点上都有完备的数据。如果不设置副本分片，一旦出现节点硬件故障，就有可能造成数据丢失。</p>
<p>副本分片由主分片同步。通过支持增加 Replica 个数，一定程度可以提高读取的吞吐量。</p>
<h3 id="3、分片数的设定"><a href="#3、分片数的设定" class="headerlink" title="3、分片数的设定"></a>3、分片数的设定</h3><p>我们需要谨慎规划一个索引的主分片和副本分片数：</p>
<p>如果主分片数过小，例如 ES 现在最新版本是默认创建一个主分片，如果一个索引只创建了一个主分片，如果该索引增长很快，集群无法通过增加节点实现对这个索引的数据扩展。</p>
<p>如果主分片数量设置过大，也会导致单个 Shard 容量很小，引发一个节点上有过多分片，影响性能。</p>
<p>如果副本分片数量设置过多，会降低集群整体的写入性能。</p>
<h3 id="4、集群故障转移过程"><a href="#4、集群故障转移过程" class="headerlink" title="4、集群故障转移过程"></a>4、集群故障转移过程</h3><p>上一节中我们也看到了一例子，我们启动了一个只有一个节点的集群，然后创建一个索引，指定其主分片数量为3，副本分片数量为1。会发现副本分片无法分配，集群状态为黄色。（<strong>另外，可以看到多个主分片是可以分布在同一个节点中的</strong>）</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093134.png" alt="image-20200426172249108"></p>
<p>这时候我们可以通过增加一个数据节点，集群将Node1中的所有主分片备份到 Node2的副本分片之后集群状态恢复绿色。<strong>此时整个集群已经具备故障转移的能力。</strong></p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093135.png" alt="image-20200426172322292"></p>
<p>此时我们再为集群增加一个数据节点，Master 节点会决定分片分配到哪个节点上。可以看到此时三个主分片都分布到了三个不同的节点上，并且三个节点互相备份其他节点的 Master 分片。（通过增加节点，提高集群的计算能力）</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093136.png" alt="image-20200426172623206"></p>
<p> 现在我们模拟一个故障过程：</p>
<p>节点1Master 节点意外出现故障，此时整个集群状态变红。集群重新选举 Master 节点，Node3上的 R0 副本分片提升为 P0 主分片进行数据接收，提升完毕之后集群状态变黄，P0 和 P1两个主分片的数据待备份，此时 Node3 负责备份 P1主分片为 R1，Node2负责备份 P0主分片为 R0，备份完毕之后集群状态变绿。</p>
<p>其中这里面有几个时间点需要注意：</p>
<ul>
<li>如果存在数据写入 P0 之后P0没来得及备份到 R0副本，Node1就挂掉了，这时候 R0是没有这些数据的，在 Node1恢复之前数据都无法获得，而当 Node1恢复重新加入集群之后，会从 <code>translog</code>中恢复没有写入的数据。</li>
<li>Node1挂掉之后，P0主分片还没选举出来之前应该路由到 P0的数据进来了，如果有创建index或者分片reallocation有可能会出错。（即集群是黄色变绿的过程，副本分片提升为主分片，不影响读写；如果集群在红变黄的过程，缺少主分片，会影响读写）</li>
</ul>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093137.png" alt="image-20200426172744223"></p>
<h3 id="5、集群健康状态"><a href="#5、集群健康状态" class="headerlink" title="5、集群健康状态"></a>5、集群健康状态</h3><ul>
<li>Green：健康状态，所有的主分片和副本分片都可用</li>
<li>Yellow：亚健康，所有的主分片可用，部分副本分片不可用</li>
<li>Red：不健康状态，部分主分片不可用</li>
</ul>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093138.png" alt="image-20200426173700072"></p>
<h1 id="四、文档分布式存储"><a href="#四、文档分布式存储" class="headerlink" title="四、文档分布式存储"></a>四、文档分布式存储</h1><h3 id="1、文档存储在分片上"><a href="#1、文档存储在分片上" class="headerlink" title="1、文档存储在分片上"></a>1、文档存储在分片上</h3><p>文档会存储到具体的某个主分片和副本分片上，而存储到哪个分片上则需要一个映射算法来负责，而这个算法需要确保文档能均匀分布在所用分片上，充分利用硬件资源，避免部分机器控线，部分机器繁忙。</p>
<p>潜在的算法：</p>
<ul>
<li>随机、Round Robin（轮询）：当查询文档1，分片数很多，需要多次查询才可能查到文档1</li>
<li>维护文档到分片的映射关系，当文档数据量很大的时候，维护成本高</li>
<li>通过 hash 算法对文档的 hash key 进行实时计算，自动算出，需要到哪个分片上获取文档</li>
</ul>
<h3 id="2、ES-中的路由算法"><a href="#2、ES-中的路由算法" class="headerlink" title="2、ES 中的路由算法"></a>2、ES 中的路由算法</h3><p>shard = hash(_routing) % number_of_primary_shards</p>
<ul>
<li>由 hash 算法确保文档均匀地 hash 到各个分片中</li>
<li>默认的_routing 值是文档 id</li>
<li>可以自行制定 routing 数值，例如用相同国家的商品，都分配到指定的 shard</li>
<li>设置 index settings 后，Primary shard数不能随意修改的根本愿意就是这里的文档 hash 到分片对主分片数进行了计算</li>
</ul>
<h3 id="3、更新一个文档的流程（没有副本分片）"><a href="#3、更新一个文档的流程（没有副本分片）" class="headerlink" title="3、更新一个文档的流程（没有副本分片）"></a>3、更新一个文档的流程（没有副本分片）</h3><p>一个更新请求发送到 coordinating 节点，该节点对文档进行 hash 计算（根据集群状态），最终将这个请求路由到该文档对应的主分片节点上，主分片节点对文档进行删除操作之后再进行索引操作，然后返回成功到 coordinating 节点，然后 coordinating 节点响应用户。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093139.png" alt="image-20200426175142090"></p>
<h3 id="4、删除一个文档的流程（涉及副本分片）"><a href="#4、删除一个文档的流程（涉及副本分片）" class="headerlink" title="4、删除一个文档的流程（涉及副本分片）"></a>4、删除一个文档的流程（涉及副本分片）</h3><p>一个删除请求发送到 coordinating 节点，该节点对文档进行 hash 计算（根据集群状态），最终将这个请求路由到该文档对应的主分片节点上，主分片节点对文档进行删除操作之后，发送同步请求到副本分片节点进行删除（根据集群状态），副本分片删除索引之后返回成功到主分片节点，主分片节点收到响应之后返回成功到 coordinating 节点，然后 coordinating 节点响应用户。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093140.png" alt="image-20200426175344500"></p>
<h3 id="5、-为什么-ES-不支持一致性-Hash-算法动态增加主分片"><a href="#5、-为什么-ES-不支持一致性-Hash-算法动态增加主分片" class="headerlink" title="5、 为什么 ES 不支持一致性 Hash 算法动态增加主分片"></a>5、 为什么 ES 不支持一致性 Hash 算法动态增加主分片</h3><blockquote>
<p>Why doesn’t Elasticsearch support incremental resharding?<br>Going from N shards to N+1 shards, aka. incremental resharding, is indeed a feature that is supported by many key-value stores. Adding a new shard and pushing new data to this new shard only is not an option: this would likely be an indexing bottleneck, and figuring out which shard a document belongs to given its _id, which is necessary for get, delete and update requests, would become quite complex. This means that we need to rebalance existing data using a different hashing scheme.</p>
<p>The most common way that key-value stores do this efficiently is by using consistent hashing. Consistent hashing only requires 1/N-th of the keys to be relocated when growing the number of shards from N to N+1. However Elasticsearch’s unit of storage, shards, are Lucene indices. Because of their search-oriented data structure, taking a significant portion of a Lucene index, be it only 5% of documents, deleting them and indexing them on another shard typically comes with a much higher cost than with a key-value store. This cost is kept reasonable when growing the number of shards by a multiplicative factor as described in the above section: this allows Elasticsearch to perform the split locally, which in-turn allows to perform the split at the index level rather than reindexing documents that need to move, as well as using hard links for efficient file copying.</p>
<p>In the case of append-only data, it is possible to get more flexibility by creating a new index and pushing new data to it, while adding an alias that covers both the old and the new index for read operations. Assuming that the old and new indices have respectively M and N shards, this has no overhead compared to searching an index that would have M+N shards.</p>
</blockquote>
<h1 id="五、分片及生命周期"><a href="#五、分片及生命周期" class="headerlink" title="五、分片及生命周期"></a>五、分片及生命周期</h1><h3 id="1、分片的内部原理"><a href="#1、分片的内部原理" class="headerlink" title="1、分片的内部原理"></a>1、分片的内部原理</h3><p>ES 中的分片是最小的工作单元，也是一个 Lucene 的 Index。</p>
<p>我们从以下一些问题出发探索 ES 中的分片：</p>
<ol>
<li>为什么 ES 的搜索是近实时的（1秒后被搜到）</li>
<li>ES 如何保证在断点时数据也不会丢失</li>
<li>为什么删除文档，并不会立刻释放空间</li>
</ol>
<h3 id="2、倒排索引不可变性"><a href="#2、倒排索引不可变性" class="headerlink" title="2、倒排索引不可变性"></a>2、倒排索引不可变性</h3><p>倒排索引采用 Immutable Design，一旦生成就不可更改。不可变性带来了如下好处：</p>
<ul>
<li>无需考虑并发写文件的问题，避免了锁机制带来的性能问题。（如果可以更新可能会出现并发更新的情况，为了保持数据一致性，往往需要加锁，而倒排索引都是直接删除然后新增，执行的是覆盖操作）</li>
<li>一旦写入内核的文件系统缓存，便留在那里。只要文件系统存有足够的空间，大部分请求就会直接请求内存，不会命中磁盘，提升了很大的性能</li>
<li>缓存容易生成和维护，数据可以被压缩</li>
</ul>
<p>不可变更性也带来了挑战：如果需要让一个新的文档可以被搜索，需要重建整个索引。</p>
<h3 id="3、Lucene-Index"><a href="#3、Lucene-Index" class="headerlink" title="3、Lucene Index"></a>3、Lucene Index</h3><p>在 Lucene 中，单个倒排索引文件被称为 Segment。<strong>Segment 是自包含的，不可变更的</strong>。当有新文档写入的时候，会生成新 Segment，查询时会同时查询所有 Segments，并且对结果汇总。多个 Segments 汇总在一起，称为 Lucene 的 Index，其对应的就是 ES 中的 Shard。</p>
<p>Lucene 中有一个文件，用来记录所有 Segments 信息，叫做 Commit Point。删除的文档信息，保存在”.del”文件中。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093141.png" alt="image-20200426221226567"></p>
<h3 id="4、什么是-Refresh"><a href="#4、什么是-Refresh" class="headerlink" title="4、什么是 Refresh"></a>4、什么是 Refresh</h3><p>在将一个新的文档写入到 ES 的时候，会将这个文档先写入到一个 Index Buffer 中，当到达一定的时候，会将 Index Buffer 写入 Segment ，然后清空 Buffer，从 Index Buffer写入信息到 Segment 的过程就叫做 Refresh。（Refresh 不执行 fsync 操作）</p>
<p>Refresh 频率默认是1秒发生一次，可通过 index.refresh_interval 配置。Refresh 后，数据就可以被搜索到了。这也是为什么 Elasticsearch 被称为近实时搜索。</p>
<p>如果系统有大量的数据写入，那就会产生很多的 Segment，当 Index Buffer 被占满时，也会触发 Refresh，这个 Buffer默认值是 JVM 的10%。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093142.png" alt="image-20200426221735235"></p>
<h3 id="5、什么是-Transaction-Log"><a href="#5、什么是-Transaction-Log" class="headerlink" title="5、什么是 Transaction Log"></a>5、什么是 Transaction Log</h3><p>上面介绍了一个新的文档的写入是先写入 ES 的 Index Buffer 中，在一定时候”refresh”到 Segments，而Segment 写入磁盘的过程相对耗时（特别时存在大量写入文档操作的时候），借助文件系统缓存，Refresh 时，先将 Segment 写入缓存以开放查询。</p>
<p>但是因为此时数据是写入到内存中的，为了保证此段时间数据不会丢失。所以ES 在 Index 一个新创建的文档的时候，除了将其写入到 Index Buffer 中，同时还写 Transaction Log（这是一个异步动作，不会阻塞文档写入 Index Buffer 以及 refresh）。高版本开始，Transaction Log 默认落盘。每个分片都有一个 Transaction Log。</p>
<p>在 ES Refresh 时，即使是Index Buffer 被清空，刷到 Segments 的缓存当中，Transaction log 不会清空。所以为什么 ES 节点产生”断电”的时候，它已经写入的数据是”不会”丢失的，就是因为它已经将 Transaction log 进行了落盘，在这个节点重启之后，会重新加载 Transaction Log 对数据进行 recover。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093143.png" alt="image-20200426221940337"></p>
<h3 id="6、什么是-FLush"><a href="#6、什么是-FLush" class="headerlink" title="6、什么是 FLush"></a>6、什么是 FLush</h3><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093144.png" alt="image-20200426222022291"></p>
<p>它可以理解为”ES FLush”和”Lucene Commit”两个过程：</p>
<ol>
<li>先执行一次 Refresh，Index Buffer 清空并且将数据刷到 Segments cache</li>
<li>调用 fsync，将缓存中的 Segments 写入磁盘</li>
<li>清空（删除）Transaction Log</li>
</ol>
<p>Flush 操作默认30分钟调用一次；另外当 Transaction Log满地时候也会触发调用（默认512MB）</p>
<h3 id="7、Merge"><a href="#7、Merge" class="headerlink" title="7、Merge"></a>7、Merge</h3><p>Merge 操作指的是当 Segment 很多地时候，需要被定期合并，减少 Segments，并真正删除已经删除地文档。</p>
<p>ES 和 Lucene 会自动进行 Merge 操作，我们也可以通过 <code>POST my_index/_forcemerge</code>API 进行强制 merge。</p>
<h3 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h3><ol>
<li>客户端发起数据写入请求，对你写的这条数据根据_routing规则选择发给哪个Shard。<ul>
<li>确认Index Request中是否设置了使用哪个Filed的值作为路由参数</li>
<li>如果没有设置，则使用Mapping中的配置，</li>
<li>如果mapping中也没有配置，则使用_id作为路由参数，然后通过_routing的Hash值选择出Shard，最后从集群的Meta中找出出该Shard的Primary节点。</li>
</ul>
</li>
<li>写入请求到达Shard后，先把数据写入到内存（index buffer）中，同时会写入一条日志到translog日志文件中去。<ul>
<li>当写入请求到shard后，首先是写Lucene，其实就是创建索引。</li>
<li>索引创建好后并不是马上生成segment，这个时候索引数据还在缓存中，这里的缓存是lucene的缓存，并非Elasticsearch缓存，lucene缓存中的数据是不可被查询的。</li>
</ul>
</li>
<li>执行refresh操作：从内存buffer中将数据写入os cache(操作系统的内存)，产生一个segment file文件，buffer清空。<ul>
<li>写入os cache的同时，建立倒排索引，这时数据就可以供客户端进行访问了。</li>
<li>默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到。</li>
<li>buffer内存占满的时候也会执行refresh操作，buffer默认值是JVM内存的10%。</li>
<li>通过es的restful api或者java api，手动执行一次refresh操作，就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。</li>
<li>若要优化索引速度, 而不注重实时性, 可以降低刷新频率。</li>
</ul>
</li>
<li>translog会每隔5秒或者在一个变更请求完成之后，将translog从缓存刷入磁盘。<ul>
<li>translog是存储在os cache中，每个分片有一个，如果节点宕机会有5秒数据丢失，但是性能比较好，最多丢5秒的数据。。</li>
<li>可以将translog设置成每次写操作必须是直接fsync到磁盘，但是性能会差很多。</li>
<li>可以通过配置增加transLog刷磁盘的频率来增加数据可靠性，最小可配置100ms，但不建议这么做，因为这会对性能有非常大的影响。</li>
</ul>
</li>
<li>每30分钟或者当tanslog的大小达到512M时候，就会执行commit操作（flush操作），将os cache中所有的数据全以segment file的形式，持久到磁盘上去。<ul>
<li>第一步，就是将buffer中现有数据refresh到os cache中去。</li>
<li>清空buffer 然后强行将os cache中所有的数据全都一个一个的通过segmentfile的形式，持久到磁盘上去。</li>
<li>将commit point这个文件更新到磁盘中，每个Shard都有一个提交点(commit point), 其中保存了当前Shard成功写入磁盘的所有segment。</li>
<li>把translog文件删掉清空，再开一个空的translog文件。</li>
<li>flush参数设置：<ul>
<li>index.translog.flush_threshold_period:</li>
<li>index.translog.flush_threshold_size:</li>
<li># 控制每收到多少条数据后flush一次</li>
<li>index.translog.flush_threshold_ops:</li>
</ul>
</li>
</ul>
</li>
<li>Segment的merge操作：<ul>
<li>随着时间，磁盘上的segment越来越多，需要定期进行合并。</li>
<li>Es和Lucene 会自动进行merge操作，合并segment和删除已经删除的文档。</li>
<li>我们可以手动进行merge：POST index/_forcemerge。一般不需要，这是一个比较消耗资源的操作。</li>
</ul>
</li>
</ol>
<h1 id="六、剖析分布式查询及相关性算分"><a href="#六、剖析分布式查询及相关性算分" class="headerlink" title="六、剖析分布式查询及相关性算分"></a>六、剖析分布式查询及相关性算分</h1><p>Elasticsearch 的搜索，会分两个阶段进行：</p>
<ul>
<li><p>第一阶段-Query</p>
</li>
<li><p>第二阶段-Fetch</p>
<p>即Query-Then-Fetch。</p>
</li>
</ul>
<h3 id="1、Query-阶段"><a href="#1、Query-阶段" class="headerlink" title="1、Query 阶段"></a>1、Query 阶段</h3><ol>
<li>用户发出搜索请求到 ES 节点。节点收到请求后，会以Coordinating 节点的身份，在6个主副分片中随机选择3个分片，发送查询请求。</li>
<li>被选中的分片执行查询，执行排序。然后，每个分片都会查询 From + Size 个排序后的文档 id 和排序值给 Coordinating 节点。</li>
</ol>
<h3 id="2、Fetch-阶段"><a href="#2、Fetch-阶段" class="headerlink" title="2、Fetch 阶段"></a>2、Fetch 阶段</h3><ol>
<li>Coordinating Node 会将 Query 阶段，从每个分片获取的排序后的文档 id 列表，重新进行排序。再获取第 from 索引开始的 size 个文档进行返回。</li>
<li>以 multi get 请求的方式，到相应的分片获取详细的文档数据。</li>
</ol>
<h3 id="3、Query-Then-Fetch-潜在问题"><a href="#3、Query-Then-Fetch-潜在问题" class="headerlink" title="3、Query Then Fetch 潜在问题"></a>3、Query Then Fetch 潜在问题</h3><ul>
<li><p>性能问题</p>
<p>每个分片上需要查询的文档个数=from+size，最终协调节点需要处理：number_of_shard * (from+size)，如果查询的数量很大，协调节点就需要处理很多的文档。对于分布式搜索来说，搜索引擎在处理深度分页的时候对性能有很大的挑战。</p>
</li>
<li><p>相关性算分</p>
<p>每个分片都基于自己的分片上的数据进行相关度计算。这会导致打分偏离的情况。特别是数据量很少时。相关性算分在分片之间是相互独立。当文档总数很少的情况下，如果主分片大于1，主分片数越多，相关性算分会越不准。</p>
</li>
</ul>
<h3 id="4、解决算分不准的方法"><a href="#4、解决算分不准的方法" class="headerlink" title="4、解决算分不准的方法"></a>4、解决算分不准的方法</h3><ol>
<li><p>数据量不大的时候，可以将主分片数设置为1，当数据量足够大的时候只要保证文档均匀分散在各个分片上，结果一般就不会出现偏差。</p>
</li>
<li><p>使用 DFS Query Then Fetch</p>
<p>在搜索的 URL中指定参数<code>_search?search_type=dfs_query_then_fetch</code>，到每个分片把各分片的词频和文档频率进行搜集，然后完整地进行一次相关性算分，这会耗费更多的 CPU 和内存，执行性能底下，一般不建议使用。</p>
</li>
</ol>
<h3 id="5、-算分不准演示例子"><a href="#5、-算分不准演示例子" class="headerlink" title="5、 算分不准演示例子"></a>5、 算分不准演示例子</h3><ol>
<li><p>建立一个索引分别写入三个文档，不指定分片数，默认1个主分片，不会出现分布式算分不准的情况，我们调用一次对于 content 字段的 term 查询。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093145.png" alt="image-20200427063900495"></p>
<p>发现得到的结果确实是正确的，good 的算分是最高的</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093146.png" alt="image-20200427064056926"></p>
</li>
<li><p>设置主分片数为20，重新写入数据并指定它们的路由 key 为1、2、3将它们路由到不同的节点上</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093147.png" alt="image-20200427064225713"></p>
</li>
<li><p>然后再进行一次查询：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093148.png" alt="image-20200427064410756"></p>
</li>
<li><p>发现返回的3条结果的分值是一样的，”good”排在了最后。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093149.png" alt="image-20200427064450602"></p>
</li>
<li><p>我们对查询加上 explain 参数之后可以发现3个文档是位于不同的分片上的</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093150.png" alt="image-20200427064628146"></p>
</li>
<li><p>使用<code>_search?search_type=dfs_query_then_fetch</code>参数查询，算分又正确了</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093151.png" alt="image-20200427064758833"></p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093152.png" alt="image-20200427064808784"></p>
</li>
</ol>
<h3 id="6、Kibana-测试请求"><a href="#6、Kibana-测试请求" class="headerlink" title="6、Kibana 测试请求"></a>6、Kibana 测试请求</h3><pre><code>DELETE message
PUT message
{
  &quot;settings&quot;: {
    &quot;number_of_shards&quot;: 20
  }
}

GET message

POST message/_doc?routing=1
{
  &quot;content&quot;:&quot;good&quot;
}

POST message/_doc?routing=2
{
  &quot;content&quot;:&quot;good morning&quot;
}

POST message/_doc?routing=3
{
  &quot;content&quot;:&quot;good morning everyone&quot;
}

POST message/_search
{
  &quot;explain&quot;: true,
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}


POST message/_search
{
  &quot;explain&quot;: true,
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;content&quot;: {
        &quot;value&quot;: &quot;good&quot;
      }
    }
  }
}


POST message/_search?search_type=dfs_query_then_fetch
{

  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;content&quot;: {
        &quot;value&quot;: &quot;good&quot;
      }
    }
  }
}</code></pre><h1 id="七、排序及-Doc-Value-amp-Fielddata"><a href="#七、排序及-Doc-Value-amp-Fielddata" class="headerlink" title="七、排序及 Doc Value&amp;Fielddata"></a>七、排序及 Doc Value&amp;Fielddata</h1><h3 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h3><p>Elasticsearch 默认采用相关性算分对结果进行降序排序，可以通过设定 sort 参数，自行设定排序。如果不指定_score 排序，算分为 null。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093153.png" alt="image-20200427065630653"></p>
<h3 id="2、多字段进行排序"><a href="#2、多字段进行排序" class="headerlink" title="2、多字段进行排序"></a>2、多字段进行排序</h3><p>传入一个数组到 sort 属性，组合多个条件，优先考虑写在前面的字段的排序，支持混合相关性算分进行排序</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093154.png" alt="image-20200427065811847"></p>
<h3 id="3、Doc-Values-vs-Fielddata"><a href="#3、Doc-Values-vs-Fielddata" class="headerlink" title="3、Doc Values vs Fielddata"></a>3、Doc Values vs Fielddata</h3><h4 id="对-Text-类型字段排序"><a href="#对-Text-类型字段排序" class="headerlink" title="对 Text 类型字段排序"></a>对 Text 类型字段排序</h4><p>当我们尝试对一个 text 类型的字段”customer_full_name”进行排序的时候，遇到一个报错告诉我们<code>fielddata</code>默认是关闭的，需要打开才能执行</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093155.png" alt="image-20200427070442266"></p>
<p>现在我们来了解一下排序的过程：</p>
<ul>
<li>排序是真毒 i字段原始内容进行的。此时倒排索引无法发挥作用，需要用到正排索引。通过文档 id 和字段快速得到字段原始内容。</li>
<li>Elasticsearch 对于排序有两种实现方法：Fielddata 和 DocValues（列式存储，对 Text 类型无效）</li>
</ul>
<p>Doc Values 现在的版本是默认打开的，它是随着倒排索引的创建一起创建（非文本类型都是结构化数据）放在磁盘上的；而 Fielddata 现在的版本默认是关闭的，因为对于文本类型数据的排序本来就是意义不大的，它是将文本数据加载到内存中进行排序的，如果排序的内容很多，就会导致内存占用很大。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093156.png" alt="image-20200427070654710"></p>
<h4 id="打开-Fieldata"><a href="#打开-Fieldata" class="headerlink" title="打开 Fieldata"></a>打开 Fieldata</h4><p>通过 Mapping 设置打开。修改设置后，即时生效，无需重建索引。</p>
<p>只支持对 Text 进行设定，其他字段类型不支持。打开后可以对 Text 字段进行排序。但是是对分词后的 term排序，所以，结果往往无法满足预期，不建议使用。</p>
<p><strong>部分情况下打开，满足一些聚合分析的特定需求</strong>。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093157.png" alt="image-20200427071221773"></p>
<h4 id="关闭-Doc-Values"><a href="#关闭-Doc-Values" class="headerlink" title="关闭 Doc Values"></a>关闭 Doc Values</h4><p>通过 Mapping 设置关闭，可以增加索引的速度，减少磁盘空间。</p>
<p>如果关闭之后重新打开，需要重建索引。所以我们要再明确不需要做排序和聚合分析的时候才关闭。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093158.png" alt="image-20200427071516025"></p>
<h4 id="获取-Doc-Values-amp-Fielddata-中存储的内容"><a href="#获取-Doc-Values-amp-Fielddata-中存储的内容" class="headerlink" title="获取 Doc Values &amp; Fielddata 中存储的内容"></a>获取 Doc Values &amp; Fielddata 中存储的内容</h4><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093159.png" alt="image-20200427072026009"></p>
<h1 id="八、分页与遍历：From、Size、Search-After-amp-Scroll-API"><a href="#八、分页与遍历：From、Size、Search-After-amp-Scroll-API" class="headerlink" title="八、分页与遍历：From、Size、Search After &amp; Scroll API"></a>八、分页与遍历：From、Size、Search After &amp; Scroll API</h1><h3 id="From-amp-Size"><a href="#From-amp-Size" class="headerlink" title="From &amp; Size"></a>From &amp; Size</h3><p><strong>默认情况下，ES 查询按照相关度算分排序，返回前10条记录</strong>。这是一个比较标准的容易理解的分页方案，from 表示开始位置，size 表示期望获取文档的总数。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093200.png" alt="image-20200427085551796"></p>
<h4 id="分布式系统中深度分页的问题"><a href="#分布式系统中深度分页的问题" class="headerlink" title="分布式系统中深度分页的问题"></a>分布式系统中深度分页的问题</h4><p>ES 天生就是分布式的。查询信息的时候数据分别保存在多个分片，多台机器上，ES 天生就需要满足排序的需要（按照相关性算分）。</p>
<p>如果一个查询是分页参数from=990、size=10。ES 会在每个分片上先都获取1000个文档。然后，通过 Coordinating Node 聚合所有结果。最后再通过排序选取出前1000个文档，然后取第990位开始的后10个文档进行返回。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093201.png" alt="image-20200427085922577"></p>
<p>当页数越深的时候，占用内存就越多。为了避免深度分页带来的内存开销。ES 有一个设定，默认限定到10000 个(from + size)文档。另外，我们可以通过<code>index.max_result_window</code>来调整这个数值。</p>
<p>下面我们在图一图二分别尝试设置 from 和 size 到比较大的数量，让 from+size 超过10000，就会获得图三的报错。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093202.png" alt="image-20200427090103760"></p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093203.png" alt="image-20200427090144141"></p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093204.png" alt="image-20200427090123802"></p>
<p>如果我们设置在10000的范围之内，可以返回结果，但是需要消耗比较长的时间，本示例消耗了2-3秒。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093205.png" alt="image-20200427090305345"></p>
<h3 id="Search-After"><a href="#Search-After" class="headerlink" title="Search After"></a>Search After</h3><p>我们可以使用 Search After 来避免深度分页带来的性能问题，这个 API 表示实时获取下一页文档信息。但是它在功能上有以下的限制：</p>
<ul>
<li>不支持指定页数（设定 From 值）</li>
<li>只能往下翻</li>
</ul>
<p>调用 Search After：</p>
<ul>
<li>第一步搜索需要指定 sort，并且保证值是唯一的（可以通过加入_id 保证唯一性）</li>
<li>然后后面的查询就使用上一次返回的文档的 sort 值进行查询</li>
</ul>
<p>Demo：</p>
<ol>
<li><p>写入数据</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093206.png" alt="image-20200427090802728"></p>
</li>
<li><p>第一次查询：指定 size 是1，表示每次查询只返回1条记录，然后我们是根据 age 来排序并分页的，但是为了保证排序的唯一性，我们加入了_id 字段。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093207.png" alt="image-20200427090843029"></p>
<p>执行之后返回以下数据，包含了一个文档，同时也返回了一个 sort 值（返回文档中按照指定排序之后的最后一个文档的 sort 字段的值）给我们用于下一次查询。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093208.png" alt="image-20200427091124426"></p>
</li>
<li><p>将第一次获取到的 sort 值传入到 search_after 属性中</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093209.png" alt="image-20200427091328864"></p>
<p>执行，即可得到第2次结果，这次执行又返回了一个 sort 值，我们通过不断地将上一次查询返回的 sort 值放到查询的 search_after 属性中进行下一次查询即可达到一个不断分页的效果，直到达到了最后 size 条数据，则没有返回一个没有文档数据的空数组。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093210.png" alt="image-20200427091410238"></p>
</li>
</ol>
<h4 id="Search-After-如何解决深度分页问题"><a href="#Search-After-如何解决深度分页问题" class="headerlink" title="Search After 如何解决深度分页问题"></a>Search After 如何解决深度分页问题</h4><p>每个 ES 分片通过指定唯一排序值定位到大于等于唯一排序值之后的 size 个文档进行返回。</p>
<p>这样的话在 from 比较大，size 比较小的深度分页问题上，例如当查询from=990，size=10 的时候，原本每个分片都会返回 i000个文档，现在只会返回10个文档给 coordinating 节点进行处理。（但是如果是 size 非常大的深度分页，还是有一定的问题）</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093211.png" alt="image-20200427093011710"></p>
<h3 id="Scroll-API"><a href="#Scroll-API" class="headerlink" title="Scroll API"></a>Scroll API</h3><p>ES 还提供了一个 Scoll API，它会基于当前的查询创建一个快照，用户可以对这个快照进行遍历操作。<strong>但是如果创建快照之后有新的数据写入到该索引，这个快照对于这个数据是无感知的，也就是说在遍历快照的时候是查询不到这个数据的</strong>。</p>
<p>我们看一下下面的 Demo，在第一次查询的时候我们执行一个 search 操作，并通过参数<code>scroll=5m</code>表示基于当前的查询结果创建一个5分钟的快照。执行之后可以看到返回结果中包含了一个 _scroll_id，表示我们下一次遍历的指针。( 同时下面也返回了查询的结果，这里截图没有截出来)</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093212.png" alt="image-20200427093505612"></p>
<p> 然后我们将这个_scroll_id 拿出来放到下面的 _search/ scroll api进行进行遍历操作，可以看到，我们拿到了当前遍历的结果，并且返回了下一次遍历要用到的 _scroll_id，以此类推，我们就可以实现对一个快照进行遍历的操作。（另外，scroll api 应该还有其他的一些配置项，带研究）</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093213.png" alt="image-20200427093906382"></p>
<h3 id="不同的搜索类型和使用场景"><a href="#不同的搜索类型和使用场景" class="headerlink" title="不同的搜索类型和使用场景"></a>不同的搜索类型和使用场景</h3><ul>
<li>Regular：需要实时获取顶部的部分文档。例如查询最新的订单</li>
<li>Scroll：需要全部文档，例如导出全部数据</li>
<li>Pagination：From 和 Size；如果需要深度分页，则选用 Search API。（ 深度分页，并不是搜索引擎所擅长的。google也一样。应该结合其他存储介质例如关系型数据库和es一起使用。es用来实现全文检索）</li>
</ul>
<h1 id="九、-处理读写操作"><a href="#九、-处理读写操作" class="headerlink" title="九、 处理读写操作"></a>九、 处理读写操作</h1><h3 id="并发控制的必要性"><a href="#并发控制的必要性" class="headerlink" title="并发控制的必要性"></a>并发控制的必要性</h3><p>举个例子，当有两个 Web 应用分别销售了一个商品，这时候需要进行扣减库存的操作，那么它们同时从 ES 中获取了一个商品的库存为100，然后分别做了库存扣减1的动作，然后 WEB1更新 ES 中该商品库存为99，然后 WEB2又将 ES 中该商品库存进行更新为99。那么这时候这个库存就不对了。它实际上应该是98，这就是修改丢失的并发问题。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093214.png" alt="image-20200427135812392"></p>
<p>处理这种问题有两种方式：</p>
<ul>
<li><p>悲观并发控制</p>
<p>假定有变更冲突的可能。会对资源加锁，防止冲突，例如数据库行锁。</p>
</li>
</ul>
<ul>
<li><p>乐观并发控制</p>
<p>假定冲突是不会发生的，不会阻塞正在尝试的操作。如果数据在读写中被修改，更新将会失败。应用程序决定如何解决冲突，例如重试更新，使用新的数据，或者将错误报告给用户。</p>
</li>
</ul>
<p>而 ES 采用的是乐观并发控制。</p>
<h3 id="ES-的乐观并发控制"><a href="#ES-的乐观并发控制" class="headerlink" title="ES 的乐观并发控制"></a>ES 的乐观并发控制</h3><p>ES 中的文档是不可变更的。如果你更新一个文档，会将该文档标记为删除，同时增加一个全新的文档。同时文档的 version 字段加1。</p>
<p>ES 提供的乐观并发控制分为内部版本控制和外部版本控制：</p>
<ul>
<li><p>内部版本控制：使用 _seq_no 和 _primary_term 两个字段</p>
<p>在 ES 的早期版本中，它是可以通过 _version 属性来实现内部的版本控制的，但是在新版本中使用 _version 来进行并发控制已经被废除了。现在我们来看一个例子。</p>
<p>我们先建立一个 products 的索引然后写入一个 id为1的文档。可以看到写入数据成功，ES 给我们返回的 _version 是1，另外还有 _seq_no 和 _primary_term 两个属性值为0和1。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093215.png" alt="image-20200427140658437"></p>
<p>现在我们尝试对该文档进行更新，并使用 ES 的乐观版本控制，我们在请求的时候带上我们在修改数据之前通过查询得到的 _seq_no 和 _primary_term （0和1）。可以看到更新成功，返回的版本号 _version 被更新为2。另外 _seq_no 被更新为1， _primary_term 不变，还是1（这个 _primary_term 个人猜测应该是一个文档的唯一标识，这里应该就是 _id）。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093216.png" alt="image-20200427141023663"></p>
<p>然后我们尝试对该请求参数再发起一次请求，ES 给我们返回了版本冲突错误：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093217.png" alt="image-20200427141405280"></p>
</li>
</ul>
<ul>
<li><p>外部版本控制：使用 _version 和 _version_type 属性</p>
<p>如果我们是使用数据库作为主要的数据存储介质，ES 仅仅是作为一个搜索引擎将数据同步到其中，那么我们可以设计在数据库中存储一个版本字段，然后将这个字段的值在 ES 中进行版本控制。我们看下面例子，在请求将 id 为1的文档进行更新的时候，我们对两个请求参数进行了设置： _version_type 设置为 external，这时候 ES 就允许我们对 _version 进行设值，我们可以将我们在数据库中设计的那个版本控制的字段的值设置到该字段，进行更新操作。可以看到更新成功，商品的版本号变成了我们写入的那个。（因为 _seq_no 不能被我们外部修改，所以区分了内部版本控制和外部版本控制）</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093218.png" alt="image-20200427141827385"></p>
<p>此时我们再将该请求发送到 ES 的时候，将会收到版本冲突报错</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093219.png" alt="image-20200427142143538"></p>
</li>
</ul>
<h3 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h3><p>可以看到 ES 为我们提供了乐观版本控制的方式来解决”修改丢失”（或者叫修改覆盖）的方法。但是它并没有提供相关的传统关系型数据库中的事务解决方案（四大隔离级别，解决脏读、幻读、不可重复读的问题），所以如果我们对于事务有很强的要求，那么必须使用数据库进行数据更新的交互，在一个事务最终完成之后得到了一个当前事务的结果之后再使用以上的 ES 乐观版本控制进行 ES 的同步。</p>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《006_分布式特性及分布式搜索的机制》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/05/04/elasticsearch/006-fen-bu-shi-te-xing-ji-fen-bu-shi-sou-suo-de-ji-zhi/" property="cc:attributionName"
               rel="cc:attributionURL">
                阿钟
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '466e387c08bce10f3f28',
        clientSecret: '5b2bf16f8a42bd72eef32e50187c7f2ccb105a1d',
        repo: 'azhong.github.io',
        owner: 'JohnZhongg',
        admin: "JohnZhongg",
        id: '2020/05/04/elasticsearch/006-fen-bu-shi-te-xing-ji-fen-bu-shi-sou-suo-de-ji-zhi/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/04/elasticsearch/008-shu-ju-jian-mo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="008_数据建模">
                        
                        <span class="card-title">008_数据建模</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ES学习
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ES学习/" class="post-category" target="_blank">
                                    ES学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES学习/" target="_blank">
                        <span class="chip bg-color">ES学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/04/elasticsearch/004-elasticsearch-ru-men/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="004_Elasticsearch 入门">
                        
                        <span class="card-title">004_Elasticsearch 入门</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ES学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ES学习/" class="post-category" target="_blank">
                                    ES学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES学习/" target="_blank">
                        <span class="chip bg-color">ES学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2020- Azhong. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">624.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/https://github.com/JohnZhongg" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:707845008@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/change-94-17" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=707845008&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


<!-- 


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 12, 20, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>