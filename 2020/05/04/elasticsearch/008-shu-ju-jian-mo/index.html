<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="008_数据建模, 技术博客 钟鸿鹏 honphan 阿钟">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="[toc]
数据的关联关系真实世界中有很多重要的关联关系：

博客、作者、评论
银行账户有多次交易记录
客户有多个银行账户
目录文件有多个文件和子目录

在关系型数据库中，提供了一些范式化设计。

1NF：消除非主属性对键的部分函数依赖
2">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>008_数据建模 | 阿钟的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">阿钟的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">阿钟的博客</div>
        <div class="logo-desc">
            
            广东工业大学 | 计算机科学与技术
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JohnZhongg" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JohnZhongg" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        008_数据建模
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/ES学习/" target="_blank">
                            <span class="chip bg-color">ES学习</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/ES学习/" class="post-category" target="_blank">
                            ES学习
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-04
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    阿钟
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    62 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[toc]</p>
<h1 id="数据的关联关系"><a href="#数据的关联关系" class="headerlink" title="数据的关联关系"></a>数据的关联关系</h1><p>真实世界中有很多重要的关联关系：</p>
<ul>
<li>博客、作者、评论</li>
<li>银行账户有多次交易记录</li>
<li>客户有多个银行账户</li>
<li>目录文件有多个文件和子目录</li>
</ul>
<p>在关系型数据库中，提供了一些范式化设计。</p>
<ul>
<li>1NF：消除非主属性对键的部分函数依赖</li>
<li>2NF：消除非主要属性对键的传递函数依赖</li>
<li>3NF：消除主属性对键的传递函数依赖</li>
<li>BCNF：主属性不依赖于主属性</li>
</ul>
<p>范式化设计（Normalization） 主要目的是”减少不必要的更新”。但是带来的副作用就是，一个完全范式化设计的数据库会经常面临”查询缓慢”的问题（数据库越范式化，就需要 join 越多的表）在最近的场景中，随着查询场景的增多，这个问题会暴露的越明显。除了可以简化操作（减少不必要的更新）之外还有节省存储空间的优点。但是最近存储空间却越来越便宜。</p>
<p>所以就有了反范式化设计（Denormalization）的概念。反范式化设计就是使得数据”Flattening”（扁平化），不使用关联关系，而是在文档中保存冗余的数据拷贝。</p>
<ul>
<li>其优点是无需处理 join 操作，数据读取性能好。Elasticsearch 通过压缩_source 字段，减少磁盘空间的开销。</li>
<li>缺点是不适合在数据频繁修改的场景，一条数据的改动，可能会引起很多数据的更新。</li>
</ul>
<p>关系型数据库一般会考虑 Normalize 数据；而在 Elasticsearch 中，往往考虑 Denormalize 数据，读取数据的时候无需连接表、无需行锁、读取速度变快。</p>
<p>Elasticsearch 并不擅长处理关联关系。我们一般采用以下4种方法处理关联：</p>
<ul>
<li>对象类型</li>
<li>嵌套对象（Nested Object）</li>
<li>父子关联关系（Parent/Child）</li>
<li>用户自己在应用端关联</li>
</ul>
<h3 id="对象及-Nested-对象"><a href="#对象及-Nested-对象" class="headerlink" title="对象及 Nested 对象"></a>对象及 Nested 对象</h3><p>数据关系其实可以最终抽象为一对一、一对多的关系（多对一和多对多关系都是由它们转化或者组合而来）。</p>
<h4 id="案例1：一对一关系（对象）"><a href="#案例1：一对一关系（对象）" class="headerlink" title="案例1：一对一关系（对象）"></a>案例1：一对一关系（对象）</h4><p>我们来看一个以博客为主导的博客和作者的关系，对于一个博客来说，它只会有一个作者。所以我们可以通过以下设置来设定”博客”索引的 mapping。可以看到：</p>
<ul>
<li>我们在mappings 下面的 properties 属性中设置博客索引的子属性，通过设置每个 properties 的子属性的一个 type 属性来指定其具体的”ES 普通类型”。（content、time 属性）</li>
<li>但是在 user 属性中，我们没有对其 type 属性值进行设定，<strong>而是设定了一个 properties 属性</strong>，属性值是一个嵌套的 JSON 对象，它包含了”text”类型的”city”属性、”long”类型的”userid”属性、”keyword”类型的”username”属性。这就是 ES 的 “对象”类型数据的设定方式。</li>
</ul>
<pre><code>DELETE blog
# 设置blog的 Mapping
PUT /blog
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;content&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;time&quot;: {
        &quot;type&quot;: &quot;date&quot;
      },
      &quot;user&quot;: {
        &quot;properties&quot;: {
          &quot;city&quot;: {
            &quot;type&quot;: &quot;text&quot;
          },
          &quot;userid&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;username&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          }
        }
      }
    }
  }
}</code></pre><p>其实我们插入一条文档数据</p>
<pre><code># 插入一条 Blog 信息
PUT blog/_doc/1
{
  &quot;content&quot;:&quot;I like Elasticsearch&quot;,
  &quot;time&quot;:&quot;2019-01-01T00:00:00&quot;,
  &quot;user&quot;:{
    &quot;userid&quot;:1,
    &quot;username&quot;:&quot;Jack&quot;,
    &quot;city&quot;:&quot;Shanghai&quot;
  }
}</code></pre><p>在查询的时候通过 <code>user.xxx=xxx</code> 的指定作者的信息进行条件查询（包括查询的时候也是这样来更新指定博客文档中的作者信息）：</p>
<pre><code># 查询 Blog 信息
POST blog/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match&quot;: {&quot;content&quot;: &quot;Elasticsearch&quot;}},
        {&quot;match&quot;: {&quot;user.username&quot;: &quot;Jack&quot;}}
      ]
    }
  }
}</code></pre><h4 id="案例2：一对多关系（Nested-对象）"><a href="#案例2：一对多关系（Nested-对象）" class="headerlink" title="案例2：一对多关系（Nested 对象）"></a>案例2：一对多关系（Nested 对象）</h4><p>我们来看一个电影和演员的例子，这是一个一对多关系，一个电影可以包含多个演员。下面我们来分析下在 ES 中关于一对多关系是如何存储的。</p>
<h5 id="1、在索引中设置对象型字段"><a href="#1、在索引中设置对象型字段" class="headerlink" title="1、在索引中设置对象型字段"></a>1、在索引中设置对象型字段</h5><p>先准备数据。可以看到我们创建了一个电影索引，其包含了两个字段：一个是 title 字段，类型为普通类型”text”；另一个 actors 字段是一个对象类型。这个对象包含一个”keyword”普通类型的 first_name 字段和一个”keyword”普通类型的 last_name 字段（<strong>注意，在 ES 中不用指定数组类型，每个文档的每个字段默认可以存储多个值</strong>）。</p>
<p>然后我们写入了一条电影文档数据：title 为 “Speed”；actors 有：”Keanu Reeves”和”Dnnis Hopper” 两位。</p>
<pre><code>DELETE my_movies
# 电影的Mapping信息
PUT my_movies
{
      &quot;mappings&quot; : {
      &quot;properties&quot; : {
        &quot;actors&quot; : {
          &quot;properties&quot; : {
            &quot;first_name&quot; : {
              &quot;type&quot; : &quot;keyword&quot;
            },
            &quot;last_name&quot; : {
              &quot;type&quot; : &quot;keyword&quot;
            }
          }
        },
        &quot;title&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {
            &quot;keyword&quot; : {
              &quot;type&quot; : &quot;keyword&quot;,
              &quot;ignore_above&quot; : 256
            }
          }
        }
      }
    }
}


# 写入一条电影信息
POST my_movies/_doc/1
{
  &quot;title&quot;:&quot;Speed&quot;,
  &quot;actors&quot;:[
    {
      &quot;first_name&quot;:&quot;Keanu&quot;,
      &quot;last_name&quot;:&quot;Reeves&quot;
    },

    {
      &quot;first_name&quot;:&quot;Dennis&quot;,
      &quot;last_name&quot;:&quot;Hopper&quot;
    }

  ]
}</code></pre><h5 id="2、基于对象型字段的查询"><a href="#2、基于对象型字段的查询" class="headerlink" title="2、基于对象型字段的查询"></a>2、基于对象型字段的查询</h5><p>下面我们尝试来查询数据，分别指定”actors.first_name”和”actors.last_name”为”Keanu”和”Hopper”，理论上应该查询不出来数据。但是实际上看到竟然匹配到了数据。下面我们来分析下为什么会匹配到了数据</p>
<pre><code># 查询电影信息
POST my_movies/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match&quot;: {&quot;actors.first_name&quot;: &quot;Keanu&quot;}},
        {&quot;match&quot;: {&quot;actors.last_name&quot;: &quot;Hopper&quot;}}
      ]
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093627.png" alt="image-20200429143625922"></p>
<h5 id="3、ES-对对象型字段的存储方法"><a href="#3、ES-对对象型字段的存储方法" class="headerlink" title="3、ES 对对象型字段的存储方法"></a>3、ES 对对象型字段的存储方法</h5><p>为什么上面会匹配到数据呢？这是因为，ES 在对文档数据进行存储的时候，内部对象的边界是没有考虑在内的，JSON 格式被处理成扁平式键值对的结构。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093628.png" alt="image-20200429144129911"></p>
<p>当对一个对象类型的属性进行多值”并”查询的时候就会导致了意外的搜索结果。此时我们可以通过用 Nested Data Type解决这个问题。</p>
<h5 id="4、创建-nested-对象型字段"><a href="#4、创建-nested-对象型字段" class="headerlink" title="4、创建 nested 对象型字段"></a>4、创建 nested 对象型字段</h5><p>创建 nested 类型字段。删除之前创建的索引，重新创建索引，可以看到，<strong>我们在设定”actors”字段的时候除了指定”properties”属性之外，还设定了一个”type”属性为”nested”</strong>。</p>
<pre><code>DELETE my_movies
# 创建 Nested 对象 Mapping
PUT my_movies
{
      &quot;mappings&quot; : {
      &quot;properties&quot; : {
        &quot;actors&quot; : {
          &quot;type&quot;: &quot;nested&quot;,
          &quot;properties&quot; : {
            &quot;first_name&quot; : {&quot;type&quot; : &quot;keyword&quot;},
            &quot;last_name&quot; : {&quot;type&quot; : &quot;keyword&quot;}
          }},
        &quot;title&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {&quot;keyword&quot;:{&quot;type&quot;:&quot;keyword&quot;,&quot;ignore_above&quot;:256}}
        }
      }
    }
}


POST my_movies/_doc/1
{
  &quot;title&quot;:&quot;Speed&quot;,
  &quot;actors&quot;:[
    {
      &quot;first_name&quot;:&quot;Keanu&quot;,
      &quot;last_name&quot;:&quot;Reeves&quot;
    },

    {
      &quot;first_name&quot;:&quot;Dennis&quot;,
      &quot;last_name&quot;:&quot;Hopper&quot;
    }

  ]
}</code></pre><h5 id="5、基于-nested-型字段的查询和聚合"><a href="#5、基于-nested-型字段的查询和聚合" class="headerlink" title="5、基于 nested 型字段的查询和聚合"></a>5、基于 nested 型字段的查询和聚合</h5><p>基于 nested 类型字段的查询。此时我们如果需要对 nested 类型字段进行查询，就需要使用一个 “nested” 查询，然后通过设定其”path”属性为我们要查询的”nested”类型的字段名称”actors”。然后再在里面嵌套上我们前面的 bool 查询的内容。可以看到，这次查询不正确的姓和名组合就没有返回数据了。</p>
<pre><code># Nested 查询
POST my_movies/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match&quot;: {&quot;title&quot;: &quot;Speed&quot;}},
        {
          &quot;nested&quot;: {
            &quot;path&quot;: &quot;actors&quot;,
            &quot;query&quot;: {
              &quot;bool&quot;: {
                &quot;must&quot;: [
                  {&quot;match&quot;: {
                    &quot;actors.first_name&quot;: &quot;Keanu&quot;
                  }},
                  {&quot;match&quot;: {
                    &quot;actors.last_name&quot;: &quot;Hopper&quot;
                  }}
                ]
              }
            }
          }
        }
      ]
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093629.png" alt="image-20200429145346645"></p>
<p>当我们查询正确的姓名组合的时候，就可以返回正确的数据</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093630.png" alt="image-20200429145518567"></p>
<p>当我们再用一个正确的姓名组合去做一个普通的非 nested 的 bool 查询的时候，会发现也匹配不到数据了，为什么会这样呢？下面我们来分析一下原因。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093631.png" alt="image-20200429145635416"></p>
<p>另外当我们需要对 nested 类型的字段进行聚合的时候，我们一样要声明当前聚合操作是对于 nested 类型字段的聚合。通过在具体的 agg 对象内部声明一个”nested”的属性对象，一样的，该对象的”path”属性设置为 nested 类型字段的名称。</p>
<pre><code># Nested Aggregation
POST my_movies/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;actors&quot;: {
      &quot;nested&quot;: {
        &quot;path&quot;: &quot;actors&quot;
      },
      &quot;aggs&quot;: {
        &quot;actor_name&quot;: {
          &quot;terms&quot;: {
            &quot;field&quot;: &quot;actors.first_name&quot;,
            &quot;size&quot;: 10
          }
        }
      }
    }
  }
}</code></pre><h5 id="6、ES-对于-nested-型字段的存储方法"><a href="#6、ES-对于-nested-型字段的存储方法" class="headerlink" title="6、ES 对于 nested 型字段的存储方法"></a>6、ES 对于 nested 型字段的存储方法</h5><p>在 ES 中，对于 nested 数据类型，会对该字段所有对象进行独立索引。在 ES 内部会将这个多个nested 类型属性对象索引到多个分隔的 Lucene 文档中，在查询的时候做 Join 处理。所以我们在对 nested 类型数据的时候需要 nested 查询，该查询会让 ES 知道当前用户需要到另外的一个独立的 nested 文档集合进行数据查找，而 nested 这个文档集合的名称（用来在当前索引中聚合这些文档，其实可以理解为给这些文档起了个统一前缀）在建立的时候是取的该 nested 类型字段名做关联的，所以我们需要指定字段名告诉 ES 到哪个nested 文档集合进行关联查询。</p>
<p>另外我们上面还尝试使用正确姓和名的组合是查询不出来数据的。正如我们上面的描述，ES 在存储 nested 类型数据的时候是存储到另外一个专门存储 nested 类型字段数据的独立文档中的，所以一个正常的 bool 查询就是在当前文档中进行指定的”键值匹配”。当然找不到数据！</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093632.png" alt="image-20200429150333417"></p>
<h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-nested-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-nested-query.html</a></p>
</blockquote>
<h3 id="文档的父子关系"><a href="#文档的父子关系" class="headerlink" title="文档的父子关系"></a>文档的父子关系</h3><p>经过上面的介绍我们知道了可以使用对象类型字段和 nested 对象类型字段存储有关系的数据。但是使用这两种数据类型有一个局限性就是，当需要对文档中的嵌套的对象类型字段或者 nested 对象类型字段进行更新的时候，我们往往也要更新其他文档中的数据。</p>
<p>例如1个作者有3篇文章，我们在 ES 中存储了以文章为主导的文档数据，其中文章文档中有一个对象（或者 nested 对象）类型字段表示其作者。所以当前索引中是有三个文章文档的作者字段内容是一样的，但我们修改了这个作者的信息的时候，需要同时更新这三个文章文档。</p>
<p>这在某些索引的写操作远远比读操作要频繁的时候，是很不友好的。所以 ES 还提供了另外一种类似关系型数据库中 join 的实现。使用 join 数据类型实现，可以 通过维护 parent、child 的关系，从而分离两个对象：</p>
<ul>
<li>父文档和子文档是同时存在于索引中的两个独立的文档</li>
<li>更新父文档无需重新索引子文档。子文当被添加，更新或者删除也不会影响父文档和其他的子文档。</li>
</ul>
<h5 id="1、定义父子关系的几个步骤"><a href="#1、定义父子关系的几个步骤" class="headerlink" title="1、定义父子关系的几个步骤"></a>1、定义父子关系的几个步骤</h5><p>我们使用以下请求创建一个名为”my_blogs”的索引：</p>
<ol>
<li><p>通过 settings 设定了该索引的分片数为2</p>
</li>
<li><p>在 mappinigs 中显示设置了两个字段为 context 和 title，前者为 text 类型，后者为 keyword 类型。在业务上，这两个字段都属于博客的字段。</p>
</li>
<li><p>此外在 mappings 中我们还设置了一个关键属性”blog_comments_relation”，它的 type 字段不是 ES 中的普通字段类型也不是 nested 类型，而是”join”，ES 会基于该属性在该索引上建立一个父子文档关系对象。</p>
<p>其中由”relations”关键字来维护多个父子关系集合，relation 对象的每个属性都代表一个父子关系，可以通过设置多个属性来设置多个父子关系：其中属性名为当前父子关系中的父文档的标识；属性值为当前父子关系的子文档标识。在往当前索引中索引文档的时候通过设置文档字段”blog_comments_relation.name”为 relation 中某个属性的属性名后者属性值来指定当前文档是哪对父子关系中的父或者子文档。</p>
<p><strong>（注意：同一个索引中不能创建多个”join”类型的同级属性；relations 关键字不支持多值。设置了就会报4xx 的错误）</strong></p>
</li>
</ol>
<pre><code>DELETE my_blogs
# 设定 Parent/Child Mapping
PUT my_blogs
{
  &quot;settings&quot;: {
    &quot;number_of_shards&quot;: 2
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;blog_comments_relation&quot;: {
        &quot;type&quot;: &quot;join&quot;,
        &quot;relations&quot;: {
          &quot;blog&quot;: &quot;comment&quot;
        }
      },
      &quot;content&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;title&quot;: {
        &quot;type&quot;: &quot;keyword&quot;
      }
    }
  }
}</code></pre><h5 id="2、索引父文档"><a href="#2、索引父文档" class="headerlink" title="2、索引父文档"></a>2、索引父文档</h5><p>下面我们索引两个父文档（博客数据对象）到索引中：</p>
<ol>
<li>我们分别为它们指定了 id 为”blog1”和”blog2”，为了后面索引子文档的时候方便获取该 id</li>
<li>它们包含的字段有”title”和”content”</li>
<li>其中我们还通过指定文档数据的”blog_comments_relation.name”来标识其为”blog:comment”父子关系中的父文档（blog）</li>
</ol>
<pre><code>#索引父文档
PUT my_blogs/_doc/blog1
{
  &quot;title&quot;:&quot;Learning Elasticsearch&quot;,
  &quot;content&quot;:&quot;learning ELK @ geektime&quot;,
  &quot;blog_comments_relation&quot;:{
    &quot;name&quot;:&quot;blog&quot;
  }
}

#索引父文档
PUT my_blogs/_doc/blog2
{
  &quot;title&quot;:&quot;Learning Hadoop&quot;,
  &quot;content&quot;:&quot;learning Hadoop&quot;,
    &quot;blog_comments_relation&quot;:{
    &quot;name&quot;:&quot;blog&quot;
  }
}</code></pre><h5 id="3、索引子文档"><a href="#3、索引子文档" class="headerlink" title="3、索引子文档"></a>3、索引子文档</h5><p>下面我们往索引中索引了3个子文档：</p>
<ol>
<li><p>我们分别指定了它们的 id 为 comment1、comment2和 comment3并<strong>给他们设置了路由分片的 hash key 为对应的父文档 id，这非常重要，我们需要保证父文档和子文档必须存在相同的分片上以确保查询 join 的性能。</strong>（如果父文档和子文档没有同时在同一个分片上会发生什么？这个待后续研究）</p>
</li>
<li><p>子文档包含了两个未在 mapping 上显示声明的字段 comment 和 username</p>
</li>
<li><p><strong>通过指定文档的”blog_comments_relation.name”属性为 comment 来指定当前文档为”blog:comment”父子关系中的子文档。</strong></p>
<p><strong>通过指定文档的”blog_comments_relation.parent”属性为当前文档的父文档 id 来指定当前子文档的父文档，这是必须的</strong></p>
</li>
</ol>
<pre><code>#索引子文档
PUT my_blogs/_doc/comment1?routing=blog1
{
  &quot;comment&quot;:&quot;I am learning ELK&quot;,
  &quot;username&quot;:&quot;Jack&quot;,
  &quot;blog_comments_relation&quot;:{
    &quot;name&quot;:&quot;comment&quot;,
    &quot;parent&quot;:&quot;blog1&quot;
  }
}

#索引子文档
PUT my_blogs/_doc/comment2?routing=blog2
{
  &quot;comment&quot;:&quot;I like Hadoop!!!!!&quot;,
  &quot;username&quot;:&quot;Jack&quot;,
  &quot;blog_comments_relation&quot;:{
    &quot;name&quot;:&quot;comment&quot;,
    &quot;parent&quot;:&quot;blog2&quot;
  }
}

#索引子文档
PUT my_blogs/_doc/comment3?routing=blog2
{
  &quot;comment&quot;:&quot;Hello Hadoop&quot;,
  &quot;username&quot;:&quot;Bob&quot;,
  &quot;blog_comments_relation&quot;:{
    &quot;name&quot;:&quot;comment&quot;,
    &quot;parent&quot;:&quot;blog2&quot;
  }
}</code></pre><h5 id="4、查询"><a href="#4、查询" class="headerlink" title="4、查询"></a>4、查询</h5><h6 id="1）查询所有文档"><a href="#1）查询所有文档" class="headerlink" title="1）查询所有文档"></a>1）查询所有文档</h6><p>可以看到查询所有文档的时候，索引内的所有父子文档都是可以返回的，包括文档的父子关系标识信息。</p>
<pre><code># 查询所有文档
POST my_blogs/_search
{

}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093633.png" alt="image-20200429170601599"></p>
<h6 id="2）通过文档-id-直接查询父文档（不包含子文档内容）"><a href="#2）通过文档-id-直接查询父文档（不包含子文档内容）" class="headerlink" title="2）通过文档 id 直接查询父文档（不包含子文档内容）"></a>2）通过文档 id 直接查询父文档（不包含子文档内容）</h6><p>可以看到也是可以返回的，父文档不包含子文档的内容</p>
<pre><code>#根据父文档ID查看
GET my_blogs/_doc/blog2</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093634.png" alt="image-20200429170747744"></p>
<h6 id="3）通过-“parent-id”-查询查询子文档信息"><a href="#3）通过-“parent-id”-查询查询子文档信息" class="headerlink" title="3）通过 “parent_id” 查询查询子文档信息"></a>3）通过 “parent_id” 查询查询子文档信息</h6><ul>
<li>指定 query 为 parent_id 类型的查询</li>
<li>并设置parent_id 的子属性 type 为 comment（即 mapping 中设置的 relations 关键字中的属性值）指定子文档的类型</li>
<li>指定 parent_id 的子属性 id 为父文档的 id “blog2”</li>
</ul>
<p>可以看到，ES 返回了 blog2 父文档的2个子文档 comment2和 comment3</p>
<pre><code># Parent Id 查询
POST my_blogs/_search
{
  &quot;query&quot;: {
    &quot;parent_id&quot;: {
      &quot;type&quot;: &quot;comment&quot;,
      &quot;id&quot;: &quot;blog2&quot;
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093635.png" alt="image-20200429171114422"></p>
<h6 id="4）”has-child”-查询通过子文档的信息查询父文档"><a href="#4）”has-child”-查询通过子文档的信息查询父文档" class="headerlink" title="4）”has_child” 查询通过子文档的信息查询父文档"></a>4）”has_child” 查询通过子文档的信息查询父文档</h6><ul>
<li>指定 query 类型为”has_child”查询类型</li>
<li>通过设置 has_child 的子属性 type 为comment（即 mapping 中设置的 relations 关键字中的属性值）指定子文档的类型</li>
<li>设置一个查询对象到 has_child 的子属性，这里设置为 match 查询类型，查询字段是 username，值为 “Jack”</li>
</ul>
<p>以上请求在收到信息之后会去查询类型为 comment 的子文档中是否有 username 为”jack”的文档，如果有，则返回其关联的父文档。可以看到，结果中返回了 blog1和 blog2父文档，它们分别关联一个comment1和 comment2子文档其中 username 字段都是 Jack。</p>
<pre><code># Has Child 查询,返回父文档
POST my_blogs/_search
{
  &quot;query&quot;: {
    &quot;has_child&quot;: {
      &quot;type&quot;: &quot;comment&quot;,
      &quot;query&quot; : {
          &quot;match&quot;: {
              &quot;username&quot; : &quot;Jack&quot;
          }
      }
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093636.png" alt="image-20200429171625009"></p>
<h6 id="5）”has-parent”-查询通过父文档的信息查询子文档"><a href="#5）”has-parent”-查询通过父文档的信息查询子文档" class="headerlink" title="5）”has_parent” 查询通过父文档的信息查询子文档"></a>5）”has_parent” 查询通过父文档的信息查询子文档</h6><p>和”has_child”类似，”has_parent”则是通过父文档的信息查询子文档。</p>
<ul>
<li>指定 query 类型为”has_parent”查询类型</li>
<li>通过设置 has_parent 的子属性 type 为 blog（即 mapping 中设置的 relations 关键字中的属性值）指定父文档的类型</li>
<li>设置一个查询对象到 has_parent 的子属性，这里设置为 match 查询类型，查询字段是  title，值为 “Learning Hadoop”</li>
</ul>
<p>以上请求在收到信息之后会去查询类型为 blog 的父文档中进行”titile = Learning Hadoop”的 match 查询，如果匹配到了文档数据，则返回其关联的子文档。可以看到，结果中返回了 comment2和 comment3 子文档，它们都关联 blog2父文档，而该父文档的 title 就是”Learning Hadoop”（该字段类型是 keyword，精准匹配）。</p>
<pre><code># Has Parent 查询，返回相关的子文档
POST my_blogs/_search
{
  &quot;query&quot;: {
    &quot;has_parent&quot;: {
      &quot;parent_type&quot;: &quot;blog&quot;,
      &quot;query&quot; : {
        &quot;match&quot;: {
            &quot;title&quot; : &quot;Learning Hadoop&quot;
        }
      }
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093637.png" alt="image-20200429172448481"></p>
<h6 id="6）-通过文档-id-直接访问子文档"><a href="#6）-通过文档-id-直接访问子文档" class="headerlink" title="6） 通过文档 id 直接访问子文档"></a>6） 通过文档 id 直接访问子文档</h6><p>当我们直接通过子文档的 id 进行访问子文档的时候，是查询不到子文档的。</p>
<pre><code>#通过ID ，访问子文档
GET my_blogs/_doc/comment3</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093638.png" alt="image-20200429173007166"></p>
<p>需要在id 后面加上 routing 才行：</p>
<pre><code>#通过ID和routing ，访问子文档
GET my_blogs/_doc/comment3?routing=blog2</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093639.png" alt="image-20200429173042470"></p>
<p>另外通过 id 更新子文档的时候也要指定 routing：</p>
<pre><code>#更新子文档
PUT my_blogs/_doc/comment3?routing=blog2
{
    &quot;comment&quot;: &quot;Hello Hadoop??&quot;,
    &quot;blog_comments_relation&quot;: {
      &quot;name&quot;: &quot;comment&quot;,
      &quot;parent&quot;: &quot;blog2&quot;
    }
}</code></pre><h3 id="嵌套对象-v-s-父子文档"><a href="#嵌套对象-v-s-父子文档" class="headerlink" title="嵌套对象 v.s. 父子文档"></a>嵌套对象 v.s. 父子文档</h3><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093640.png" alt="image-20200429173328674"></p>
<h3 id="相关阅读-1"><a href="#相关阅读-1" class="headerlink" title="相关阅读"></a>相关阅读</h3><blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-child-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-child-query.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-parent-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-has-parent-query.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/query-dsl-parent-id-query.html</a></p>
</blockquote>
<h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>一般在以下几种情况时，我们需要重建索引：</p>
<ol>
<li>索引的 Mappings 发生变更：字段类型更改、分词器及字段更新</li>
<li>索引的 Settings 发生变更：索引的主分片数发生改变</li>
<li>集群内/集群间需要做数据迁移</li>
</ol>
<p>ES 内置的关于重建索引的 API 两个：</p>
<ul>
<li>Update By Query：在现有索引上重建</li>
<li>Reindex：在其他索引上重新构建出当前索引</li>
</ul>
<h3 id="案例1：为索引增加子字段（Update-By-Query）"><a href="#案例1：为索引增加子字段（Update-By-Query）" class="headerlink" title="案例1：为索引增加子字段（Update By Query）"></a>案例1：为索引增加子字段（Update By Query）</h3><p>下面我们来描述一个给索引 mapping 中的字段增加一个子字段并使用 Update By Query 重建索引的过程。</p>
<ol>
<li><p>直接往一个索引在写入文档，使用 ES 的 Dynamic Mapping 自动创建索引</p>
<pre><code>DELETE blogs/

# 写入文档
PUT blogs/_doc/1
{
  &quot;content&quot;:&quot;Hadoop is cool&quot;,
  &quot;keyword&quot;:&quot;hadoop&quot;
}</code></pre></li>
<li><p>查看刚刚创建的索引，可以看到 ES  为这个索引创建了一个 Mapping，并自动设置content和 keyword 字段，类型都是 text，并且都为他们创建一个子字段keyword，类型为 keyword。</p>
<pre><code># 查看 Mapping
GET blogs/_mapping</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093641.png" alt="image-20200429175813394"></p>
</li>
<li><p>其实我们想修改 Mapping 中的 content 字段，为其增加一个子字段”english”，类型不变，设置分词器为”english”，使得我们更好地使用英文内容对该字段进行搜索。</p>
<pre><code># 修改 Mapping，增加子字段，使用英文分词器
PUT blogs/_mapping
{
  &quot;properties&quot; : {
    &quot;content&quot; : {
      &quot;type&quot; : &quot;text&quot;,
      &quot;fields&quot; : {
        &quot;english&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;analyzer&quot;:&quot;english&quot;
        }
      }
    }
  }
}</code></pre></li>
<li><p>写入新的文档并对新加的字段进行查询，是可以查出来数据的</p>
<pre><code># 写入文档
PUT blogs/_doc/2
{
  &quot;content&quot;:&quot;Elasticsearch rocks&quot;,
  &quot;keyword&quot;:&quot;elasticsearch&quot;
}
# 查询新写入文档
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content.english&quot;: &quot;Elasticsearch&quot;
    }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093642.png" alt="image-20200429180358045"></p>
</li>
<li><p>但是当我们对旧的文档对新加字段进行查询的时候，发现查询不到数据。</p>
<pre><code># 查询 Mapping 变更前写入的文档
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content.english&quot;: &quot;Hadoop&quot;
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093643.png" alt="image-20200429180541028"></p>
</li>
<li><p>使用 <code>_update_by_query</code> api 进行现有的索引重建后再查询新数据。即可查询出来了。</p>
<pre><code># Update所有文档
POST blogs/_update_by_query
{

}
# 查询之前写入的文档
POST blogs/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content.english&quot;: &quot;Hadoop&quot;
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093644.png" alt="image-20200429180708458"></p>
</li>
</ol>
<h3 id="案例2：更改-Mapping-中的字段的类型（ReIndex）"><a href="#案例2：更改-Mapping-中的字段的类型（ReIndex）" class="headerlink" title="案例2：更改 Mapping 中的字段的类型（ReIndex）"></a>案例2：更改 Mapping 中的字段的类型（ReIndex）</h3><p>ES 是不允许我们修改现有 mapping 中已经定义的字段的类型的，直接报错：</p>
<pre><code>PUT blogs/_mapping
{
        &quot;properties&quot; : {
        &quot;content&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {
            &quot;english&quot; : {
              &quot;type&quot; : &quot;text&quot;,
              &quot;analyzer&quot; : &quot;english&quot;
            }
          }
        },
        &quot;keyword&quot; : {
          &quot;type&quot; : &quot;keyword&quot;
        }
      }
}
</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093645.png" alt="image-20200429181124513"></p>
<p>那么如果我们确实要修改字段类型怎么办呢？只能创建新的索引，并且设置正确的字段类型，再通过 reindex api 将老索引的数据导入到新索引。下面我们来描述一个修改Mapping 中字段的场景：</p>
<ol>
<li><p>创建新索引并设置正确的字段类型</p>
<pre><code>DELETE blogs_fix

# 创建新的索引并且设定新的Mapping
PUT blogs_fix/
{
  &quot;mappings&quot;: {
        &quot;properties&quot; : {
        &quot;content&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {
            &quot;english&quot; : {
              &quot;type&quot; : &quot;text&quot;,
              &quot;analyzer&quot; : &quot;english&quot;
            }
          }
        },
        &quot;keyword&quot; : {
          &quot;type&quot; : &quot;keyword&quot;
        }
      }    
  }
}</code></pre></li>
<li><p>调用 ES 的 <code>_reindex</code> api 将老索引的数据重新导入到新索引</p>
<pre><code># Reindx API
POST  _reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;blogs&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;blogs_fix&quot;
  }
}</code></pre><p>从新索引查询 id 为1的文档</p>
<pre><code>GET  blogs_fix/_doc/1</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093646.png" alt="image-20200429181628754"></p>
<p>我们刚刚将一个 keyword 字段从 text 类型修改为 keyword 类型，通过 terms agg 进行测试，是没有问题的：</p>
<pre><code># 测试 Term Aggregation
POST blogs_fix/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;blog_keyword&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;keyword&quot;,
        &quot;size&quot;: 10
      }
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093647.png" alt="image-20200429181927451"></p>
</li>
</ol>
<h4 id="ReIndex-总结"><a href="#ReIndex-总结" class="headerlink" title="ReIndex 总结"></a>ReIndex 总结</h4><h6 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h6><ul>
<li>修改索引的主分片数</li>
<li>改变 Mapping 中的字段类型</li>
<li>集群内数据迁移/跨集群的数据迁移</li>
</ul>
<h6 id="2、数据冲突的解决方案"><a href="#2、数据冲突的解决方案" class="headerlink" title="2、数据冲突的解决方案"></a>2、数据冲突的解决方案</h6><p>另外当我们往新索引中进行 _reindex 的时候，有可能已经存在了一些数据。在默认情况下以及设置”dest.version_type=internal”的时候，ES 将会将强制覆盖所有已经存在的文档，然后版本号+1。</p>
<pre><code>//默认情况
POST _reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;twitter&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;new_twitter&quot;
  }
}
//设置 version_type 为 internal
POST _reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;twitter&quot;
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;new_twitter&quot;,
    &quot;version_type&quot;: &quot;internal&quot;
  }
}</code></pre><p>通过设置”dest.version_type=external”可以让 ES 在遇到已经存在的文档的时候比较两者的版本，当已存在于 dest 中的文档的版本低于 source 中版本的时候，就会更新dest 中的该文档；如果无冲突将直接索引文档。</p>
<p>另外我们可以通过设置”dest.op_type=create”来让 _reindex 仅仅创建目标 index 中缺失的文档。所有的已经存在的文档都会导致一个版本冲突。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093648.png" alt="image-20200429200157335"></p>
<p>默认情况下，以上版本冲突会使得 _reindex 操作中止。我们可以通过设置 _reindex 的直接属性 “conflicts=proceed” 让 _reindex 在遇到版本冲突的时候跳过当前这个文档，继续处理下一个文档，当 _reindex 完成之后会返回遇到版本冲突的数量。（注意，这个参数仅仅可以对版本冲突错误有效，其他错误还是会中止 _reindex 操作）</p>
<h6 id="3、筛选需要-reindex-的数据"><a href="#3、筛选需要-reindex-的数据" class="headerlink" title="3、筛选需要 _reindex 的数据"></a>3、筛选需要 _reindex 的数据</h6><p>有时，我们并不想对所有的文档进行迁移。我们可以通过在 source 属性中指定一个查询来筛选我们需要 _reindex 的数据。此外，对于 size、sort 等在查询动作中设定的参数都是可以设置的，具体参考官方文档。</p>
<pre><code>POST _reindex
{
  &quot;source&quot;: {
    &quot;index&quot;: &quot;twitter&quot;,
    &quot;query&quot;: {
      &quot;term&quot;: {
        &quot;user&quot;: &quot;kimchy&quot;
      }
    }
  },
  &quot;dest&quot;: {
    &quot;index&quot;: &quot;new_twitter&quot;
  }
}</code></pre><h6 id="4、跨集群-Reindex"><a href="#4、跨集群-Reindex" class="headerlink" title="4、跨集群 Reindex"></a>4、跨集群 Reindex</h6><p>ES 同时还支持跨集群的 reindex，我们先在本地（dest）中修改 elasticearch.yml 文件中的配置<code>reindex.remote.whitelist: &quot;otherhost:9200, another:9200”</code>开启白名单（对 source 的端口），然后设置 source 的 remote 属性进行远程连接配置，最后发起 _reindex 操作</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093649.png" alt="image-20200429201706072"></p>
<h6 id="5、异步-reiindex"><a href="#5、异步-reiindex" class="headerlink" title="5、异步 reiindex"></a>5、异步 reiindex</h6><p>同时 reindex 还支持异步操作。通过指定 url 参数<code>wait_for_completion=false</code>来实现：</p>
<pre><code>POST _reindex?wait_for_completion=false
{
... ...
}</code></pre><p>此时执行该请求将会得到一个 task id。可以通过 _task api 来查看任务状态：</p>
<pre><code>GET _tsak?detailed=true&amp;actions=*reindex
{

}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093650.png" alt="image-20200429202014925"></p>
<blockquote>
<p>使用 Reindex API 的注意点：</p>
<ol>
<li>在进行 reindex 操作的 source index 中，必须保证所有文档的 _source 字段是可用的。</li>
<li>reindex api 不会去尝试创建目标索引，也不会复制源索引的 settings 到目标索引。用户必须在进行 _reindex 之前手动设置目标索引的 mappings、shard  数量、replicas 等。</li>
<li>建议对 api 使用 alias，在 reindex 好之后可以直接切换 alias 指向的新 index 即可。</li>
</ol>
</blockquote>
<h3 id="相关阅读-2"><a href="#相关阅读-2" class="headerlink" title="相关阅读"></a>相关阅读</h3><blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/docs-reindex.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/docs-reindex.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/docs-update-by-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/docs-update-by-query.html</a></p>
</blockquote>
<h1 id="Ingest-Pipeline-amp-Painless-Script"><a href="#Ingest-Pipeline-amp-Painless-Script" class="headerlink" title="Ingest Pipeline &amp; Painless Script"></a>Ingest Pipeline &amp; Painless Script</h1><h3 id="Ingest-Node"><a href="#Ingest-Node" class="headerlink" title="Ingest Node"></a>Ingest Node</h3><p>Ingest Node 是在 Elasticsearch 5.0后，引入了一种新的节点。默认配置下，每个节点都是Ingest Node。</p>
<ol>
<li>可拦截 Index 或者 Bulk API 的请求，对数据进行预处理（如：为某个字段设置默认值、重命名某个字段的字段名、对字段值进行 Split 操作等），处理完成之后重新返回给 index 或者 Buik API</li>
<li>相对 Logstash 无需额外引入新的工具依赖，就可以进行数据预处理</li>
<li>支持设置 Painless 脚本，对数据进行更加复杂的加工</li>
</ol>
<p>例如以下 index 的请求中 tags 字段时候一个使用逗号分隔的文本，我们现在需要对其进行分隔之后再存入 ES，方便后期需要对 Tags 字段进行Aggregation 统计：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093651.png" alt="image-20200429205049625"></p>
<h4 id="1、Pipeline-amp-Processor"><a href="#1、Pipeline-amp-Processor" class="headerlink" title="1、Pipeline &amp; Processor"></a>1、Pipeline &amp; Processor</h4><p>Pipeline：管道会对通过的数据（文档）按照顺序进行加工。</p>
<p>Processor：Elasticsearch 对一些加工的行为进行了抽象包装，它提供了很多内置的 Processors。也支持通过插件的方式，实现自己的 Processor。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093652.png" alt="image-20200429205543898"></p>
<h4 id="2、Ingest-API"><a href="#2、Ingest-API" class="headerlink" title="2、Ingest API"></a>2、Ingest API</h4><p>参考下面的示例，ingest api 在 ES 中是一个定级 api，路径为_ingest。后面紧跟的就是 pipeline，即我们上面提到的概念。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093653.png" alt="image-20200429213050917"></p>
<h5 id="1）Ingest-pipeline-测试"><a href="#1）Ingest-pipeline-测试" class="headerlink" title="1）Ingest pipeline 测试"></a>1）Ingest pipeline 测试</h5><p>在 pipeline 后面定义的路径或者 restful 方法就是ES 实际提供的 ingest api。_simulate 是 ES 提供的一个可以对 ingest pipeline 进行测试的 api。参考以下示例：</p>
<ul>
<li><p>我们对该 api 的请求体对象中的 pipeline属性进行了定义，包括这个 pipeline 的描述和 pipeliine 中包含的 processors。</p>
<p>这里仅定义了两个 processors：第一个是”split” processor，它对所有文档的”tags”字段进行一个以”,”为分隔符的分隔操作，然后将分隔后得到的一个字符串数组覆盖到文档的 tags 属性中；第二个是”set” processor，为每一个文档增加一个字段，并设置默认值为0。</p>
</li>
<li><p>然后在 api 请求体中通过设置 docs 填充测试文档数据。可以看到这些文档数据都包含一个 tags 字段，都是以逗号分隔。且都增加了一个 view 字段，值为0。</p>
</li>
</ul>
<p>可以看到api 发出调用后返回的结果中，两个文档的 tags 字段都被分隔成了一个数组。</p>
<pre><code>//对 tags 字段进行逗号切割，并为所有文档增加一个字段默认值为0
POST _ingest/pipeline/_simulate
{
  &quot;pipeline&quot;: {
    &quot;description&quot;: &quot;to split blog tags&quot;,
    &quot;processors&quot;: [
      {
        &quot;split&quot;: {
          &quot;field&quot;: &quot;tags&quot;,
          &quot;separator&quot;: &quot;,&quot;
        }
      }, 
      {
        &quot;set&quot;:{
          &quot;field&quot;: &quot;views&quot;,
          &quot;value&quot;: 0
        }
      }
    ]
  },

  &quot;docs&quot;: [
    {
      &quot;_index&quot;:&quot;index&quot;,
      &quot;_id&quot;:&quot;id&quot;,
      &quot;_source&quot;:{
        &quot;title&quot;:&quot;Introducing big data......&quot;,
        &quot;tags&quot;:&quot;hadoop,elasticsearch,spark&quot;,
        &quot;content&quot;:&quot;You konw, for big data&quot;
      }
    },
    {
      &quot;_index&quot;:&quot;index&quot;,
      &quot;_id&quot;:&quot;idxx&quot;,
      &quot;_source&quot;:{
        &quot;title&quot;:&quot;Introducing cloud computering&quot;,
        &quot;tags&quot;:&quot;openstack,k8s&quot;,
        &quot;content&quot;:&quot;You konw, for cloud&quot;
      }
    }
  ]
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093654.png" alt="image-20200429211257800"></p>
<h5 id="2）新增一个-ingest-pipeline"><a href="#2）新增一个-ingest-pipeline" class="headerlink" title="2）新增一个 ingest pipeline"></a>2）新增一个 ingest pipeline</h5><p>在上面经过测试之后我们的 ingest pipeline 是没有问题的，此时我们就可以创建这个 pipeline 对象了。通过调用 PUT 方法并在 _ingest/pipeline/ 后面加上我们要创建的这个 pipeline 对象的 id进行创建。</p>
<p>然后可以通过 GET 方法使用同样的 URI 进行查询动作。</p>
<p>另外我们还能对创建之后的 pipeline 再次进行 _simulate 的测试动作，请求方法为 POST 方法，URI 则是上面创建和查询使用的 URI 拼接上子路径 _simulate，然后在请求体中直接设置测试文档到”docs”属性。而不用像前面的测试动作一样需要指定”pipeline”属性。</p>
<pre><code># 为ES添加一个 Pipeline
PUT _ingest/pipeline/blog_pipeline
{
  &quot;description&quot;: &quot;a blog pipeline&quot;,
  &quot;processors&quot;: [
      {
        &quot;split&quot;: {
          &quot;field&quot;: &quot;tags&quot;,
          &quot;separator&quot;: &quot;,&quot;
        }
      },
      {
        &quot;set&quot;:{
          &quot;field&quot;: &quot;views&quot;,
          &quot;value&quot;: 0
        }
      }
    ]
}
#查看Pipleline
GET _ingest/pipeline/blog_pipeline
#测试pipeline
POST _ingest/pipeline/blog_pipeline/_simulate
{
  &quot;docs&quot;: [
    {
      &quot;_source&quot;: {
        &quot;title&quot;: &quot;Introducing cloud computering&quot;,
        &quot;tags&quot;: &quot;openstack,k8s&quot;,
        &quot;content&quot;: &quot;You konw, for cloud&quot;
      }
    }
  ]
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093655.png" alt="image-20200429211636889"></p>
<h5 id="3）使用创建之后的-ingest-pipeline"><a href="#3）使用创建之后的-ingest-pipeline" class="headerlink" title="3）使用创建之后的 ingest pipeline"></a>3）使用创建之后的 ingest pipeline</h5><p>在创建了 ingest pipeline 之后我们就可以在对文档 index 的时候（通过 index或者 bulk api）使用这些 pipeline 了。</p>
<p>下面我们来看一些例子：</p>
<p>我们在第一个请求中没使用 ingest pipeline，tags 中的数据是原封不动地存储到文档中然后被索引；而在第二个请求中，我们<strong>在索引数据的 URI 后面使用了一个”piipeline=${pipeline_name}”的参数</strong>，指定了我们要对本次文档数据使用id 为”blog_pipeline”的 ingest pipeline 进行预处理，即我们前面创建的 pipeline。</p>
<p>两个索引文档的请求都执行之后，我们通过 _search api 查询索引后的两个文档。可以看到第一个文档的 tags 还是没有处理的；而第二个文档的 tags 字段则是被分隔成了一个字符串数组。</p>
<pre><code>#不使用pipeline更新数据
PUT tech_blogs/_doc/1
{
  &quot;title&quot;:&quot;Introducing big data......&quot;,
  &quot;tags&quot;:&quot;hadoop,elasticsearch,spark&quot;,
  &quot;content&quot;:&quot;You konw, for big data&quot;
}

#使用pipeline更新数据
PUT tech_blogs/_doc/2?pipeline=blog_pipeline
{
  &quot;title&quot;: &quot;Introducing cloud computering&quot;,
  &quot;tags&quot;: &quot;openstack,k8s&quot;,
  &quot;content&quot;: &quot;You konw, for cloud&quot;
}
#查看两条数据，一条被处理，一条未被处理
POST tech_blogs/_search
{}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093656.png" alt="image-20200429212336066"></p>
<p>除了上面的例子，我们还可以在前面提到的重构索引的 api <code>_update_by_query</code>中使用 ingest pipeline。但是如果基于上面的数据直接执行的话，会得到类型转换异常的错误，因为有一个文档的该字段已经被转成了数组类型，对应 java 中的 ArrayList，”split”操作需要的是一个字符串类型字段，而此时它已经不是一个 String，解决方法看下面。</p>
<pre><code>#update_by_query 会导致错误
POST tech_blogs/_update_by_query?pipeline=blog_pipeline
{
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093657.png" alt="image-20200429212605175"></p>
<p>此时我们可以通过设置 <code>_update_by_query</code>的 api 设置查询参数实现将我们更新过的数据进行过滤。可以看到我们前面设置的 pipeline 中其实还设置了一个给文档增加一个新字段 view 的操作。所以我们可以将查询条件设置为必须不存在一个 view字段的数据才进行 _update_by_query 操作。此时再对该字段指定我们前面设置的pipeline，就不会遇到已经被处理过的数据了，即可正常执行。</p>
<pre><code>#增加update_by_query的条件
POST tech_blogs/_update_by_query?pipeline=blog_pipeline
{
    &quot;query&quot;: {
        &quot;bool&quot;: {
            &quot;must_not&quot;: {
                &quot;exists&quot;: {
                    &quot;field&quot;: &quot;views&quot;
                }
            }
        }
    }
}
</code></pre><h4 id="3、一些内置Processors"><a href="#3、一些内置Processors" class="headerlink" title="3、一些内置Processors"></a>3、一些内置Processors</h4><ul>
<li><p>Split Processor (例:将给定字段值分成⼀一个数组)</p>
</li>
<li><p>Remove / Rename Processor (例:移除⼀个重命名字段)</p>
</li>
<li><p>Append (例:为商品增加⼀个新的标签)</p>
</li>
<li><p>Convert(例:将商品价格，从字符串转换成 float 类型)</p>
</li>
<li><p>Date / JSON(例:⽇期格式转换，字符串转 JSON 对象)</p>
</li>
<li><p>Date Index Name Processor (例:将通过该处理器的⽂档，分配到指定时间格式的索引中)</p>
</li>
<li><p>Fail Processor (⼀旦出现异常，该 Pipeline 指定的错误信息能返回给用户)</p>
</li>
<li><p>Foreach Process(数组字段，数组的每个元素都会使⽤到一个相同的处理器)</p>
</li>
<li><p>Grok Processor(⽇志的⽇期格式切割)</p>
</li>
<li><p>Gsub / Join / Split(字符串替换 / 数组转字符串/ 字符串转数组)</p>
</li>
<li><p>Lowercase / Upcase(⼤小写转换)</p>
</li>
</ul>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-processors.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-processors.html</a></p>
</blockquote>
<h4 id="4、Ingest-Node-v-s-Logstash"><a href="#4、Ingest-Node-v-s-Logstash" class="headerlink" title="4、Ingest Node v.s. Logstash"></a>4、Ingest Node v.s. Logstash</h4><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093658.png" alt="image-20200429213426597"></p>
<blockquote>
<p>我应该使用 logstash 还是 es ingest node：<a href="https://www.elastic.co/cn/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes" target="_blank" rel="noopener">https://www.elastic.co/cn/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes</a></p>
</blockquote>
<h3 id="Painless"><a href="#Painless" class="headerlink" title="Painless"></a>Painless</h3><p>自 Elasticsearch 5.x 后引入，专门为 Elasticsearch 设计，扩展了 Java 的语法。</p>
<p>6.0 开始，ES 只支持 Painless。Groovy、Javascript 和 Python 都不再支持。</p>
<p>Painless 支持所有 Java 的数据类型及 Java API 子集。具备以下特性：</p>
<ul>
<li>高性能 </li>
<li>安全</li>
<li>支持显示类型或者动态定义类型</li>
</ul>
<p>Painless 的用途：</p>
<ul>
<li>可以对文档字段进行加工处理：<ul>
<li>更新或者删除字段，处理数据聚合操作</li>
<li>Script Field：对返回的字段提前进行计算</li>
<li>Function Score：对文档的算分进行处理</li>
</ul>
</li>
<li>在 Ingest Pipeline 中执行脚本</li>
<li>在 Reindex API、Update By Query 时，对数据进行处理</li>
</ul>
<h4 id="1、在-Painless-脚本中访问字段"><a href="#1、在-Painless-脚本中访问字段" class="headerlink" title="1、在 Painless 脚本中访问字段"></a>1、在 Painless 脚本中访问字段</h4><p>在 Painless 脚本中访问字段根据当前使用脚本的上下文的不同对字段的访问语法也不同，具体参考下列表格：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093659.png" alt="image-20200429213955719"></p>
<p>可以看到在 Ingestion 中，ctx 引用的是文档的 _source 属性对象；在 Update 的时候，ctx 引用的就是文档对象；在 Search 和 Agg 的时候， 没有提供 ctx 的引用，提供了一个 doc 的引用，引用的是文档的 _source 属性对象。</p>
<h4 id="2、-在-Ingest-Pipeline-中的使用示例"><a href="#2、-在-Ingest-Pipeline-中的使用示例" class="headerlink" title="2、 在 Ingest Pipeline 中的使用示例"></a>2、 在 Ingest Pipeline 中的使用示例</h4><p>可以看到在下面的例子中，我们在之前的 ingest pipeline 中加入了一个新的 processor，这是一个”script” processor。它需要处理的字段是”source”。即直接访问文档的封装了所有字段的属性。处理逻辑是：如果文档（的 _source）中包含一个 content 字段，就将该字段的长度设置到一个”content_length”字段中，没有该字段就新增；如果不包含一个 content 字段，则直接设置 content_length 为0。</p>
<p>可以看到输出结果中增加了一个 content_length 字段，值为 content 的内容长度。</p>
<pre><code># 增加一个 Script Prcessor
POST _ingest/pipeline/_simulate
{
  &quot;pipeline&quot;: {
    &quot;description&quot;: &quot;to split blog tags&quot;,
    &quot;processors&quot;: [
      {
        &quot;split&quot;: {
          &quot;field&quot;: &quot;tags&quot;,
          &quot;separator&quot;: &quot;,&quot;
        }
      },
      {
        &quot;script&quot;: {
          &quot;source&quot;: &quot;&quot;&quot;
            if(ctx.containsKey(&quot;content&quot;)){
              ctx.content_length = ctx.content.length();
            }else{
              ctx.content_length=0;
            }
          &quot;&quot;&quot;
        }
      },
      {
        &quot;set&quot;:{
          &quot;field&quot;: &quot;views&quot;,
          &quot;value&quot;: 0
        }
      }
    ]
  },
  &quot;docs&quot;: [
    {
      &quot;_index&quot;:&quot;index&quot;,
      &quot;_id&quot;:&quot;id&quot;,
      &quot;_source&quot;:{
        &quot;title&quot;:&quot;Introducing big data......&quot;,
        &quot;tags&quot;:&quot;hadoop,elasticsearch,spark&quot;,
        &quot;content&quot;:&quot;You konw, for big data&quot;
      }
    },
    {
      &quot;_index&quot;:&quot;index&quot;,
      &quot;_id&quot;:&quot;idxx&quot;,
      &quot;_source&quot;:{
        &quot;title&quot;:&quot;Introducing cloud computering&quot;,
        &quot;tags&quot;:&quot;openstack,k8s&quot;,
        &quot;content&quot;:&quot;You konw, for cloud&quot;
      }
    }
  ]
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093700.png" alt="image-20200429214426689"></p>
<h4 id="3、在文档字段更新中使用示例"><a href="#3、在文档字段更新中使用示例" class="headerlink" title="3、在文档字段更新中使用示例"></a>3、在文档字段更新中使用示例</h4><p>我们先是初始化了一个浏览数是0的博客文档。然后在更新的时候使用了一个”script”类型的更新操作，在其子属性source 中指定了 painless 脚本的内容，并可以利用请求体中的 script 对象的子属性构建脚本执行的时候的参数上下文。</p>
<p>例如下面例子中我们给”script”设置了一个”params”属性对象，并给该对象设置了一个”new_views:100”的属性对。此时脚本在执行的时候会将”script”对象作为其上下文的一部分，在识别脚本中的”params.new_views”部分的时候就可以匹配到”scirpt”对象的”params.newviews”属性值100了。所以构成的更新语义就是将 id 为1的文档的 views 字段的值加上100。</p>
<pre><code>DELETE tech_blogs
# 输入一个博客文档，并设置其浏览数 view 为0
PUT tech_blogs/_doc/1
{
  &quot;title&quot;:&quot;Introducing big data......&quot;,
  &quot;tags&quot;:&quot;hadoop,elasticsearch,spark&quot;,
  &quot;content&quot;:&quot;You konw, for big data&quot;,
  &quot;views&quot;:0
}
# 将id 为1的博客文档的浏览数加上100
POST tech_blogs/_update/1
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;ctx._source.views += params.new_views&quot;,
    &quot;params&quot;: {
      &quot;new_views&quot;:100
    }
  }
}
# 查看views计数
POST tech_blogs/_search
{

}</code></pre><h4 id="4、在搜索的时候使用示例"><a href="#4、在搜索的时候使用示例" class="headerlink" title="4、在搜索的时候使用示例"></a>4、在搜索的时候使用示例</h4><p>参考下面的例子，我们在 _search api 中指定了一个 “script_fields” api，然后再后面定义了一个match_all 的”query” api。</p>
<ul>
<li>match_all query api 表示查询出所有文档数据</li>
<li>而 _search 会将 query 得到的文档数据输入到定义在它下面的”script_fields”对象中，该对象的子属性名”rnd_views”将表示当前”script_fields”的名称。而”rnd_views”属性对象中我们通过指定该对象的子属性”lang”为 palinless 标识它为一个 painless 脚本，并在 source 中填入了脚本内容，脚本逻辑为调用 Java 的 Random 函数随机生成一个值并加上每一个文档中的 views 字段的值。</li>
</ul>
<p>可以看到返回的结果中只包含了”script_fields”的结果，文档的字段都没有被返回。</p>
<pre><code>GET tech_blogs/_search
{
  &quot;script_fields&quot;: {
    &quot;rnd_views&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;&quot;&quot;
          java.util.Random rnd = new Random();
          doc[&#39;views&#39;].value+rnd.nextInt(1000);
        &quot;&quot;&quot;
      }
    }
  },
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093701.png" alt="image-20200429220656262"></p>
<h4 id="5、脚本缓存"><a href="#5、脚本缓存" class="headerlink" title="5、脚本缓存"></a>5、脚本缓存</h4><p>上面的在 api 中直接输入脚本的源字符串，在 api 执行的时候实时编译脚本，这种脚本叫做 inline script；此外还可以将脚本进行预编译之后缓存到 ES 中，之后可以直接通过预编译的脚本 id 直接对编译后的脚本对象进行调用，而这种脚本叫做 Stored Script。</p>
<p>脚本的预编译通过 _script api 实现，可以看到下面例子中先是对脚本进行了预编译并，然后直接通过脚本 id 调用预编译之后的脚本。</p>
<pre><code>#保存脚本在 Cluster State
POST _scripts/update_views
{
  &quot;script&quot;:{
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;ctx._source.views += params.new_views&quot;
  }
}
# 通过指定script 的 id直接取出编译后的脚本进行使用
POST tech_blogs/_update/1
{
  &quot;script&quot;: {
    &quot;id&quot;: &quot;update_views&quot;,
    &quot;params&quot;: {
      &quot;new_views&quot;:1000
    }
  }
}</code></pre><p>因为脚本编译的开销相较大，所以推荐使用预编译的脚本。在 ES 中，对于Inline Scripts 和 Stored Scripts 都会进行缓存，默认缓存数量是100个。可以通过以下参数进行设置。</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093702.png" alt="image-20200429221126585"></p>
<h3 id="相关阅读-3"><a href="#相关阅读-3" class="headerlink" title="相关阅读"></a>相关阅读</h3><blockquote>
<p><a href="https://www.elastic.co/cn/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes" target="_blank" rel="noopener">https://www.elastic.co/cn/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-apis.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-apis.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-processors.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-processors.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/7.1/painless-lang-spec.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/painless/7.1/painless-lang-spec.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/painless/7.1/painless-api-reference.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/painless/7.1/painless-api-reference.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-processors.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/ingest-processors.html</a></p>
<p><a href="https://www.elastic.co/cn/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes" target="_blank" rel="noopener">https://www.elastic.co/cn/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes</a></p>
</blockquote>
<h1 id="Elasticsearch-数据建模"><a href="#Elasticsearch-数据建模" class="headerlink" title="Elasticsearch 数据建模"></a>Elasticsearch 数据建模</h1><p>数据建模（Data modeling），是创建数据模型的过程。数据模型是对真实世界进行抽象描述的一种工具和方法，实现对现实世界的映射。</p>
<p>数据建模包含3个过程：</p>
<ol>
<li>概念模型</li>
<li>逻辑模型</li>
<li>数据模型（第三范式）：结合具体的数据库，在满足业务读写性能等需求的前提下，确定最终的定义。</li>
</ol>
<p>数据建模一般基于功能需求和性能需求两个角度进行考虑：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093703.png" alt="image-20200430080436915"></p>
<p>那么在 ES 中我们应该如何进行数据建模呢？ES 中数据建模主要分为两方面：一方面是对于索引、文档和对象关系的规划建模；另一方面是对于文档字段的建模。</p>
<h3 id="字段建模"><a href="#字段建模" class="headerlink" title="字段建模"></a>字段建模</h3><p>在对字段建模的过程，我们一般从以下4个方面进行分析：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093704.png" alt="image-20200430080744087"></p>
<h4 id="1、字段类型"><a href="#1、字段类型" class="headerlink" title="1、字段类型"></a>1、字段类型</h4><ul>
<li>Text &amp; Keyword<ul>
<li>Text：用于全文本字段，文本会被 Analyzer 分词。默认不支持聚合分析及排序，需要设置 fielddata 为 true。</li>
<li>keyword：用于 id，枚举及不需要分词的文本。例如电话号码、email 地址、手机号码、邮政编码、性别等。适用于字段需要被 Filter（精确匹配），Soring 和 Aggregation 的场景。</li>
<li>设置多字段类型：如果用户没有在 mappnig 中显式设置字符串字段的类型，ES 默认会将其设置为 text 类型并且设置一个 keyword 的子字段。在处理人类语言时，通过增加”英文”，”拼音”和”标准”分词器，提高搜索结构。</li>
</ul>
</li>
<li>结构化数据<ul>
<li>数值类型：尽量选择贴近的类型。例如可用用 byte，就不要用 long。</li>
<li>枚举类型：设置为 keyword。即便时数字，也应该设置成 keyword，获取更好的性能。</li>
<li>其他：日期、布尔、地理信息… …都需要将其设置为正确的字段类型。</li>
</ul>
</li>
</ul>
<h4 id="2、是否需要搜索"><a href="#2、是否需要搜索" class="headerlink" title="2、是否需要搜索"></a>2、是否需要搜索</h4><ul>
<li>如果不需要对该字段进行检索、排序和聚合分析：Enable 设置为 false。</li>
<li>如果仅仅是不需要检索：只将 index 设置为 false。</li>
<li>对需要检索的字段，可以通过如下配置：<ul>
<li>index_options：设置索引的粒度</li>
<li>norms：该字段用于在查询的时候进行查询的分值字段的，如果对这个字段的查询不需要计算分值，可以关闭这个选项，它也会占用一定的存储空间。</li>
<li>… …</li>
</ul>
</li>
</ul>
<h4 id="3、聚合及排序"><a href="#3、聚合及排序" class="headerlink" title="3、聚合及排序"></a>3、聚合及排序</h4><ul>
<li>如果不需要对该字段进行检索、排序和聚合分析：Enable 设置为 false。</li>
<li>如果仅仅是不需要排序或者聚合分析功能：Doc_values/fielddata 设置为 false。</li>
<li>更新频繁、聚合查询频繁的 keyword 类型的字段：推荐将 eager_global_ordinals 设置为 true。</li>
</ul>
<h4 id="4、额外的存储"><a href="#4、额外的存储" class="headerlink" title="4、额外的存储"></a>4、额外的存储</h4><p>文档的所有字段默认都是存储在 _source 字段下的，我们需要基于一些特定场景来判断是否需要将这些字段存储在 _source 之外。</p>
<ul>
<li><p>_source 字段是否必须：当文档中的内容相当大或者查询文档并不需要每次都返回所有字段的内容的时候，基于节约磁盘的角度，可以考虑 disable _source。当 disable _source 字段之后：</p>
<ul>
<li>将在查询的时候在文档的返回结果中无法看到 _source 字段</li>
<li>且无法做 reindex，无法做 update</li>
<li>Kibana 中无法做 discovery</li>
</ul>
<p>所以一般建议先考虑增加压缩比来节约磁盘。一般是一些指标型数据适合关闭 _source，参考下图中的官方描述：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093705.png" alt="image-20200430083724859"></p>
</li>
</ul>
<ul>
<li>是否需要专门存储当前字段数据，Store 设置成 true，可以对该字段的原始内容进行专门的存储。一般结合 _source 的 enable 设置为 false 使用。</li>
</ul>
<h4 id="5、一个字段建模实例"><a href="#5、一个字段建模实例" class="headerlink" title="5、一个字段建模实例"></a>5、一个字段建模实例</h4><ol>
<li><p>使用 ES 的默认 Dynamic Mapping 创建索引 Mapping。可以看到我们下面先是索引了一本书的信息，其包含以下字段信息：</p>
<ul>
<li>书名</li>
<li>简介</li>
<li>作者</li>
<li>发行日期</li>
<li>图书封面链接</li>
</ul>
<p>ES 会为我们默认创建一个索引。可以看到所有字段都设置成了 text 类型并且增加了一个keyword 类型的子字段。</p>
<pre><code># Index 一本书的信息
PUT books/_doc/1
{
  &quot;title&quot;:&quot;Mastering ElasticSearch 5.0&quot;,
  &quot;description&quot;:&quot;Master the searching, indexing, and aggregation features in ElasticSearch Improve users’ search experience with Elasticsearch’s functionalities and develop your own Elasticsearch plugins&quot;,
  &quot;author&quot;:&quot;Bharvi Dixit&quot;,
  &quot;public_date&quot;:&quot;2017&quot;,
  &quot;cover_url&quot;:&quot;https://images-na.ssl-images-amazon.com/images/I/51OeaMFxcML.jpg&quot;
}
#查询自动创建的Mapping
GET books/_mapping</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093706.png" alt="image-20200430085140227"></p>
</li>
<li><p>优化字段设定。 </p>
<ul>
<li>类型：我们知道，图书的作者、封面链接都是一个精确值，所以将它们都设置为 keyword；另外，将发行日期设置为日期格式；而简介时不需要一个 keyword 子字段的，它本身在99.99%的情况下都不会作为一个精确值被检索，所以无需再针对这个字段进行精确索引；而书名在一般情况下都会支持全文检索和精确检索两种情况，所以保持默认类型不用变化。</li>
<li>是否需要索引：对于封面链接，一般是不会有人基于该字段来检索图书，所以我们设置 index 为 false。</li>
</ul>
<pre><code>DELETE books

#优化字段类型
PUT books
{
      &quot;mappings&quot; : {
      &quot;properties&quot; : {
        &quot;author&quot; : {&quot;type&quot; : &quot;keyword&quot;},
        &quot;cover_url&quot; : {&quot;type&quot; : &quot;keyword&quot;,&quot;index&quot;: false},
        &quot;description&quot; : {&quot;type&quot; : &quot;text&quot;},
        &quot;public_date&quot; : {&quot;type&quot; : &quot;date&quot;},
        &quot;title&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {
            &quot;keyword&quot; : {
              &quot;type&quot; : &quot;keyword&quot;,
              &quot;ignore_above&quot; : 100
            }
          }
        }
      }
    }
}
#Cover URL index 设置成false，无法对该字段进行搜索，尝试对该字段进行搜索会报错。
POST books/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;cover_url&quot;: {
        &quot;value&quot;: &quot;https://images-na.ssl-images-amazon.com/images/I/51OeaMFxcML.jpg&quot;
      }
    }
  }
}

#Cover URL index 设置成false，依然支持聚合分析
POST books/_search
{
  &quot;aggs&quot;: {
    &quot;cover&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;cover_url&quot;,
        &quot;size&quot;: 10
      }
    }
  }
}</code></pre></li>
<li><p>需求变更。现在我们收到了新的需求变更，需要在图书文档中增加一个图书内容的字段，并要求能对图书的内容进行全文检索的同时支持高亮显示。</p>
<p>这个新需求会导致 _source 的内容过大。默认情况下对于文档的检索无论是 data node 返回数据给 coordinating node 还是 coordinating node 返回数据给用户都会携带着 _source 一起返回，这样每次查询无论用户是否真的需要获取全部的字段（或者数据量比较大的图书内容字段）信息都会导致大量数据的传输。</p>
<p>考虑到图书信息一般在导入之后就不再会有 update 操作，我们可以通过关闭 _source 字段，并将所有字段的 “store” 设置为 true 来解决问题。下面我们删除图书索引并重新设置 mapping，然后重新索引一个图书文档。</p>
<pre><code>DELETE books
#新增 Content字段。数据量很大。选择将Source 关闭
PUT books
{
      &quot;mappings&quot; : {
      &quot;_source&quot;: {&quot;enabled&quot;: false},
      &quot;properties&quot; : {
        &quot;author&quot; : {&quot;type&quot; : &quot;keyword&quot;,&quot;store&quot;: true},
        &quot;cover_url&quot; : {&quot;type&quot; : &quot;keyword&quot;,&quot;index&quot;: false,&quot;store&quot;: true},
        &quot;description&quot; : {&quot;type&quot; : &quot;text&quot;,&quot;store&quot;: true},
         &quot;content&quot; : {&quot;type&quot; : &quot;text&quot;,&quot;store&quot;: true},
        &quot;public_date&quot; : {&quot;type&quot; : &quot;date&quot;,&quot;store&quot;: true},
        &quot;title&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {
            &quot;keyword&quot; : {
              &quot;type&quot; : &quot;keyword&quot;,
              &quot;ignore_above&quot; : 100
            }
          },
          &quot;store&quot;: true
        }
      }
    }
}

# Index 一本书的信息,包含Content
PUT books/_doc/1
{
  &quot;title&quot;:&quot;Mastering ElasticSearch 5.0&quot;,
  &quot;description&quot;:&quot;Master the searching, indexing, and aggregation features in ElasticSearch Improve users’ search experience with Elasticsearch’s functionalities and develop your own Elasticsearch plugins&quot;,
  &quot;content&quot;:&quot;The content of the book......Indexing data, aggregation, searching.    something else. something in the way............&quot;,
  &quot;author&quot;:&quot;Bharvi Dixit&quot;,
  &quot;public_date&quot;:&quot;2017&quot;,
  &quot;cover_url&quot;:&quot;https://images-na.ssl-images-amazon.com/images/I/51OeaMFxcML.jpg&quot;
}</code></pre><p>此时尝试查询的时候，_source 字段关闭了，ES 默认是不会返回文档额外存储的字段的。</p>
<pre><code>#查询结果中，Source不包含数据
POST books/_search
{}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093707.png" alt="image-20200430090941895"></p>
<p>我们需要指定 API 中具体需要操作或者查询的字段</p>
<ul>
<li>下面我们通过在 _search API 的 “stored_fields”的动作对象，这个对象会抓取经过查询出来的文档数据的具体字段值然后封装到一个”fields”对象中，这个”fields”对象会作为返回信息的文档对象的一个属性值返回，这样我们就能看到一个文档中我们指定的具体字段信息了。</li>
<li>另外我们还通过在 _search API 的 “highlight” 动作对象，该对象和”stored_fields”对象的逻辑差不多，只不过它在从文档的（用户）指定字段中把字段数据抓取出来之后经过高亮标签拼接再封装到一个”highlight”对象，然后设置到返回信息的文档对象的”highlight”属性中。</li>
</ul>
<pre><code>#搜索，通过store 字段显示数据，同时高亮显示 conent的内容
POST books/_search
{
  &quot;stored_fields&quot;: [&quot;title&quot;,&quot;author&quot;,&quot;public_date&quot;],
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content&quot;: &quot;searching&quot;
    }
  },
  &quot;highlight&quot;: {
    &quot;fields&quot;: {
      &quot;content&quot;:{}
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093708.png" alt="image-20200430091119890"></p>
</li>
</ol>
<h4 id="6、Mapping-字段的相关设置"><a href="#6、Mapping-字段的相关设置" class="headerlink" title="6、Mapping 字段的相关设置"></a>6、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html" target="_blank" rel="noopener">Mapping 字段的相关设置</a></h4><ul>
<li>Enabled – 设置成 false，仅做存储，不支持搜索和聚合分析 (数据保存在 _source 中)</li>
<li>Index – 是否构倒排索引。设置成 false，⽆法被搜索，但还是支持 aggregation，并出现在 _source中</li>
<li>Norms – 如果字段仅用做过滤和聚合分析，可以关闭，节约存储</li>
<li>Doc_values – 是否启⽤用 doc_values，用于排序和聚合分析</li>
<li>Field_data – 如果要对 text 类型启用排序和聚合分析， fielddata 需要设置成true</li>
<li>Store – 默认不存储，数据默认存储在 _source。</li>
<li>Coerce – 默认开启，是否开启数据类型的自动转换(例如，字符串转数字)</li>
<li>Multifields 多字段特性</li>
<li>Dynamic – true / false / strict 控制 Mapping 的⾃动更新</li>
</ul>
<h4 id="7、数据建模中一些相关的-API"><a href="#7、数据建模中一些相关的-API" class="headerlink" title="7、数据建模中一些相关的 API"></a>7、数据建模中一些相关的 API</h4><ul>
<li>Index Template &amp; Dynamic Template：根据索引的名字匹配不同的 Mapping 和 Settings。可以在一个 Mapping 上动态的设定字段类型</li>
<li>Index Alias：无需停机，无需修改程序，修改 alias 之后立即生效，即可使用该 alias（可进行零停机 reindex 等动作）</li>
<li>Update By Query &amp; Reindex</li>
</ul>
<h4 id="8、相关阅读"><a href="#8、相关阅读" class="headerlink" title="8、相关阅读"></a>8、相关阅读</h4><blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html</a></p>
</blockquote>
<h3 id="文档及关系建模及一些数据建模最佳实践"><a href="#文档及关系建模及一些数据建模最佳实践" class="headerlink" title="文档及关系建模及一些数据建模最佳实践"></a>文档及关系建模及一些数据建模最佳实践</h3><h4 id="建模建议-一-：如何处理关联关系"><a href="#建模建议-一-：如何处理关联关系" class="headerlink" title="建模建议(一)：如何处理关联关系"></a>建模建议(一)：如何处理关联关系</h4><p>下图就是我们在选择索引中的文档关系的一个优先考虑流程：</p>
<p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093709.png" alt="image-20200430095305105"></p>
<blockquote>
<p>需要注意的是：在 Kibana 中目前暂时没有对 nested 类型和 parent/child 类型提供一个很好的支持。在未来有可能会支持。如果需要使用 Kibana 进行数据分析，在数据建模时仍需对嵌套和父子关系类型作出取舍。</p>
</blockquote>
<h4 id="建模建议-二-：避免过多字段"><a href="#建模建议-二-：避免过多字段" class="headerlink" title="建模建议(二)：避免过多字段"></a>建模建议(二)：避免过多字段</h4><p>一个文档中，最好避免大量的字段：</p>
<ul>
<li>过多的字段不容易维护</li>
<li>Mapping 信息保存在 Cluster State 中，数据量过大，对集群性能会有影响（Cluster State 信息需要和所有的节点同步）</li>
<li>后期再删除或者修改字段需求 reindex</li>
</ul>
<p>ES 中默认最大字段数是1000，可以通过设置<code>index.mapping.total)fields.limit</code>限定最大字段数。</p>
<p><strong>可能导致文档中有成百上千的字段的原因：</strong></p>
<p>可能是因为启用了 Dynamic Mapping，用户在对其数据结构不是很准确的了解和控制的情况下会导致一些为止的新字段的写入。所以在生产环境中我们尽量不要使用 Dynamic Mapping。通过 Mapping 中的”_doc.dynamic”属性控制：</p>
<ul>
<li>true：未知字段会被自动加入以及索引</li>
<li>false：新字段不会被索引，但是会保存到 _source</li>
<li>strict：索引未知字段会失败，直接报错</li>
</ul>
<h5 id="示例：Cookie-Service-的数据"><a href="#示例：Cookie-Service-的数据" class="headerlink" title="示例：Cookie Service 的数据"></a>示例：Cookie Service 的数据</h5><p>我们现在有一个保存 Cookie 的服务，我们打算将 cookie 数据索引到 ES 的一个 cookie_service 中，并在一开始使用了 dynamic mapping，直接索引数据。</p>
<p>可以看到在下面的例子中，我们分别保存了两个 cookies，而两个 cookie 中的含有的键值对是不一样的，主要是 cookie 的键，<strong>因为 cookie 是一个可以由用户自定义的一个键值对，所以cookie 对象中的属性字段输入到 ES 可能就会有成千上百以上了</strong>！</p>
<pre><code>##索引数据，dynamic mapping 会不断加入新增字段
PUT cookie_service/_doc/1
{
 &quot;url&quot;:&quot;www.google.com&quot;,
 &quot;cookies&quot;:{
   &quot;username&quot;:&quot;tom&quot;,
   &quot;age&quot;:32
 }
}

PUT cookie_service/_doc/2
{
 &quot;url&quot;:&quot;www.amazon.com&quot;,
 &quot;cookies&quot;:{
   &quot;login&quot;:&quot;2019-01-01&quot;,
   &quot;email&quot;:&quot;xyz@abc.com&quot;
 }
}</code></pre><p>此时，我们可以使用 nested Object 来解决这个问题。看下面的例子，我们删除了原本的 cookie_service 索引，并进行显示 mapping 设置。我们重新定义了索引中文档的”cookies”字段为一个”nested”类型的字段，这个对象有4个属性：</p>
<ul>
<li>“name”：存储的就是一个 cookie 键</li>
<li>根据cookie 值的不同类型存储到不同的value字段：<ul>
<li>“dataValue”：date 类型</li>
<li>“keywordValue”：keyword 类型</li>
<li>“intValue”：integer 类型</li>
</ul>
</li>
</ul>
<p><strong>经过这样的数据字段抽象定义和约定</strong>，我们在写入以上的 cookies 对象的时候，就可以通过对一个对象只支持一组 “key-value” 属性的cookies对象数组来存储到一个URL链接对象中，而不是像一开始那样设置一个 cookies 对象然后设置不同的属性名存储到 URL 链接对象中。</p>
<p>在查询的时候，也需要通过 nested 查询来根据指定的 cookie 信息进行检索。</p>
<p>这样即可起到控制cookies 字段数量但是又支持 cookies 属性自定义的作用。</p>
<pre><code>DELETE cookie_service
#使用 Nested 对象，增加key/value
PUT cookie_service
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;cookies&quot;: {
        &quot;type&quot;: &quot;nested&quot;,
        &quot;properties&quot;: {
          &quot;name&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          },
          &quot;dateValue&quot;: {
            &quot;type&quot;: &quot;date&quot;
          },
          &quot;keywordValue&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          },
          &quot;IntValue&quot;: {
            &quot;type&quot;: &quot;integer&quot;
          }
        }
      },
      &quot;url&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;fields&quot;: {
          &quot;keyword&quot;: {
            &quot;type&quot;: &quot;keyword&quot;,
            &quot;ignore_above&quot;: 256
          }
        }
      }
    }
  }
}
##写入数据，使用key和合适类型的value字段
PUT cookie_service/_doc/1
{
 &quot;url&quot;:&quot;www.google.com&quot;,
 &quot;cookies&quot;:[
    {
      &quot;name&quot;:&quot;username&quot;,
      &quot;keywordValue&quot;:&quot;tom&quot;
    },
    {
      &quot;name&quot;:&quot;age&quot;,
      &quot;intValue&quot;:32

    }
  ]
}
PUT cookie_service/_doc/2
{
 &quot;url&quot;:&quot;www.amazon.com&quot;,
 &quot;cookies&quot;:[
    {
      &quot;name&quot;:&quot;login&quot;,
      &quot;dateValue&quot;:&quot;2019-01-01&quot;
    },
    {
      &quot;name&quot;:&quot;email&quot;,
      &quot;IntValue&quot;:32

    }
 ]
}
# Nested 查询，通过bool查询进行过滤
POST cookie_service/_search
{
  &quot;query&quot;: {
    &quot;nested&quot;: {
      &quot;path&quot;: &quot;cookies&quot;,
      &quot;query&quot;: {
        &quot;bool&quot;: {
          &quot;filter&quot;: [
            {
              &quot;term&quot;: {
                &quot;cookies.name&quot;: &quot;age&quot;
              }
            },
            {
              &quot;range&quot;:{
                &quot;cookies.intValue&quot;:{
                  &quot;gte&quot;:30
                }
              }
            }
          ]
        }
      }
    }
  }
}
</code></pre><blockquote>
<p>但是虽然通过 Nested 对象保存这种 key/value 数据可以减少字段数量，解决了 Cluster State 中保存过多 Meta 信息的问题，但是同时也导致了查询语句复杂度增加；另外 nested 对象不利于在 Kibana 中实现可视化分析。</p>
</blockquote>
<h4 id="建模建议-三-：避免正则查询"><a href="#建模建议-三-：避免正则查询" class="headerlink" title="建模建议(三)：避免正则查询"></a>建模建议(三)：避免正则查询</h4><p>我们应该尽量避免在 ES 中使用正则、通配符查询，特别是将通配符放在开头，会导致性能的灾难。前面也提到 ES 提供了一个基于前缀的 terms 查询，但是性能不够好。</p>
<p>下面我们来分析一个案例提供一些对于”匹配”查询的一些优化思路。</p>
<h5 id="示例：模糊查询版本信息"><a href="#示例：模糊查询版本信息" class="headerlink" title="示例：模糊查询版本信息"></a>示例：模糊查询版本信息</h5><p>我们拥有一个 softwares 的一个索引，里面索引了一些软件的信息。其中的一个 version 字段包含了软件的版本信息，以 ES 为例，可能包含一个值为”7.1.0”的ES文档。 现在我们需要该字段支持模糊查询，例如：搜索所有是 bug fix 版本的软件并返回每个主版本号所关联的文档？</p>
<pre><code>PUT softwares/_doc/1
{
  &quot;software_version&quot;:&quot;7.1.0&quot;
}
GET softwares/_mapping</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093710.png" alt="image-20200430104356697"></p>
<p>解决方案可以将 version 经过各部分的拆分之后，从字符串类型转为对象类型，可以看到我们为 version 属性设置了4个属性：</p>
<ul>
<li>display_name：keyword 类型，维护原始的版本字符串信息</li>
<li>hot_fix：byte 类型，将版本信息拆分之后截取出来的 hot fix 版本号</li>
<li>marjor：byte 类型，将版本信息拆分之后截取出来的 major 版本号</li>
<li>minor：byte 类型，将版本信息拆分之后截取出来的 minor 版本号</li>
</ul>
<p>这样，原本的”7.1.0”我们就拆成了”hot_fix=7;marjor=1;minor=0”，在检索的时候根据具体子版本号使用 bool 查询即可，大大提升性能：</p>
<pre><code>DELETE softwares
# 优化,使用inner object
PUT softwares/
{
    &quot;properties&quot;: {
      &quot;version&quot;: {
        &quot;properties&quot;: {
          &quot;display_name&quot;: {
            &quot;type&quot;: &quot;keyword&quot;
          },
          &quot;hot_fix&quot;: {
            &quot;type&quot;: &quot;byte&quot;
          },
          &quot;marjor&quot;: {
            &quot;type&quot;: &quot;byte&quot;
          },
          &quot;minor&quot;: {
            &quot;type&quot;: &quot;byte&quot;
          }
        }
      }
    }
  }
}
#通过 Inner Object 写入多个文档
PUT softwares/_doc/1
{
  &quot;version&quot;:{
  &quot;display_name&quot;:&quot;7.1.0&quot;,
  &quot;marjor&quot;:7,
  &quot;minor&quot;:1,
  &quot;hot_fix&quot;:0  
  }

}

PUT softwares/_doc/2
{
  &quot;version&quot;:{
  &quot;display_name&quot;:&quot;7.2.0&quot;,
  &quot;marjor&quot;:7,
  &quot;minor&quot;:2,
  &quot;hot_fix&quot;:0  
  }
}

PUT softwares/_doc/3
{
  &quot;version&quot;:{
  &quot;display_name&quot;:&quot;7.2.1&quot;,
  &quot;marjor&quot;:7,
  &quot;minor&quot;:2,
  &quot;hot_fix&quot;:1  
  }
}
# 通过 bool 查询，
POST softwares/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;match&quot;:{
            &quot;version.marjor&quot;:7
          }
        },
        {
          &quot;match&quot;:{
            &quot;version.minor&quot;:2
          }
        }

      ]
    }
  }
}</code></pre><h4 id="建模建议-四-：避免空值引起的聚合不准"><a href="#建模建议-四-：避免空值引起的聚合不准" class="headerlink" title="建模建议(四)：避免空值引起的聚合不准"></a>建模建议(四)：避免空值引起的聚合不准</h4><p>请看下面示例，我们分别一个ratings 索引中创建了两个文档，它们都只有一个字段”rating”，文档1的值为5，文档2的值为 null。</p>
<p>然后我们进行了一次对”rating”的 avg metric agg，发现得到的 rating 平均值是5，因为 ES 在进行字段 Metric计算的时候，是会过滤空值的，但是对于用户来说，一个文档在这个字段的空值其实指的应该是该文档语义下该字段的默认值，比如这里的 rating 字段，如果是空我们认为它是排名第一的，在这种语义下，下面的 Metric 结果就是错误的。</p>
<pre><code>PUT ratings/_doc/1
{
 &quot;rating&quot;:5
}
PUT ratings/_doc/2
{
 &quot;rating&quot;:null
}
POST ratings/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;avg&quot;: {
      &quot;avg&quot;: {
        &quot;field&quot;: &quot;rating&quot;
      }
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093711.png" alt="image-20200430105104466"></p>
<p>基于上面的问题，我们可以通过 <code>mapping.properties.null_value</code>属性来处理空值，这个属性的值就指定了其所属字段的默认值。下面的例子中我们设置了 rating 的字段的默认值是1，这样我们重新索引文档后再进行 metric 操作就能得到一个想要的值了。</p>
<pre><code># Not Null 解决聚合的问题
DELETE ratings
PUT ratings
{
  &quot;mappings&quot;: {
      &quot;properties&quot;: {
        &quot;rating&quot;: {
          &quot;type&quot;: &quot;float&quot;,
          &quot;null_value&quot;: 1.0
        }
      }
    }
}
# 重新索引文档
PUT ratings/_doc/1
{
 &quot;rating&quot;:5
}
PUT ratings/_doc/2
{
 &quot;rating&quot;:null
}
POST ratings/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;rating&quot;: {
        &quot;value&quot;: 1
      }
    }
  }
}
POST ratings/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;avg&quot;: {
      &quot;avg&quot;: {
        &quot;field&quot;: &quot;rating&quot;
      }
    }
  }
}</code></pre><p><img src="https://gitee.com/honphan/blogs-img/raw/master/blogs-img/20201220093712.png" alt="image-20200430105634440"></p>
<h4 id="建模建议-五-：为索引的-Mapping-加入-Meta-信息"><a href="#建模建议-五-：为索引的-Mapping-加入-Meta-信息" class="headerlink" title="建模建议(五)：为索引的 Mapping 加入 Meta 信息"></a>建模建议(五)：为索引的 Mapping 加入 Meta 信息</h4><p>Mappings 设置非常重要，需要从两个维度进行考虑：</p>
<ul>
<li>功能：搜索、聚合、排序</li>
<li>性能：存储的开销、内存的开销、搜索的开销</li>
</ul>
<p>同时 Mappings 的设置也是一个迭代的过程</p>
<ul>
<li><p>加入新的字段很容易（必要时需要 update_by_query）</p>
</li>
<li><p>更新删除字段不允许（需要 reindex 到一个新的索引）</p>
</li>
<li><p>最好能对 Mappings 加入 Meta 信息，更好的进行版本控制</p>
<p>参考下面例子，一开始在 _mapping 中设置了一个 _meta 属性，并在这个属性中再增加一个子属性 software_version_mapping 表示当前 mapping 的版本号，在之后的 mapping 更新中要手动的维护这个版本号：</p>
<pre><code># 在Mapping中加入元信息，便于管理
PUT softwares/
{
  &quot;mappings&quot;: {
    &quot;_meta&quot;: {
      &quot;software_version_mapping&quot;: &quot;1.0&quot;
    }
  }
}
PUT softwares/_mapping
{
  &quot;_meta&quot;: {
      &quot;software_version_mapping&quot;: &quot;2.0&quot;
  },
  &quot;properties&quot;: {
    &quot;new_file&quot;: {
      &quot;type&quot;: &quot;keyword&quot;
    }
  }
}</code></pre></li>
<li><p>可以考虑将 Mapping 文件上传 git 进行管理</p>
</li>
</ul>
<h3 id="相关阅读-4"><a href="#相关阅读-4" class="headerlink" title="相关阅读"></a>相关阅读</h3><blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/general-recommendations.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/general-recommendations.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/tune-for-disk-usage.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/tune-for-disk-usage.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/tune-for-search-speed.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/tune-for-search-speed.html</a></p>
</blockquote>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《008_数据建模》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/05/04/elasticsearch/008-shu-ju-jian-mo/" property="cc:attributionName"
               rel="cc:attributionURL">
                阿钟
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '466e387c08bce10f3f28',
        clientSecret: '5b2bf16f8a42bd72eef32e50187c7f2ccb105a1d',
        repo: 'azhong.github.io',
        owner: 'JohnZhongg',
        admin: "JohnZhongg",
        id: '2020/05/04/elasticsearch/008-shu-ju-jian-mo/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/05/04/elasticsearch/007-shen-ru-ju-he/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="007_深入聚合">
                        
                        <span class="card-title">007_深入聚合</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ES学习
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ES学习/" class="post-category" target="_blank">
                                    ES学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES学习/" target="_blank">
                        <span class="chip bg-color">ES学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/04/elasticsearch/006-fen-bu-shi-te-xing-ji-fen-bu-shi-sou-suo-de-ji-zhi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="006_分布式特性及分布式搜索的机制">
                        
                        <span class="card-title">006_分布式特性及分布式搜索的机制</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ES学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-05-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ES学习/" class="post-category" target="_blank">
                                    ES学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ES学习/" target="_blank">
                        <span class="chip bg-color">ES学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 阿钟的博客<br />'
            + '作者: 阿钟<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2020- Azhong. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">624.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/https://github.com/JohnZhongg" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:707845008@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/change-94-17" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=707845008&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


<!-- 


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 12, 20, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>