<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="mysql学习笔记：高可用, 技术博客 钟鸿鹏 honphan 阿钟">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="MySQL是怎么保证主备一致的毫不夸张地说，MySQL 能够成为现下最流行的开源数据库，binlog 功不可没。在最开始，MySQL 是以容易学习和方便的高可用架构，被开发人员青睐的。而它的几乎所有的高可用架构，都直接依赖于 binlog。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>mysql学习笔记：高可用 | 阿钟的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">阿钟的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">阿钟的博客</div>
        <div class="logo-desc">
            
            keep going...
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JohnZhongg" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JohnZhongg" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        mysql学习笔记：高可用
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/mysql/" target="_blank">
                            <span class="chip bg-color">mysql</span>
                        </a>
                        
                        <a href="/tags/高可用/" target="_blank">
                            <span class="chip bg-color">高可用</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/mysql/" class="post-category" target="_blank">
                            mysql
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-16
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    阿钟
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    30.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    109 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="MySQL是怎么保证主备一致的"><a href="#MySQL是怎么保证主备一致的" class="headerlink" title="MySQL是怎么保证主备一致的"></a>MySQL是怎么保证主备一致的</h1><p>毫不夸张地说，MySQL 能够成为现下最流行的开源数据库，binlog 功不可没。在最开始，MySQL 是以容易学习和方便的高可用架构，被开发人员青睐的。而它的几乎所有的高可用架构，都直接依赖于 binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是从最基本的一主一备演化过来的。</p>
<h2 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134822.png" alt="MySQL主备切换流程"></p>
<p>在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。</p>
<p>在状态 1 中，虽然节点 B 没有被直接访问，但是依然建议你把节点 B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用 readonly 状态，来判断节点的角色。</li>
</ol>
<p>把备库设置成只读了，还怎么跟主库保持同步更新呢？这个问题不用担心。<strong>因为 readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限</strong>。</p>
<h2 id="主备同步"><a href="#主备同步" class="headerlink" title="主备同步"></a>主备同步</h2><p>接下来，再看看节点 A 到 B 这条线的内部流程是什么样的。下图就是一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134829.png" alt="主备流程图"></p>
<p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。</p>
<p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p> 这里需要说明，后来由于多线程复制方案的引入，sql_thread 演化成为了多个线程，跟这里要介绍的原理没有直接关系，暂且不展开。</p>
</blockquote>
<h2 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h2><p>分析完了这个长连接的逻辑，再来看一个问题：binlog 里面到底是什么内容，为什么备库拿过去可以直接执行。binlog 有三种格式：</p>
<ol>
<li>statement</li>
<li>row</li>
<li>mixed</li>
</ol>
<p>建表如下：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `a` (`a`),
  KEY `t_modified`(`t_modified`)
) ENGINE=InnoDB;

insert into t values(1,1,'2018-11-13');
insert into t values(2,2,'2018-11-12');
insert into t values(3,3,'2018-11-11');
insert into t values(4,4,'2018-11-10');
insert into t values(5,5,'2018-11-09');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要在表中删除一行数据的话，来看看这个 <code>delete</code> 语句的 binlog 是怎么记录的。</p>
<blockquote>
<p> 注意，下面这个语句包含注释，如果你用 MySQL 客户端来做这个实验的话，要记得加 <code>-c</code> 参数，否则客户端会自动去掉注释。</p>
</blockquote>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> delete from t /*comment*/  where a>=4 and t_modified<='2018-11-10' limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>当 <code>binlog_format=statement</code> 时，binlog 里面记录的就是 SQL 语句的原文。可以用以下命令看 binlog 中的内容。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> show binlog events in 'master.000001';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134837.png" alt="statement 格式 binlog 示例"></p>
<ol>
<li>第一行 <code>SET @@SESSION.GTID_NEXT=&#39;ANONYMOUS’</code>在主备切换的时候用到；</li>
<li>第二行是一个 <code>BEGIN</code>，跟第四行的 <code>commit</code> 对应，表示中间是一个事务；</li>
<li>第三行就是真实执行的语句了。可以看到，在真实执行的 <code>delete</code> 命令之前，还有一个<code>use ‘test’</code>命令。这条命令不是我们主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。<code>use &#39;test’</code>命令之后的 <code>delete</code> 语句，就是我们输入的 SQL 原文了。可以看到，binlog“忠实”地记录了 SQL 命令，甚至连注释也一并记录了。</li>
<li>最后一行是一个 <code>COMMIT</code>。你可以看到里面写着 <code>xid=61</code>。</li>
</ol>
<h4 id="和-row-格式的区别"><a href="#和-row-格式的区别" class="headerlink" title="和 row 格式的区别"></a>和 row 格式的区别</h4><p>为了说明 statement 和 row 格式的区别，我们来看一下这条 delete 命令的执行效果图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134841.png" alt="delete 执行 warnings"></p>
<p>可以看到，运行这条 <code>delete</code> 命令产生了一个 warning，原因是当前 binlog 设置的是 statement 格式，并且语句中有 limit，所以这个命令可能是 unsafe 的。为什么这么说呢？这是因为 delete 带 limit，很可能会出现主备数据不一致的情况。比如上面这个例子：</p>
<ol>
<li>如果 <code>delete</code> 语句使用的是索引 <code>a</code>，那么会根据索引 <code>a</code> 找到第一个满足条件的行，也就是说删除的是 a=4 这一行；</li>
<li>但如果使用的是索引 <code>t_modified</code>，那么删除的就是 t_modified=’2018-11-09’也就是 a=5 这一行。</li>
</ol>
<p>由于 <code>statement</code> 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 <code>a</code>；而在备库执行这条 SQL 语句的时候，却使用了索引 <code>t_modified</code>。因此，MySQL 认为这样写是有风险的。</p>
<h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><p>那么，如果把 binlog 的格式改为 <code>binlog_format=‘row’</code>， 是不是就没有这个问题了呢？我们先来看看这时候 binog 中的内容吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134843.png" alt="row 格式 binlog 示例"></p>
<p>可以看到，与 statement 格式的 binlog 相比，前后的 <code>BEGIN</code> 和 <code>COMMIT</code> 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p>
<ol>
<li><code>Table_map event</code>，用于说明接下来要操作的表是 test 库的表 t;</li>
<li><code>Delete_rows event</code>，用于定义删除的行为。</li>
</ol>
<p>其实，通过上图是看不到 row 格式的详细信息的，还需要借助 mysqlbinlog 工具，用下面这个命令解析和查看 binlog 中的内容。因为上图中的信息显示，这个事务的 binlog 是从 8900 这个位置开始的，所以可以用 <code>start-position</code> 参数来指定从这个位置的日志开始解析。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysqlbinlog  -vv data/master.000001 --start-position=8900;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134848.png" alt="row 格式 binlog 示例的详细信息"></p>
<p>从这个图中，我们可以看到以下几个信息：</p>
<ol>
<li>server id 1，表示这个事务是在 server_id=1 的这个库上执行的。</li>
<li>每个 event 都有 CRC32 的值，这是因为把参数 <code>binlog_checksum</code> 设置成了 CRC32。</li>
<li><code>Table_map event</code> 跟在前面的图中看到的相同，显示了接下来要打开的表，map 到数字 226。现在我们这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 <code>Table_map event</code>、都会 map 到一个单独的数字，用于区分对不同表的操作。</li>
<li>我们在 mysqlbinlog 的命令中，使用了 <code>-vv</code> 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。</li>
<li><code>binlog_row_image</code> 的默认配置是 <code>FULL</code>，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果把 <code>binlog_row_image</code> 设置为 <code>MINIMAL</code>，则只会记录必要的信息，在这个例子里，就是只会记录 id=4 这个信息。</li>
<li>最后的 <code>Xid event</code>，用于表示事务被正确地提交了。</li>
</ol>
<p>你可以看到，当 <code>binlog_format</code> 使用 row 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id=4 的行，不会有主备删除不同行的问题。</p>
<h3 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h3><p>基于上面的信息来讨论一个问题：为什么会有 mixed 这种 binlog 格式的存在场景？推论过程是这样的：</p>
<ul>
<li>因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</li>
<li>但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li>
<li>所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li>
</ul>
<p>也就是说，mixed 格式可以利用 statment 格式的优点，同时又避免了数据不一致的风险。<strong>因此，如果你的线上 MySQL 设置的 binlog 格式是 statement 的话，那基本上就可以认为这是一个不合理的设置。你至少应该把 binlog 的格式设置为 mixed</strong>。比如我们这个例子，设置为 mixed 后，就会记录为 row 格式；而如果执行的语句去掉 limit 1，就会记录为 statement 格式。</p>
<h2 id="row-的好处"><a href="#row-的好处" class="headerlink" title="row 的好处"></a>row 的好处</h2><p>现在越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。这么做的理由有很多，举一个可以直接看出来的好处：<strong>恢复数据</strong>。接下来，我们就分别从 <code>delete</code>、<code>insert</code> 和 <code>update</code> 这三种 SQL 语句的角度，来看看数据恢复的问题。</p>
<h3 id="恢复数据举例"><a href="#恢复数据举例" class="headerlink" title="恢复数据举例"></a>恢复数据举例</h3><p>通过上图可以看出来，即使执行的是 <code>delete</code> 语句，row 格式的 binlog 也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条 <code>delete</code> 语句以后，发现删错数据了，可以直接把 binlog 中记录的 <code>delete</code> 语句转成 <code>insert</code>，把被错删的数据插入回去就可以恢复了。</p>
<p>如果你是执行错了 <code>insert</code> 语句呢？那就更直接了。row 格式下，<code>insert</code> 语句的 binlog 里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把 <code>insert</code> 语句转成 <code>delete</code> 语句，删除掉这被误插入的一行数据就可以了。</p>
<p>如果执行的是 <code>update</code> 语句的话，binlog 里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了 <code>update</code> 语句的话，只需要把这个 event 前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</p>
<h3 id="恢复数据工具"><a href="#恢复数据工具" class="headerlink" title="恢复数据工具"></a>恢复数据工具</h3><p>其实，由 <code>delete</code>、<code>insert</code> 或者 <code>update</code> 语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。MariaDB 的<a href="https://mariadb.com/kb/en/flashback/" target="_blank" rel="noopener">Flashback</a>工具就是基于上面介绍的原理来回滚数据的。</p>
<h2 id="binlog-恢复数据注意点"><a href="#binlog-恢复数据注意点" class="headerlink" title="binlog 恢复数据注意点"></a>binlog 恢复数据注意点</h2><p>虽然 mixed 格式的 binlog 现在已经用得不多了，但这里还是要再借用一下 mixed 格式来说明一个问题，来看一下这条 SQL 语句：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> insert into t values(10,10, now());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134855.png" alt="mixed 格式和 now()"></p>
<p>可以看到，MySQL 用的居然是 statement 格式。你一定会奇怪，如果这个 binlog 过了 1 分钟才传给备库的话，那主备的数据不就不一致了吗？接下来，我们再用 mysqlbinlog 工具来看看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134857.png" alt="TIMESTAMP 命令"></p>
<p>从图中的结果可以看到，原来 binlog 在记录 event 的时候，多记了一条命令：<code>SET TIMESTAMP=1546103491</code>。它用 SET TIMESTAMP 命令约定了接下来的 <code>now()</code> 函数的返回时间。因此，不论这个 binlog 是 1 分钟之后被备库执行，还是 3 天后用来恢复这个库的备份，这个 <code>insert</code> 语句插入的行，值都是固定的。也就是说，通过这条 <code>SET TIMESTAMP</code> 命令，MySQL 就确保了主备数据的一致性。</p>
<p>所以不能用 mysqlbinlog 解析出日志直接把里面的 statement 语句直接拷贝出来执行。这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执行的结果很可能是错误的。所以，用 binlog 来恢复数据的标准做法是，用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行。类似下面的命令：</p>
<pre class="line-numbers language-shell"><code class="language-shell">mysqlbinlog master.000001  --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令的意思是，将 master.000001 文件里面从第 2738 字节到第 2973 字节中间这段内容解析出来，放到 MySQL 去执行。</p>
<h2 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h2><p>binlog 的特性确保了在备库执行相同的 binlog，可以得到与主库相同的状态。因此，我们可以认为正常情况下主备的数据是一致的。也就是说，[该图中](##MySQL 主备的基本原理) A、B 两个节点的内容是一致的，其实，该图中画的是 M-S 结构，但实际生产上使用比较多的是双 M 结构，也就是下图所示的主备切换流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134902.png" alt="MySQL 主备切换流程 -- 双 M 结构"></p>
<p>可以发现，双 M 结构和 M-S 结构，其实区别只是多了一条线，即：节点 A 和 B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系（只是增加了一条关系，同一时间还是只有一台 MySQL 可以写入数据）。</p>
<p>但是，双 M 结构还有一个问题需要解决。业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（建议把参数 <code>log_slave_updates</code> 设置为 <code>on</code>，表示备库执行 relay log 后生成 binlog）。那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>从上图中可以看到，MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。因此，我们可以用下面的逻辑，来解决两个节点间的循环复制的问题：</p>
<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<p>按照这个逻辑，如果我们设置了双 M 结构，日志的执行流就会变成这样：</p>
<ol>
<li>从节点 A 更新的事务，binlog 里面记的都是 A 的 server id；</li>
<li>传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id；</li>
<li>再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。</li>
</ol>
<p>所以，死循环在这里就断掉了。</p>
<h4 id="还是会出现循环复制的场景"><a href="#还是会出现循环复制的场景" class="headerlink" title="还是会出现循环复制的场景"></a>还是会出现循环复制的场景</h4><p>一种场景是，在一个主库更新事务后，用命令 <code>set global server_id=x</code> 修改了 server_id。等日志再传回来的时候，发现 server_id 跟自己的 server_id 不同，就只能执行了。</p>
<p>另一种场景是，有三个节点的时候，如下图所示，trx1 是在节点 B 执行的，因此 binlog 上的 server_id 就是 B，binlog 传给节点 A，然后 A 和 A’搭建了双 M 结构，就会出现循环复制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134905.png" alt="三节点循环复制"></p>
<p>这种三节点复制的场景，做数据库迁移的时候会出现。如果出现了循环复制，可以在 A 或者 A’上，执行如下命令：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">stop slave；
CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);
start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">stop slave；
CHANGE MASTER TO IGNORE_SERVER_IDS=();
start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="MySQL是怎么保证高可用的"><a href="#MySQL是怎么保证高可用的" class="headerlink" title="MySQL是怎么保证高可用的"></a>MySQL是怎么保证高可用的</h1><p>正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。但是，MySQL 要提供高可用能力，只有最终一致性是不够的。为什么这么说呢？这里，再放一次双 M 结构的主备切换流程图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134909.png" alt="MySQL 主备切换流程--双 M 结构"></p>
<h2 id="主备切换基础知识"><a href="#主备切换基础知识" class="headerlink" title="主备切换基础知识"></a>主备切换基础知识</h2><p>主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。</p>
<h3 id="主备延迟时间计算"><a href="#主备延迟时间计算" class="headerlink" title="主备延迟时间计算"></a>主备延迟时间计算</h3><p>接下来先一起看看主动切换的场景。在介绍主动切换流程的详细步骤之前，要先你说明一个概念，即“同步延迟”。与数据同步有关的时间点主要包括以下三个：</p>
<ol>
<li>主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1;</li>
<li>之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2;</li>
<li>备库 B 执行完成这个事务，我们把这个时刻记为 T3。</li>
</ol>
<p><strong>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 T3-T1</strong>。可以在备库上执行 <code>show slave status</code> 命令，它的返回结果里面会显示 <code>seconds_behind_master</code>，用于表示当前备库延迟了多少秒。<code>seconds_behind_master</code> 的计算方法是这样的：</p>
<ol>
<li>每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 <code>seconds_behind_master</code>。</li>
</ol>
<p>可以看到，其实 <code>seconds_behind_master</code> 这个参数计算的就是 T3-T1。所以，可以用 <code>seconds_behind_master</code> 来作为主备延迟的值，这个值的时间精度是秒。</p>
<p>如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？其实不会的。因为，备库连接到主库的时候，会通过执行 <code>SELECT UNIX_TIMESTAMP()</code> 函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行 <code>seconds_behind_master</code> 计算的时候会自动扣掉这个差值。</p>
<p>需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即 T2-T1 的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完 binlog 和执行完这个事务之间的时间差。<strong>所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢</strong>，所以接下来分析这可能是由哪些原因导致的。</p>
<h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h3><h4 id="1-gt-备库机器性能较差"><a href="#1-gt-备库机器性能较差" class="headerlink" title="1&gt;备库机器性能较差"></a>1&gt;备库机器性能较差</h4><p>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或者，他们会把 20 个主库放在 4 台机器上，而把备库集中在一台机器上。其实更新请求对 IOPS 的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为“非双 1”的模式。</p>
<p>但实际上，更新过程中也会触发大量的读操作。所以，<strong>当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了</strong>。当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，<strong>所以主备库选用相同规格的机器，并且做对称部署</strong>，是现在比较常见的情况。</p>
<h4 id="2-gt-备库压力大"><a href="#2-gt-备库压力大" class="headerlink" title="2&gt;备库压力大"></a>2&gt;备库压力大</h4><p>即使做了对称部署以后，还可能会有延迟。这是为什么呢？这就是第二种常见的可能了，即备库的压力大。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</p>
<p>由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。这种情况，我们一般可以这么处理：</p>
<ol>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
<p>其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。</p>
<blockquote>
<p>备注：这里需要说明一下，从库和备库在概念上其实差不多。在这里会在 HA 过程中被选成新主库的，称为备库，其他的称为从库。</p>
</blockquote>
<h4 id="3-gt-大事务"><a href="#3-gt-大事务" class="headerlink" title="3&gt;大事务"></a>3&gt;大事务</h4><p>采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？这就是第三种可能了，即大事务。大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。</p>
<ul>
<li>一次性地用 delete 语句删除太多数据就是一个典型的大事务场景。比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。结果，负责的 DBA 同学半夜就会收到延迟报警。然后，DBA 团队就要求你后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</li>
<li>另一种典型的大事务场景，就是大表 DDL。这个场景处理方案就是，计划内的 DDL，建议使用 gh-ost 方案。</li>
</ul>
<h4 id="4-gt-备库的并行复制能力"><a href="#4-gt-备库的并行复制能力" class="headerlink" title="4&gt;备库的并行复制能力"></a>4&gt;备库的并行复制能力</h4><p>如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？造成主备延迟还有一个大方向的原因，就是备库的并行复制能力。前面几种可能导致备库延迟的原因，不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134917.png" alt="主备流程图并行能力"></p>
<p>谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上 sql_thread 执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如上图所示，第一个箭头要明显粗于第二个箭头。在主库上，影响并发度的原因就是各种锁了。由于 InnoDB 引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，在性能测试的时候会发现，并发压测线程 32 就比单线程时，总体吞吐量高。</p>
<p>而日志在备库上的执行，就是图中备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p>
<h5 id="MySQL-5-6-之前不支持并行复制"><a href="#MySQL-5-6-之前不支持并行复制" class="headerlink" title="MySQL 5.6 之前不支持并行复制"></a>MySQL 5.6 之前不支持并行复制</h5><p>在官方的 5.6 版本之前，MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主备延迟问题。从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。其实说到底，所有的多线程复制机制，都是要把上图中只有一个线程的 sql_thread，拆成多个线程，也就是都符合下面的这个模型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134919.png" alt="多线程模型"></p>
<p>上图中，coordinator 就是原来的 sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了 worker 线程。而 work 线程的个数，就是由参数 <code>slave_parallel_workers</code> 决定的。根据经验，把这个值设置为 8~16 之间最好（32 核物理机的情况），毕竟备库还有可能要提供读查询，不能把 CPU 都吃光了。</p>
<h5 id="并行复制发展过程"><a href="#并行复制发展过程" class="headerlink" title="并行复制发展过程"></a>并行复制发展过程</h5><ul>
<li>事务能不能按照轮询的方式分发给各个 worker，也就是第一个事务分给 worker_1，第二个事务发给 worker_2 呢？其实是不行的。因为，事务被分发给 worker 以后，不同的 worker 就独立执行了。但是，由于 CPU 的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</li>
<li>同一个事务的多个更新语句，能不能分给不同的 worker 来执行呢？答案是，也不行。举个例子，一个事务更新了表 t1 和表 t2 中的各一行，如果这两条更新语句被分到不同 worker 的话，虽然最终的结果是主备一致的，但如果表 t1 执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的隔离性。</li>
</ul>
<p>所以，coordinator 在分发的时候，需要满足以下这两个基本要求：</p>
<ul>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。</li>
<li>同一个事务不能被拆开，必须放到同一个 worker 中。</li>
</ul>
<p>各个版本的多线程复制，都遵循了这两条基本原则。接下来就看看各个版本的并行复制策略。</p>
<h6 id="丁大开发的MySQL-5-5-版本的并行复制策略"><a href="#丁大开发的MySQL-5-5-版本的并行复制策略" class="headerlink" title="丁大开发的MySQL 5.5 版本的并行复制策略"></a>丁大开发的MySQL 5.5 版本的并行复制策略</h6><p>官方 MySQL 5.5 版本是不支持并行复制的。但是，在 2012 年的时候，丁大自己服务的业务出现了严重的主备延迟，原因就是备库只有单线程复制，然后就先后写了两个版本的并行策略。</p>
<ol>
<li><p><strong>按表分发策略</strong></p>
<p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如下图所示，就是按表分发的规则。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134927.png" alt="按表并行复制程模型"></p>
<p>可以看到，每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是“库名. 表名”，value 是一个数字，表示队列中有多少个事务修改这个表。</p>
<p>在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。上图中，hash_table_1 表示，现在 worker_1 的“待执行事务队列”里，有 4 个事务涉及到 <code>db1.t1</code> 表，有 1 个事务涉及到 <code>db2.t2</code> 表；hash_table_2 表示，现在 worker_2 中有一个事务会更新到表 <code>t3</code> 的数据。</p>
<p>假设在图中的情况下，coordinator 从中转日志中读入一个新事务 T，这个事务修改的行涉及到表 <code>t1</code> 和 <code>t3</code>。现在我们用事务 T 的分配流程，来看一下分配规则：</p>
<ol>
<li>由于事务 T 中涉及修改表 <code>t1</code>，而 worker_1 队列中有事务在修改表 <code>t1</code>，事务 T 和队列中的某个事务要修改同一个表的数据，这种情况我们说事务 T 和 worker_1 是冲突的。</li>
<li>按照这个逻辑，顺序判断事务 T 和每个 worker 队列的冲突关系，会发现事务 T 跟 worker_2 也冲突。事务 T 跟多于一个 worker 冲突，coordinator 线程就进入等待。</li>
<li>每个 worker 继续执行，同时修改 hash_table。假设 hash_table_2 里面涉及到修改表 t3 的事务先执行完成，就会从 hash_table_2 中把 <code>db1.t3</code> 这一项去掉。</li>
<li>这样 coordinator 会发现跟事务 T 冲突的 worker 只有 worker_1 了，因此就把它分配给 worker_1。</li>
<li>coordinator 继续读下一个中转日志，继续分配事务。</li>
</ol>
<p>也就是说，每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
</li>
<li><p><strong>按行分发策略</strong></p>
<p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。<strong>显然，这个模式要求 binlog 格式必须是 row</strong>。这时候，我们判断一个事务 T 和 worker 是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。按行复制和按表复制的数据结构差不多，也是为每个 worker，分配一个 hash 表。只是要实现按行分发，这时候的 key，就必须是“库名 + 表名 + 唯一键的值”。但是，这个“唯一键”只有主键 id 还是不够的，我们还需要考虑下面这种场景，表 t1 中除了主键，还有唯一索引 a：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE `t1` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `a` (`a`)
) ENGINE=InnoDB;

insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设，接下来我们要在主库执行这两个事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134930.png" alt="唯一键冲突示例"></p>
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的 worker，就有可能 session B 的语句先执行。这时候 id=1 的行的 a 的值还是 1，就会报唯一键冲突。</p>
<p>因此，基于行的策略，事务 hash 表中还需要考虑到表中除了主键之外还是有可能存在其它唯一键的，此时 key 应该是“库名 + 表名 + 索引 a 的名字 +a 的值”。</p>
<p>比如，在上面这个例子中，要在表 <code>t1</code> 上执行 <code>update t1 set a=1 where id=2</code> 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项:</p>
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。</li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
<p>可见，相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</p>
</li>
</ol>
<p>这两个方案其实都有一些约束条件：</p>
<ul>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
</ul>
<p>但，好在这三条约束规则，本来就是 DBA 之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p>
<ul>
<li>耗费内存。比如一个语句要删除 100 万行数据，这时候 hash 表就要记录 100 万个项。</li>
<li>耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务，这个成本还是很高的。</li>
</ul>
<p>所以在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过 10 万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p>
<ol>
<li>coordinator 暂时先 hold 住这个事务；</li>
<li>等待所有 worker 都执行完成，变成空队列；</li>
<li>coordinator 直接执行这个事务；</li>
<li>恢复并行模式。</li>
</ol>
<h6 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h6><p>官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的 hash 表里，key 就是数据库名。</p>
<p>这个策略的并行效果，取决于压力模型。如果在主库上有多个 DB，并且各个 DB 的压力均衡，使用这个策略的效果会很好。相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</li>
<li>不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</li>
</ol>
<p>但是，如果你的主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者如果不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。理论上你可以创建不同的 DB，把相同热度的表均匀分到这些不同的 DB 中，强行使用这个策略。不过由于需要特地移动数据，这个策略用得并不多。</p>
<h6 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h6><p>MariaDB 的并行复制策略利用的是 redo log 和 binlog 组提交就是这个特性：</p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行（因为冲突的两个事务必定因为锁阻塞有一个先后提交顺序，只有前者提交了，后者才能继续执行，而所有事务的提交都会随着一个唯一的事务组提交，所以不可能存在冲突的事务在同一个提交组里面）；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
</ol>
<p>在实现上，MariaDB 是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析 binlog，并拆分到 worker”上。而 MariaDB 的这个策略，目标是“模拟主库的并行模式”。但是，这个策略有一个问题，它并没有实现“<strong>真正的模拟主库并发度</strong>”这个目标。</p>
<p>在主库上，一组事务在 commit 的时候，下一组事务是同时处于“执行中”状态的。如下图所示，假设了三组事务在主库的执行情况，你可以看到在 trx1、trx2 和 trx3 提交的时候，trx4、trx5 和 trx6 是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入 commit 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135153.png" alt="主库并行事务"></p>
<p>而按照 MariaDB 的并行复制策略，备库上的执行效果如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134940.png" alt="MariaDB 并行复制，备库并行效果"></p>
<p>可以看到，<strong>在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行（需要保证同一个提交组的事务完全提交下一组才能开始执行，即使下一组已经准备就绪了），这样系统的吞吐量就不够。另外，这个方案很容易被大事务拖后腿。假设 trx2 是一个超大事务，那么在备库应用的时候，trx1 和 trx3 执行完成后，就只能等 trx2 完全执行完成，下一组才能开始执行。这段时间，只有一个 worker 线程在工作，是对资源的浪费</strong>。不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p>
<h6 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h6><p>在 MariaDB 并行复制实现之后，官方的 MySQL5.7 版本也提供了类似的功能，由参数 <code>slave-parallel-type</code> 来控制并行复制策略：</p>
<ol>
<li>配置为 <code>DATABASE</code>，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 <code>LOGICAL_CLOCK</code>，表示的就是类似 MariaDB 的策略。不过，<strong>MySQL 5.7 这个策略，针对并行度做了优化</strong>。</li>
</ol>
<p>上面提到 MariaDB 的从库并行复制策略中，即使下一组在主库已经提交的事务已经传送到 relay log 等待执行，在当前组事务完全提交之前，它都不能执行，也就是说，它是在每一次日志 fsync 的时候对同一批已经 prepare 完毕准备被标记为 commit 状态的事务进行聚合成为一组并行执行事务。<strong>因为它同时还要保证存在更新冲突的事务在主备库上的更新都是一致的，所以以事务被标记为 commit 状态的先后顺序作为同步点入手是可以得到主库上冲突事务的执行的前后顺序的</strong>。但是这里面是否可以优化呢？有的，上面提到的 MySQL 5.7 的优化就是这里，再回顾一下两阶段提交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134947.png" alt="两阶段提交细化过程图"></p>
<p>其实，不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁冲突的检验了，即只有当前事务所需要的资源没有被其它未提交事务占有的情况下，当前事务执行提交的时候才可以不经阻塞进入 redo log prepare 状态，否则当前事务将会被阻塞。也就是说，除了上面提到的 MariaDB 的从库根据事务被标记为 commit 状态的先后顺序与主库进行冲突事务的提交顺序同步之外，还可以根据事务被标记为 prepare 状态的先后顺序与主库进行同步。</p>
<p>因此，MySQL 5.7 并行复制策略的思想是：</p>
<ol>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<blockquote>
<p>相较于 MariaDB 在组提交的时候才对 prepare 完毕的事务申请最新的 commit id；MySQL 5.7 在事务进入 prepare 状态的时候就会给该事务申请最新的 commit id。所以 MySQL 5.7 可以聚合为同一组并行执行的事务的范围就更大了，也就是拥有一样的 commit id 的事务数量就更多了。（备库在执行一个事务的时候，就是先检查 worker 线程中是否存在比当前事务 commit id 小的事务在执行，如果有就需要阻塞，没有就可以执行，所以相同的 commit id 事务越多，阻塞就越少，并行度越高）</p>
</blockquote>
<p>另外，以下两个参数也是用于故意拉长 binlog 从 write 到 fsync 的时间，以此减少 binlog 的写盘次数。在 MySQL 5.7 的并行复制策略里，它们可以用来制造更多的“同时处于 prepare 阶段的事务”。这样就增加了备库复制的并行度。</p>
<ol>
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在 MySQL 5.7 处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p>
<h6 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h6><p>在 2018 年 4 月份发布的 MySQL 5.7.22 版本里，<strong>MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制</strong>。相应地，新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p>
<ol>
<li><code>COMMIT_ORDER</code>，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li><code>WRITESET</code>，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
<li><code>WRITESET_SESSION</code>，是在 <code>WRITESET</code> 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序，不能并行执行。</li>
</ol>
<blockquote>
<ul>
<li>对于<code>WRITESET</code>，一个线程中执行的不同事务，只要这些事务没有冲突就可以并行执行（即保证物理上备库和主库数据一致的情况下最高程度并发）。（什么情况下可能会出现一个线程中不同事务可以并行执行呢？其实很常见，并行复制不及时的话，事务执行就会延迟，所以对于一个线程，是可能存在前一个事务没来得及在备库中执行，下一个事务又从主库传过来了，此时这两个事务根据 hash 值计算出没有冲突，可以并行执行）</li>
<li>对于 <code>WRITESET_SESSION</code> 一个线程中执行的不同事务无论计算的 hash 值是否有冲突不能并行执行，必须按照 commit id 顺序同步执行。</li>
</ul>
</blockquote>
<p>当然为了唯一标识，这个 hash 值是通过“库名 + 表名 + 索引名 + 值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。这跟前面介绍的丁大实现的基于 MySQL 5.5 版本的按行分发的策略是差不多的。</p>
<p>不过，MySQL 官方的这个实现还是有很大的优势：</p>
<ol>
<li><strong>writeset 是在主库生成后直接写入到 binlog 里面的</strong>，这样在备库执行的时候，不需要解析 binlog 内容（event 里的行数据），节省了很多计算量；（<strong>相较于丁大的实现方式，是不改变原有 binlog 格式，在备库里面实时计算的，以下两点的区别原因也在于此</strong>）</li>
<li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；</li>
<li>由于备库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。</li>
</ol>
<p>因此，MySQL 5.7.22 的并行复制策略在通用性上还是有保证的。当然，对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。</p>
<h5 id="一个例子理解-5-7-22-的并行复制策略"><a href="#一个例子理解-5-7-22-的并行复制策略" class="headerlink" title="一个例子理解 5.7.22 的并行复制策略"></a>一个例子理解 5.7.22 的并行复制策略</h5><p>假设一个 MySQL 5.7.22 版本的主库，单线程插入了很多数据，过了 3 个小时后，我们要给这个主库搭建一个相同版本的备库。<strong>这时候，为了更快地让备库追上主库，要开并行复制</strong>。在 <code>binlog-transaction-dependency-tracking</code> 参数的 COMMIT_ORDER、<code>WRITESET</code> 和 <code>WRITE_SESSION</code> 这三个取值中，你会选择哪一个呢？你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？</p>
<p>由于主库是单线程压力模式，所以每个事务的 commit_id 都不同，那么设置为 <code>COMMIT_ORDER</code> 模式的话，从库也只能单线程执行。同样地，由于 <code>WRITESET_SESSION</code> 模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。所以，应该将 <code>binlog-transaction-dependency-tracking</code> 设置为 <code>WRITESET</code>。</p>
<h4 id="5-gt-其它"><a href="#5-gt-其它" class="headerlink" title="5&gt;其它"></a>5&gt;其它</h4><ul>
<li>表上无主键的情况(主库利用索引更改数据,备库回放只能用全表扫描,这种情况可以调整<code>slave_rows_search_algorithms</code>参数适当优化下)</li>
<li>设置的是延迟备库</li>
<li>备库空间不足的情况下</li>
<li>… …</li>
</ul>
<h3 id="主备延迟时间分析示例"><a href="#主备延迟时间分析示例" class="headerlink" title="主备延迟时间分析示例"></a>主备延迟时间分析示例</h3><p>一般现在的数据库运维系统都有备库延迟监控，其实就是在备库上执行 show slave status，采集 seconds_behind_master 的值。假设，现在你看到你维护的一个备库，它的延迟监控的图像类似下图，是一个 45°斜向上的线段，你觉得可能是什么原因导致呢？你又会怎么去确认这个原因呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134953.png" alt="备库延迟"></p>
<p>看这曲线应该是T3随着时间的增长在增长，而T1这个时间点是没变的。即备库的同步在这段时间完全被堵住了。产生这种现象典型的场景主要包括两种：</p>
<ul>
<li><p>一种是大事务（包括大表 DDL、一个事务操作很多行）；</p>
</li>
<li><p>还有一种情况比较隐蔽，就是备库起了一个长事务，比如</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">begin; 
select * from t limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后就不动了。这时候主库对表 t 做了一个加字段操作，即使这个表很小，这个 DDL 在备库应用的时候也会被堵住，也不能看到这个现象。</p>
</li>
</ul>
<h3 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h3><p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p>
<h4 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h4><p>在前面的双 M 结构图中，从状态 1 到状态 2 切换的详细过程是这样的：</p>
<ol>
<li>判断备库 B 现在的 <code>seconds_behind_master</code>，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库 A 改成只读状态，即把 <code>readonly</code> 设置为 true；</li>
<li>判断备库 B 的 <code>seconds_behind_master</code> 的值，直到这个值变成 0 为止；</li>
<li>把备库 B 改成可读写状态，也就是把 <code>readonly</code> 设置为 false；</li>
<li>把业务请求切到备库 B。</li>
</ol>
<p>这个切换流程，一般是由专门的 HA 系统来完成的，暂时称之为可靠性优先流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221134956.png" alt="MySQL 可靠性优先主备切换流程"></p>
<blockquote>
<p>注：图中的 SBM，是 seconds_behind_master 参数的简写。</p>
</blockquote>
<p>可以看到，这个切换流程中是有不可用时间的。因为在步骤 2 之后，主库 A 和备库 B 都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤 5 完成后才能恢复。在这个不可用状态中，比较耗费时间的是步骤 3，可能需要耗费好几秒的时间。这也是为什么需要在步骤 1 先做判断，确保 seconds_behind_master 的值足够小。试想如果一开始主备延迟就长达 30 分钟，而不先做判断直接切换的话，系统的不可用时间就会长达 30 分钟，这种情况一般业务都是不可接受的。当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。你也可以选择可用性优先的策略，来把这个不可用时间几乎降为 0。</p>
<h4 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h4><p>如果强行把步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 B，并且让备库 B 可以读写，那么系统几乎就没有不可用时间了。我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。接下来介绍一个可用性优先流程产生数据不一致的例子。假设有一个表 t：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> CREATE TABLE `t` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `c` int(11) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(c) values(1),(2),(3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个表定义了一个自增主键 id，初始化数据后，主库和备库上都是 3 行数据。接下来，业务人员要继续在表 t 上执行两条插入语句的命令，依次是：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">insert into t(c) values(4);
insert into t(c) values(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到 5 秒。在插入一条 c=4 的语句后，发起了主备切换。下图是可用性优先策略，且 <code>binlog_format=mixed</code> 时的切换流程和数据结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135002.png" alt="可用性优先策略，且 binlog_format=mixed"></p>
<ol>
<li>步骤 2 中，主库 A 执行完 <code>insert</code> 语句，插入了一行数据（4,4），之后开始进行主备切换。</li>
<li>步骤 3 中，由于主备之间有 5 秒的延迟，所以备库 B 还没来得及应用“插入 c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</li>
<li>步骤 4 中，备库 B 插入了一行数据（4,5），并且把这个 binlog 发给主库 A。</li>
<li>步骤 5 中，备库 B 执行“插入 c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库 B 执行的“插入 c=5”这个语句，传到主库 A，就插入了一行新数据（5,5）。</li>
</ol>
<p>最后的结果就是，主库 A 和备库 B 上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p>
<p>那么，如果还是用可用性优先策略，但设置 <code>binlog_format=row</code>，情况又会怎样呢？因为 row 格式在记录 binlog 的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错 duplicate key error 并停止。也就是说，这种情况下，备库 B 的 (5,4) 和主库 A 的 (5,5) 这两行数据，都不会被对方执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135009.png" alt="可用性优先策略，且 binlog_format=row"></p>
<h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><p>从上面的分析中，可以看到一些结论：</p>
<ol>
<li>使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。而使用 mixed 或者 statement 格式的 binlog 时，数据很可能悄悄地就不一致了。如果过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li>
<li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li>
</ol>
<p>但事无绝对，有没有哪种情况数据的可用性优先级更高呢？答案是，有的。</p>
<p>有这样的一个场景：</p>
<ul>
<li>有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过 binlog 来修补，而这个短暂的不一致也不会引发业务问题。</li>
<li>同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。</li>
</ul>
<p>这时候，可能就需要选择先强行切换，事后再补数据的策略。当然，事后复盘的时候，我们想到了一个改进措施就是，让业务逻辑不要依赖于这类日志的写入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临时库里面。这样的话，这种场景就又可以使用可靠性优先策略了。</p>
<h5 id="主备延迟的重要"><a href="#主备延迟的重要" class="headerlink" title="主备延迟的重要"></a>主备延迟的重要</h5><p>按照可靠性优先的思路，异常切换会是什么效果？假设，主库 A 和备库 B 间的主备延迟是 30 分钟，这时候主库 A 掉电了，HA 系统要切换 B 作为主库。我们在主动切换的时候，可以等到主备延迟小于 5 秒的时候再启动切换，但这时候已经别无选择了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135012.png" alt="可靠性优先策略，主库不可用"></p>
<p>采用可靠性优先策略的话，就必须得等到备库 B 的 <code>seconds_behind_master=0</code> 之后，才能切换。但现在的情况比刚刚更严重，并不是系统只读、不可写的问题了，而是系统处于完全不可用的状态。因为，主库 A 掉电后，我们的连接还没有切到备库 B。</p>
<p>那能不能直接切换到备库 B，但是保持 B 只读呢？这样也不行。因为，这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。</p>
<p>所以在满足数据可靠性的前提下，MySQL 高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。<strong>所以在实际的应用中，更建议使用可靠性优先的策略。毕竟保证数据准确，应该是数据库服务的底线。在这个基础上，通过减少主备延迟，提升系统的可用性。</strong></p>
<h2 id="一主多从：如何正确地切换主备"><a href="#一主多从：如何正确地切换主备" class="headerlink" title="一主多从：如何正确地切换主备"></a>一主多从：如何正确地切换主备</h2><p>上面讲的都是一主一备的结构。大多数的互联网应用场景都是读多写少，所以业务在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，就要涉及到一主多从的架构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135019.png" alt="一主多从基本结构"></p>
<p>图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。下图就是主库发生故障，主备切换后的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135026.png" alt="一主多从基本结构--主备切换"></p>
<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<p>接下来，我们再一起看看一个切换系统会怎么完成一主多从的主备切换过程。</p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 <code>change master</code> 命令：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
MASTER_LOG_FILE=$master_log_name 
MASTER_LOG_POS=$master_log_pos  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这条命令有这么 6 个参数：</p>
<ul>
<li><code>MASTER_HOST</code>、<code>MASTER_PORT</code>、<code>MASTER_USER</code> 和 <code>MASTER_PASSWORD</code> 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>最后两个参数 <code>MASTER_LOG_FILE</code> 和 <code>MASTER_LOG_POS</code> 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ul>
<p>那么，这里就有一个问题了，节点 B 要设置成 A’的从库，就要执行 <code>change master</code> 命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？原来节点 B 是 A 的从库，本地记录的主库位点就是 A 的位点。但是相同的日志，在 A 的位点和 A’的位点是不同的，不能直接将两者的位点做一个直接映射。</p>
<h4 id="寻找位点"><a href="#寻找位点" class="headerlink" title="寻找位点"></a>寻找位点</h4><p>因此，从库 B 要切换的时候，就需要先经过“找同步位点”这个逻辑。这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？来分析一下看看这个位点一般是怎么获取到的。考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库 B 上已经执行过的事务。一种取同步位点的方法是这样的：</p>
<ol>
<li><p>等待新主库 A’把中转日志（relay log）全部同步完成；</p>
</li>
<li><p>在 A’上执行 <code>show master status</code> 命令，得到当前 A’上最新的 binlog File 和 Position；</p>
</li>
<li><p>取原主库 A 故障的时刻 T；</p>
</li>
<li><p>用 mysqlbinlog 工具结合第二步查到的 A’ 的当前最新的 binlog File 和位置解析 A’的 File，得到 T 时刻的位点。</p>
<pre class="line-numbers language-shell"><code class="language-shell">mysqlbinlog File --stop-datetime=T --start-datetime=T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135033.png" alt="mysqlbinlog 部分输出结果"></p>
<p>图中，end_log_pos 后面的值“123”，表示的就是 A’这个实例，在 T 时刻写入新的 binlog 的位置。然后，我们就可以把 123 这个值作为 $master_log_pos ，用在节点 B 的 <code>change master</code> 命令里。</p>
</li>
</ol>
<h4 id="无法定位到精准位点"><a href="#无法定位到精准位点" class="headerlink" title="无法定位到精准位点"></a>无法定位到精准位点</h4><p>当然这个值并不精确。为什么呢？你可以设想有这么一种情况，假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。</p>
<p>那么，这时候系统的状态是这样的：</p>
<ol>
<li>在从库 B 上，由于同步了 binlog， R 这一行已经存在；</li>
<li>在新主库 A’上， R 这一行也已经存在，日志是写在 123 这个位置之后的；</li>
<li>我们在从库 B 上执行 change master 命令，指向 A’的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。</li>
</ol>
<p>这时候，从库 B 的同步线程就会报告 <code>Duplicate entry ‘id_of_R’ for key ‘PRIMARY’</code> 错误，提示出现了主键冲突，然后停止同步。</p>
<h4 id="处理问题位点"><a href="#处理问题位点" class="headerlink" title="处理问题位点"></a>处理问题位点</h4><p>所以，通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</p>
<h5 id="逐步跳过错误位点"><a href="#逐步跳过错误位点" class="headerlink" title="逐步跳过错误位点"></a>逐步跳过错误位点</h5><p>一种做法是，主动跳过一个事务。跳过命令的写法是：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">set global sql_slave_skip_counter=1;
start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
<blockquote>
<p><code>sql_slave_skip_counter</code> 跳过的其实是一个 event，由于 MySQL 总不能执行一半的事务，所以既然跳过了一个 event，就会跳到这个事务的末尾，因此上面的语句是可以跳过整个事务的</p>
</blockquote>
<h5 id="一次性忽略所有错误位点"><a href="#一次性忽略所有错误位点" class="headerlink" title="一次性忽略所有错误位点"></a>一次性忽略所有错误位点</h5><p>另外一种方式是，通过设置 <code>slave_skip_errors</code> 参数，直接设置跳过指定的错误。在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ul>
<li>1062 错误是插入数据时唯一键冲突；</li>
<li>1032 错误是删除数据时找不到行。</li>
</ul>
<p>因此，我们可以把 <code>slave_skip_errors</code> 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。这个背景是，我们很清楚在主备切换过程中，直接跳过 1032 和 1062 这两类错误是无损的，所以才可以这么设置 <code>slave_skip_errors</code> 参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>通过 <code>sql_slave_skip_counter</code> 跳过事务和通过 <code>slave_skip_errors</code> 忽略错误的方法，虽然都最终可以建立从库 B 和新主库 A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6 版本引入了 GTID，彻底解决了定位同步位点这个困难。</p>
<h4 id="GTID-介绍"><a href="#GTID-介绍" class="headerlink" title="GTID 介绍"></a>GTID 介绍</h4><p>GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<pre><code>GTID=server_uuid:gno</code></pre><p>其中：</p>
<ul>
<li>server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li>
<li>gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。</li>
</ul>
<p>这里需要说明一下，在 MySQL 的官方文档里，GTID 格式是这么定义的：</p>
<pre><code>GTID=source_id:transaction_id</code></pre><p>这里的 source_id 就是 server_uuid；而后面的这个 transaction_id，容易造成误导，所以改成了 gno。为什么说使用 transaction_id 容易造成误解呢？因为，<strong>在 MySQL 里面我们说 transaction_id 就是指事务 id，事务 id 是在事务执行过程中分配的，如果这个事务回滚了，事务 id 也会递增，而 gno 是在事务提交的时候才会分配</strong>。从效果上看，GTID 往往是连续的，因此我们用 gno 来表示更容易理解。</p>
<h4 id="GTID-使用"><a href="#GTID-使用" class="headerlink" title="GTID 使用"></a>GTID 使用</h4><p>GTID 模式的启动也很简单，我们只需要在启动一个 MySQL 实例的时候，加上参数 <code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code> 就可以了。在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 <code>gtid_next</code> 的值：</p>
<ol>
<li>如果 <code>gtid_next=automatic</code>，代表使用默认值。这时，MySQL 就会把 <code>server_uuid:gno</code> 分配给这个事务。<ol>
<li>记录 binlog 的时候，先记录一行 <code>SET @@SESSION.GTID_NEXT=‘server_uuid:gno’</code>作为当前事务的全局唯一标识，主要给从库识别用的;</li>
<li>把这个 GTID 加入本实例的 GTID 集合，表示当前实例已经执行过这个事务了，当下次有事务要执行的时候，如果发现 session 变量 <code>gtid_next</code> 的值等于集合中的某个 GTID，这个事务将被跳过，不执行。</li>
</ol>
</li>
<li>如果 gtid_next 是一个指定的 GTID 的值，比如通过 <code>set gtid_next=&#39;current_gtid’</code>指定为 current_gtid，那么就有两种可能：<ol>
<li>如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；</li>
<li>如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。</li>
</ol>
</li>
</ol>
<p>注意，一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。<strong>这样，每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”</strong>。</p>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>在实例 X 中创建一个表 t。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t values(1,1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135040.png" alt="初始化数据的 binlog"></p>
<p>可以看到，事务的 BEGIN 之前有一条 <code>SET @@SESSION.GTID_NEXT</code> 命令。这时，如果实例 X 有从库，那么将 <code>CREATE TABLE</code> 和 <code>insert</code> 语句的 binlog 同步到从库，从库在执行事务之前就会先执行这两个 SET 命令， 这样被加入从库的 GTID 集合的，就是图中的这两个 GTID。</p>
<p>假设，现在这个实例 X 是另外一个实例 Y 的从库，并且此时在实例 Y 上执行了下面这条插入语句：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">insert into t values(1,1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>并且，这条语句在实例 Y 上的 GTID 是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。那么，实例 X 作为 Y 的从库，就要同步这个事务过来执行然后将这个 GTID 加入到自己的 GTID 集合中，但是显然因为表 t 已经插入过 id 为 1 的行，该主库语句执行出现主键冲突，导致实例 X 的同步线程停止。这时，我们应该怎么处理呢？</p>
<p>处理方法就是，你可以执行下面的这个语句序列：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">set gtid_next='aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10';
begin;
commit;
set gtid_next=automatic;
start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，前三条语句的作用，是通过提交一个空事务，把这个 GTID 加到实例 X 的 GTID 集合中。如下图所示，就是执行完这个空事务之后的 <code>show master status</code> 的结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135043.png" alt="show master status 结果"></p>
<p>可以看到实例 X 的 <code>Executed_Gtid_set</code> (GTID集合)里面，已经加入了这个 GTID。这样，再执行 <code>start slave</code> 命令让同步线程执行起来的时候，虽然实例 X 上还是会继续执行实例 Y 传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例 X 的 GTID 集合中了，所以实例 X 就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p>
<blockquote>
<p>在上面的这个语句序列中，start slave 命令之前还有一句 <code>set gtid_next=automatic</code>。这句话的作用是“恢复 GTID 的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配 gno=3（当然，在同步主库的线程中，会通过主动设置主库的 GTID 为 current_gtid 执行主库事务，而在当前库上新执行的事务就是 automatic 了）。</p>
</blockquote>
<h4 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h4><p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">CHANGE MASTER TO 
MASTER_HOST=$host_name 
MASTER_PORT=$port 
MASTER_USER=$user_name 
MASTER_PASSWORD=$password 
master_auto_position=1 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>master_auto_position=1</code> 就表示这个主备关系使用的是 GTID 协议。可以看到，前面让我们头疼不已的 <code>MASTER_LOG_FILE</code> 和 <code>MASTER_LOG_POS</code> 参数，已经不需要指定了。我们把现在这个时刻，实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。接下来，我们就看看现在的主备切换逻辑。我们在实例 B 上执行 <code>start slave</code> 命令，取 binlog 的逻辑是这样的：</p>
<ol>
<li><p>实例 B 指定主库 A’，基于主备协议建立连接。</p>
</li>
<li><p>实例 B 把 set_b 发给主库 A’。</p>
</li>
<li><p>实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GTID 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。</p>
<ol>
<li><p>如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；</p>
<blockquote>
<p>此时解决方案：</p>
<ol>
<li>如果业务允许主从不一致的情况，那么可以在主库上先执行 <code>show global variables like ‘gtid_purged’</code>，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 reset master，再执行 set global gtid_purged =‘gtid_purged1’；最后执行 start slave，就会从主库现存的 binlog 开始同步。binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li>
<li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li>
<li>如果有其他的从库保留有全量的 binlog 的话，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志以后，如果有需要，再接回主库。</li>
<li>如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 start slave。</li>
</ol>
</blockquote>
</li>
<li><p>如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；</p>
</li>
</ol>
</li>
<li><p>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。</p>
</li>
</ol>
<p>其实，这个逻辑里面包含了一个设计思想：在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A’就拒绝把日志发给 B。这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p>
<p>基于上面的介绍，我们再来看看引入 GTID 后，一主多从的切换场景下，主备切换是如何实现的。由于不需要找位点了，所以从库 B、C、D 只需要分别执行 <code>change master</code> 命令指向实例 A’即可。其实，严谨地说，主备切换不是不需要找位点了，<strong>而是找位点这个工作，在实例 A’内部就已经自动完成了</strong>。但由于这个工作是自动的，所以对 HA 系统的开发人员来说，非常友好。</p>
<p>之后这个系统就由新主库 A’写入，主库 A’的自己生成的 binlog 中的 GTID 集合格式是：<code>server_uuid_of_A’:1-M</code>。如果之前从库 B 的 GTID 集合格式是 <code>server_uuid_of_A:1-N</code>， 那么切换之后 GTID 集合的格式就变成了 server_uuid_of_A:1-N, <code>server_uuid_of_A’:1-M</code>。当然，主库 A’之前也是 A 的备库，因此主库 A’和从库 B 的 GTID 集合是一样的。这就达到了我们预期。</p>
<h4 id="GTID-和在线-DDL"><a href="#GTID-和在线-DDL" class="headerlink" title="GTID 和在线 DDL"></a>GTID 和在线 DDL</h4><p>在业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。<strong>在双 M 结构下，备库执行的 DDL 语句也会传给主库，为了避免传回后对主库造成影响，要通过 <code>set sql_log_bin=off</code> 暂时关掉备库的 binlog 写</strong>。这样操作的话，数据库里面是加了索引，但是 binlog 并没有记录下这一个更新，是会导致数据和日志不一致的。现在可以通过 GTID 方案实现 online DDL 的执行。</p>
<p>假设，这两个互为主备关系的库还是实例 X 和实例 Y，且当前主库是 X，并且都打开了 GTID 模式。这时的主备切换流程可以变成下面这样：</p>
<ul>
<li><p>在实例 X 上执行 <code>stop slave</code> ，停止复制实例 Y，此时双 M 变成单 M 结构，Y -&gt; X。</p>
</li>
<li><p>在实例 Y 上执行 DDL 语句。注意，这里并不需要关闭 binlog。</p>
</li>
<li><p>执行完成后，查出这个 DDL 语句对应的 GTID，并记为 <code>server_uuid_of_Y:gno</code>。</p>
</li>
<li><p>到实例 X 上执行以下语句序列：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">set GTID_NEXT="server_uuid_of_Y:gno";
begin;
commit;
set gtid_next=automatic;
start slave;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样做的目的在于，既可以让实例 Y 的更新有 binlog 记录，同时也可以确保不会在实例 X 上执行这条更新。</p>
</li>
<li><p>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</p>
</li>
</ul>
<h2 id="一主多从：主备延迟带来的读写分离问题"><a href="#一主多从：主备延迟带来的读写分离问题" class="headerlink" title="一主多从：主备延迟带来的读写分离问题"></a>一主多从：主备延迟带来的读写分离问题</h2><p>所谓的一主多从的结构，其实就是读写分离的基本结构了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135049.png" alt="读写分离基本结构"></p>
<p>读写分离的主要目标就是分摊主库的压力。图 1 中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。还有一种架构是，在 MySQL 和客户端之间有一个中间代理层 proxy，客户端只连接 proxy， 由 proxy 根据请求类型和上下文决定请求的分发路由。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135051.jpg" alt="带 proxy 的读写分离架构"></p>
<h3 id="客户端直连和-proxy-读写分离架构"><a href="#客户端直连和-proxy-读写分离架构" class="headerlink" title="客户端直连和 proxy 读写分离架构"></a>客户端直连和 proxy 读写分离架构</h3><ol>
<li>客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ol>
<p>理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带 proxy 的架构方向发展的。</p>
<h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><p>但是，不论使用哪种架构，都会即将要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。<strong>这种“在从库上会读到系统的一个过期状态”的现象，在这里暂且称之为“过期读”。</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>前面说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能 100% 避免的。不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。接下来，我们就来讨论怎么处理过期读问题。</p>
<p>处理过期读的方案汇总：</p>
<ul>
<li>强制走主库方案；</li>
<li>sleep 方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合 semi-sync 方案；</li>
<li>等主库位点方案；</li>
<li>等 GTID 方案。</li>
</ul>
<h4 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h4><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p>
<ol>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ol>
<p>这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。因此接下来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点。</p>
<h4 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h4><p>主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 <code>select sleep(1)</code> 命令。这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p>
<p>这个方案的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，还可能会说，直接在发起查询时先执行一条 sleep 语句，用户体验很不友好啊。但，这个思路确实可以在一定程度上解决问题。</p>
<p>为了看起来更靠谱儿，我们可以换一种方式。以卖家发布商品为例，商品发布后，用 Ajax（Asynchronous JavaScript + XML，异步 JavaScript 和 XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了 sleep 的目的，进而也就解决了过期读的问题。也就是说，这个 sleep 方案确实解决了类似场景下的过期读问题。</p>
<p>但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：如果这个查询请求本来 0.5 秒就可以在从库上拿到正确结果，也会等 1 秒；如果延迟超过 1 秒，还是会出现过期读。是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似 Ajax 场景下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来就你介绍一些更准确的方案。</p>
<h4 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h4><p>要确保备库无延迟，通常有三种做法。前面提到<code>show slave status</code> 结果里的 <code>seconds_behind_master</code> 参数的值，可以用来衡量主备延迟时间的长短。</p>
<p>所以<strong>第一种确保主备无延迟的方法</strong>是，每次从库执行查询请求前，先判断 <code>seconds_behind_master</code> 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。<code>seconds_behind_master</code> 的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和 GTID 的方法来确保主备无延迟，也就是接下来要说的第二和第三种方法。</p>
<p>如下图所示，是一个 <code>show slave status</code> 结果的部分截图</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135056.png" alt="show slave status 结果"></p>
<p>现在，我们就通过这个结果，来看看具体如何通过对比位点和 GTID 来确保主备无延迟。</p>
<p><strong>第二种方法，对比位点确保主备无延迟</strong>：</p>
<ul>
<li>Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<p><strong>第三种方法，对比 GTID 集合确保主备无延迟</strong>：</p>
<ul>
<li>Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。可见，对比位点和对比 GTID 这两种方法，都要比判断 <code>seconds_behind_master</code> 是否为 0 更准确。在执行查询请求之前，先判断从库是否同步完成的方法，相比于 sleep 方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p>
<p>一个事务的 binlog 在主备库之间的状态：</p>
<ol>
<li>主库执行完成，写入 binlog，并反馈给客户端；</li>
<li>binlog 被从主库发送给备库，备库收到；</li>
<li>在备库执行 binlog 完成。</li>
</ol>
<p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。如下图所示就是这样的一个状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135101.png" alt="备库还没收到 trx3"></p>
<p>这时，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中：</p>
<ol>
<li>trx1 和 trx2 已经传到从库，并且已经执行完成了；</li>
<li>trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li>
</ol>
<p>如果这时候你在从库 B 上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，就是出现了过期读。那么，这个问题有没有办法解决呢？</p>
<h4 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h4><p>要解决这个问题，就要引入半同步复制，也就是 semi-sync replication。semi-sync 做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。此时可以来讨论一个问题，如果主库掉电的时候，有些 binlog 还来不及发给从库，会不会导致系统数据丢失？答案是，如果使用的是普通的异步复制模式，就可能会丢失，但 semi-sync 就可以解决这个问题。</p>
<p>这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。但是，semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ol>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ol>
<p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。为什么这么说呢？我们来看一下这个时序图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135105.png" alt="主备持续延迟一个事务"></p>
<p>上图中，就是等待位点方案的一个 bad case。图中备库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，从状态 1 到状态 4，一直处于延迟一个事务的状态。备库 B 一直到状态 4 都和主库 A 存在延迟，如果用上面必须等到无延迟才能查询的方案，select 语句直到状态 4 都不能被执行。但是，其实客户端是在发完 trx1 更新后发起的 select 语句，我们只需要确保 trx1 已经执行完成就可以执行 select 语句了。也就是说，如果在状态 3 执行查询请求，得到的就是预期结果了。</p>
<h5 id="semi-sync-判断主备无延迟的方案的问题："><a href="#semi-sync-判断主备无延迟的方案的问题：" class="headerlink" title="semi-sync + 判断主备无延迟的方案的问题："></a>semi-sync + 判断主备无延迟的方案的问题：</h5><ul>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ul>
<h4 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h4><p>要理解等主库位点方案，需要先介绍一条命令：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select master_pos_wait(file, pos[, timeout]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这条命令的逻辑如下：</p>
<ol>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ol>
<p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：</p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ol>
<p>对于前面图中先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p>
<ol>
<li>trx1 事务更新完成后，马上执行 <code>show master status</code> 得到当前主库执行到的 File 和 Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 <code>select master_pos_wait(File, Position, 1);</code></li>
<li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135109.png" alt="master_pos_wait 方案"></p>
<p>这里我们假设，这条 select 查询最多在从库上等待 1 秒。那么，如果 1 秒内 <code>master_pos_wait</code> 返回一个大于等于 0 的整数，就确保了从库上执行的这个查询结果一定包含了 trx1 的数据。</p>
<p>步骤 5 到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。如果所有的从库都延迟超过 1 秒了，那查询压力不就都跑到主库上了吗？确实是这样。但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p>
<h4 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h4><p>如果你的数据库开启了 GTID 模式，对应的也有等待 GTID 的方案。MySQL 中同样提供了一个类似的命令：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">select wait_for_executed_gtid_set(gtid_set, 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这条命令的逻辑是：</p>
<ol>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ol>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 <code>show master status</code>。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。这时，等 GTID 的执行流程就变成了：</p>
<ol>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 <code>select wait_for_executed_gtid_set(gtid1, 1);</code> </li>
<li>如果返回值是 0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135112.png" alt="wait_for_executed_gtid_set 方案"></p>
<p>在上面的第一步中，trx1 事务更新完成后，从返回包直接获取这个事务的 GTID。问题是，怎么能够让 MySQL 在执行事务后，返回包中带上 GTID 呢？只需要将参数 <code>session_track_gtids</code> 设置为 <code>OWN_GTID</code>，然后通过 API 接口 <code>mysql_session_track_get_first</code> 从返回包解析出 GTID 的值即可。</p>
<p>类似的 <code>mysql_reset_connection</code> 也存在这类 API 接口，那么这类接口应该怎么使用呢？其实，MySQL 并没有提供这类接口的 SQL 用法，是提供给程序的 <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html" target="_blank" rel="noopener">API</a>。比如，为了让客户端在事务提交后，返回的 GITD 能够在客户端显示出来，可以对 MySQL 客户端代码做点修改，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135114.png" alt="显示更新事务的 GTID-- 代码"></p>
<p>这样，就可以看到语句执行完成，显示出 GITD 的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135119.png" alt="显示更新事务的 GTID-- 效果"></p>
<p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用 <code>mysql_session_track_get_first</code> 这个函数。</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>假设系统采用了等 GTID 的方案，现在要对主库的一张大表做 DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p>
<p>假设，这条语句在主库上要执行 10 分钟，提交后传到备库就要 10 分钟（典型的大事务）。那么，在主库 DDL 之后再提交的事务的 GTID，去备库查的时候，就会等 10 分钟才出现。这样，这个读写分离机制在这 10 分钟之内都会超时，然后走主库。</p>
<ul>
<li>这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做 DDL。等备库延迟追上以后，再把读请求切回备库。所以大事务对等位点方案的影响挺大的。当然了，使用 gh-ost 方案来解决这个问题也是不错的选择。</li>
<li>另外，也可以使用前面提到的现在先从库中执行 DDL 然后切换主备再执行的方式进行。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。即使是最后等待位点和等待 GTID 这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增大，把主库打挂了呢？</p>
<p>其实，在实际应用中，这几个方案是可以混合使用的。比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p>
<h2 id="如何检测一个数据库是否有问题"><a href="#如何检测一个数据库是否有问题" class="headerlink" title="如何检测一个数据库是否有问题"></a>如何检测一个数据库是否有问题</h2><p>在一主一备的双 M 架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由 HA 系统发起的。那么怎么判断一个主库出问题了？连上 MySQL，执行个 select 1 就好了。但是 select 1 成功返回了，就表示主库没问题吗？</p>
<h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><p>实际上，select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，我们来看一下这个场景。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">set global innodb_thread_concurrency=3;

CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t values(1,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135122.png" alt="查询 blocked"></p>
<p>我们设置 <code>innodb_thread_concurrency</code> 参数的目的是，控制 InnoDB 的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB 在接收到新请求的时候，就会进入等待状态，直到有线程退出。这里把 <code>innodb_thread_concurrency</code> 设置成 3，表示 InnoDB 只允许 3 个线程并行执行。</p>
<p>而在我们的例子中，前三个 session 中的 sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大查询。 session D 里面，<code>select 1</code> 是能执行成功的，但是查询表 t 的语句会被堵住。也就是说，如果这时候我们用 select 1 来检测实例是否正常的话，是检测不出问题的。</p>
<p>在 InnoDB 中，<code>innodb_thread_concurrency</code> 这个参数的默认值是 0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的。因为，一个机器的 CPU 核数有限，线程全冲进来，上下文切换的成本就会太高。所以，通常情况下，我们建议把 <code>innodb_thread_concurrency</code> 设置为 64~128 之间的值。</p>
<blockquote>
<p>另外，这里有一个常见的问题，空间满之后，发现数据库连接不上了，更不用说想做什么删除动作了。其实空间满本身是不会导致连不上的。但是因为空间满，事务无法提交，可能会导致接下来外部事务重试，新重试的业务还是堵在提交阶段，持续累积可能会把连接数用满达到最大连接数。</p>
</blockquote>
<ol>
<li><p>但是线上的并发连接数动不动就上千了，并发线程上限数设置为 128 够吗？这里面涉及到了两个概念，一个是并发连接，一个是并发查询，而<code>innodb_thread_concurrency</code>设置的就是并发查询的线程数，它和并发连接线程数没有直接关系。在 <code>show processlist</code> 的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。</p>
</li>
<li><p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是 CPU 杀手。这也是为什么我们需要设置 <code>innodb_thread_concurrency</code> 参数的原因（连接着的不一定在执行，只有执行的才会占用 CPU 时间，产生上下文切换）。</p>
</li>
<li><p>那在热点更新和死锁检测的时候，如果把 <code>innodb_thread_concurrency</code> 设置为 128 的话，那么出现同一行热点更新的问题时，是不是很快就把 128 消耗完了，这样整个系统是不是就挂了呢？实际上，在线程进入锁等待以后，并发线程的计数会减一，也就是说等行锁（也包括间隙锁）的线程是不算在 128 里面的。MySQL 这样设计是非常有意义的。因为，进入锁等待的线程已经不吃 CPU 了；更重要的是，必须这么设计，才能避免整个系统锁死。为什么呢？假设处于锁等待的线程也占并发线程的计数，你可以设想一下这个场景：</p>
<ol>
<li>线程 1 执行 <code>begin; update t set c=c+1 where id=1</code>, 启动了事务 trx1， 然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面。</li>
<li>线程 2 到线程 129 都执行 <code>update t set c=c+1 where id=1;</code> 由于等行锁，进入等待状态。这样就有 128 个线程处于等待状态；</li>
<li>如果处于锁等待状态的线程计数不减一，InnoDB 就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程 1 不能提交事务。而另外的 128 个线程又处于锁等待状态，整个系统就堵住了。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135126.png" alt="系统锁死状态（假设等行锁的语句占用并发计数）"></p>
<p>这时候 InnoDB 不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此时占用的 CPU 却是 0，而这明显不合理。所以，我们说 InnoDB 在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减 1 的设计，是合理而且是必要的。</p>
</li>
</ol>
<p><strong>虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如我们上面例子中前三个事务中的 <code>select sleep(100) from t</code>，还是要算进并发线程的计数的</strong>。在这个例子中，同时在执行的语句超过了设置的 <code>innodb_thread_concurrency</code> 的值，这时候系统其实已经不行了，但是通过 <code>select 1</code> 来检测系统，MySQL 却是正常返回的，此时 HA 会认为数据库还是正常的。因此，我们使用 <code>select 1</code> 的判断逻辑要修改一下。</p>
<h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，我们需要找一个访问 InnoDB 的场景。一般的做法是，在系统库（mysql 库）里创建一个表，比如命名为 <code>health_check</code>，里面只放一行数据，然后定期执行：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> select * from mysql.health_check; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。但是，我们马上还会碰到下一个问题，即：空间满了以后，这种方法又会变得不好使。</p>
<p>更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的（只要读操作不涉及事务提交。例如如果没有显示开启事务，<code>select</code> 语句不会产生事务提交）。因此，我们还是把这条监控语句再改进一下。接下来，我们就看看把查询语句改成更新语句后的效果。</p>
<h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个 <code>timestamp</code> 字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> insert into mysql.health_check(id, t_modified) values (1, now()) on duplicate key update t_modified=now();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。但，备库的检测也是要写 binlog 的。由于我们一般会把数据库 A 和 B 的主备关系设计为双 M 结构，所以在备库 B 上执行的检测命令，也要发回给主库 A。</p>
<p>但是，如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突（主备都是空表的时候），也就是可能会导致主备同步停止。所以，现在看来 <code>mysql.health_check</code> 这个表就不能<strong>只有一行数据</strong>了。</p>
<p>为了让主备之间的更新不产生冲突，我们可以在 <code>mysql.health_check</code> 表上存入多行数据，并用 A、B 的 <code>server_id</code> 做主键。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> CREATE TABLE `health_check` (
  `id` int(11) NOT NULL,
  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

/* 检测命令 */
insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，“判定慢”一直是让 DBA 头疼的问题。</p>
<h4 id="“判定慢”问题"><a href="#“判定慢”问题" class="headerlink" title="“判定慢”问题"></a>“判定慢”问题</h4><p>更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定慢的问题呢？其实，这里涉及到的是服务器 IO 资源分配的问题。</p>
<ol>
<li>首先，所有的检测逻辑都需要一个超时时间 N。执行一条 <code>update</code> 语句，超过 N 秒后还不返回，就认为系统不可用。</li>
<li>可以设想一个日志盘的 IO 利用率已经是 100% 的场景。这时候，整个系统响应非常慢，已经需要做主备切换了。</li>
<li>但是 IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而我们的检测使用的 <code>update</code> 命令，<strong>需要的资源很少</strong>，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。</li>
<li>检测系统一看，<code>update</code> 命令没有超时，于是就得到了“系统正常”的结论。</li>
</ol>
<p>也就是说，这时候在业务系统上正常的 SQL 语句已经执行得很慢了，但是 DBA 上去一看，HA 系统还在正常工作，并且认为主库现在处于可用状态。之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。因为，外部检测都需要<strong>定时轮询</strong>，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，我们才有可能发现问题。而且，如果你的运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。所以，接下来我要再和你介绍一种在 MySQL 内部发现数据库问题的方法。</p>
<h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>针对磁盘利用率这个问题，如果 MySQL 可以告诉我们，内部每一次 IO 请求的时间，那我们判断数据库是否出问题的方法就可靠得多了。其实，MySQL 5.6 版本以后提供的 <code>performance_schema</code> 库，就在 <code>file_summary_by_event_name</code> 表里统计了每次 IO 请求的时间。<code>file_summary_by_event_name</code> 表里有很多行数据，我们先来看看 <code>event_name=&#39;wait/io/file/innodb/innodb_log_file’</code>这一行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135133.png" alt="performance_schema.file_summary_by_event_name 的一行"></p>
<ul>
<li>这一行表示统计的是 redo log 的写入时间，第一列 <code>EVENT_NAME</code> 表示统计的类型。</li>
<li>接下来的三组数据，显示的是 redo log 操作的时间统计。<ul>
<li>第一组五列，是所有 IO 类型的统计。其中，<code>COUNT_STAR</code> 是所有 IO 的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀 <code>SUM</code>、<code>MIN</code>、<code>AVG</code>、<code>MAX</code>，顾名思义指的就是总和、最小值、平均值和最大值。</li>
<li>第二组六列，是读操作的统计。最后一列 <code>SUM_NUMBER_OF_BYTES_READ</code> 统计的是，总共从 redo log 里读了多少个字节。</li>
<li>第三组六列，统计的是写操作。</li>
</ul>
</li>
<li>最后的第四组数据，是对其他类型数据的统计。在 redo log 里，你可以认为它们就是对 fsync 的统计。</li>
</ul>
<p>在 <code>performance_schema</code> 库的 <code>file_summary_by_event_name</code> 表里，binlog 对应的是 <code>event_name = &quot;wait/io/file/sql/binlog&quot;</code>这一行。各个字段的统计逻辑，与 redo log 的各个字段完全相同。</p>
<p>因为我们每一次操作数据库，<code>performance_schema</code> 都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗的。丁大的测试结果是，如果打开所有的 <code>performance_schema</code> 项，性能大概会下降 10% 左右。所以，建议只打开自己需要的项进行统计。可以通过下面的方法打开或者关闭某个具体项的统计。</p>
<p>如果要打开 redo log 的时间监控，你可以执行这个语句：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> update setup_instruments set ENABLED='YES', Timed='YES' where name like '%wait/io/file/innodb/innodb_log_file%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>假设，现在你已经开启了 redo log 和 binlog 这两个统计信息，那要怎么把这个信息用在实例状态诊断上呢？很简单，你可以通过 <code>MAX_TIMER</code> 的值来判断数据库是否出问题了。比如，你可以设定阈值，单次 IO 请求时间超过 200 毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> select event_name,MAX_TIMER_WAIT  FROM performance_schema.file_summary_by_event_name where event_name in ('wait/io/file/innodb/innodb_log_file','wait/io/file/sql/binlog') and MAX_TIMER_WAIT>200*1000000000;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>发现异常后，取到你需要的信息，再通过下面这条语句：</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">mysql> truncate table performance_schema.file_summary_by_event_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>看完后可能会觉得，<code>select 1</code> 这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的 MHA（Master High Availability），默认使用的就是这个方法。MHA 中的另一个可选方法是只做连接，就是 “如果连接成功就认为主库没问题”。不过选择这个方法的很少。其实，每个改进的方案，都会增加额外损耗，并不能用“对错”做直接判断，需要你根据业务实际情况去做权衡。丁大个人比较倾向的方案，是优先考虑 <code>update</code> 系统表，然后再配合增加检测 <code>performance_schema</code> 的信息。</p>
<h1 id="如何处理误删数据情况"><a href="#如何处理误删数据情况" class="headerlink" title="如何处理误删数据情况"></a>如何处理误删数据情况</h1><p>前面提到的传统高可用架构是不能预防误删数据的，因为主库的一个 <code>drop table</code> 命令，会通过 binlog 传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。我们需要先对和 MySQL 相关的误删数据，做下分类：</p>
<ol>
<li>使用 <code>delete</code> 语句误删数据行；</li>
<li>使用 <code>drop table</code> 或者 <code>truncate table</code> 语句误删数据表；</li>
<li>使用 <code>drop database</code> 语句误删数据库；</li>
<li>使用 <code>rm</code> 命令误删整个 MySQL 实例。</li>
</ol>
<h2 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h2><p>如果是使用 delete 语句误删了数据行，可以用 <a href="https://mariadb.com/kb/en/flashback/" target="_blank" rel="noopener">Flashback</a> 工具通过闪回把数据恢复回来。Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保 <code>binlog_format=row</code> 和 <code>binlog_row_image=FULL</code>。</p>
<p>具体恢复数据时，对单个事务做如下处理：</p>
<ol>
<li>对于 <code>insert</code> 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可；</li>
<li>同理，对于 <code>delete</code> 语句，也是将 Delete_rows event 改为 Write_rows event；</li>
<li>而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li>
</ol>
<p>如果误操作不是一个，而是多个，如：</p>
<pre><code>(A)delete ...
(B)insert ...
(C)update ...</code></pre><p>现在要把数据库恢复回这三个事务操作之前的状态，用 Flashback 工具解析 binlog 后，写回主库的命令是：</p>
<pre><code>(reverse C)update ...
(reverse B)delete ...
(reverse A)insert ...</code></pre><p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p>
<h3 id="注意不要直接在主库上恢复"><a href="#注意不要直接在主库上恢复" class="headerlink" title="注意不要直接在主库上恢复"></a>注意不要直接在主库上恢复</h3><p>需要说明的是，不建议直接在主库上执行这些操作。<strong>恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库</strong>。</p>
<p>为什么要这么做呢？这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>当然，我们不止要说误删数据的事后处理办法，更重要是要做到事前预防。有以下两个建议：</p>
<ol>
<li>把 <code>sql_safe_updates</code> 参数设置为 on。这样一来，如果我们忘记在 <code>delete</code> 或者 <code>update</code> 语句中写 <code>where</code> 条件，或者 <code>where</code> 条件里面没有包含索引字段的话，这条语句的执行就会报错。</li>
<li>代码上线前，必须经过 SQL 审计。</li>
</ol>
<p>设置了 <code>sql_safe_updates=on</code>，如果真的要把一个小表的数据全部删掉，应该怎么办呢？如果确定这个删除操作没问题的话，可以在 <code>delete</code> 语句中加上 <code>where</code> 条件，比如 <code>where id&gt;=0</code>。但是，<code>delete</code> 全表是很慢的，需要生成回滚日志、写 redo、写 binlog。所以，从性能角度考虑，应该优先考虑使用 <code>truncate table</code> 或者 <code>drop table</code> 命令。</p>
<h2 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库/表"></a>误删库/表</h2><p>使用 <code>delete</code> 命令删除的数据，还可以用 Flashback 来恢复。而使用 <code>truncate</code> /<code>drop table</code> 和 <code>drop database</code> 命令删除的数据，就没办法通过 Flashback 来恢复了。为什么呢？这是因为，即使我们配置了 <code>binlog_format=row</code>，执行这三个命令时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 <code>truncate</code>/<code>drop</code> 语句，这些信息是恢复不出数据的。那么，如果我们真的是使用这几条命令误删数据了，又该怎么办呢？这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。<strong>这个方案要求线上有定期的全量备份，并且实时备份 binlog</strong>。</p>
<p>在这两个条件都具备的情况下，假如有人中午 12 点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li>
<li>用全量备份恢复出一个临时库；</li>
<li>从日志备份里面，取出凌晨 0 点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<p>这个流程的示意图如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135141.png" alt="数据恢复流程 -mysqlbinlog 方法"></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用 <code>mysqlbinlog</code> 命令时，加上一个<code>–database</code> 参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li>
<li>在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog：<ul>
<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用<code>–stop-position</code> 参数执行到误操作之前的日志，然后再用<code>–start-position</code> 从误操作之后的日志继续执行；</li>
<li>如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 <code>set gtid_next=gtid1;begin;commit;</code> 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。</li>
</ul>
</li>
</ol>
<p>不过，即使这样，使用 mysqlbinlog 方法恢复数据还是不够快，主要原因有两个：</p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志；</li>
<li>用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。前面介绍的关于备库同步主库的那些并行复制的方法，在这里都用不上。</li>
</ol>
<h3 id="加速恢复"><a href="#加速恢复" class="headerlink" title="加速恢复"></a>加速恢复</h3><p>一种加速的方法是，<strong>在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库</strong>：在 <code>start slave</code> 之前，先通过执行﻿﻿<code>change replication filter replicate_do_table = (tbl_name)</code> 命令，就可以让临时库只同步误操作的表；这样做也可以用上并行复制技术，来加速整个数据恢复过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201221135144.png" alt="数据恢复流程 -master-slave 方法"></p>
<p>可以看到，图中 binlog 备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的 binlog 的话，我们可以从 binlog 备份系统中找到需要的 binlog，再放回备库中。</p>
<p>假设，我们发现当前临时实例需要的 binlog 是从 master.000005 开始的，但是在备库上执行 show binlogs 显示的最小的 binlog 文件是 master.000007，意味着少了两个 binlog 文件。这时，我们就需要去 binlog 备份系统中找到这两个文件。</p>
<p>把之前删掉的 binlog 放回备库的操作步骤，是这样的：</p>
<ol>
<li>从备份系统下载 master.000005 和 master.000006 这两个文件，放到备库的日志目录下；</li>
<li>打开日志目录下的 master.index 文件，在文件开头加入两行，内容分别是 “./master.000005”和“./master.000006”;</li>
<li>重启备库，目的是要让备库重新识别这两个日志文件；</li>
<li>现在这个备库上就有了临时库需要的所有 binlog 了，建立主备关系，就可以正常同步了。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>不论是把 mysqlbinlog 工具解析出的 binlog 文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用 binlog 的方式。也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保 binlog 在被从本地删除之前已经做了备份。</p>
<p>但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留的天数。如果你的 DBA 团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就表示备份系统保留的日志时间就至少是半个月。</p>
<p>另外，建议你不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿出来演练。为什么这么说呢？这里的原因，主要包括两个方面：虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失降到最小，也应该不用跑路了。而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过去了。</p>
<h2 id="临时实例恢复完成后的工作"><a href="#临时实例恢复完成后的工作" class="headerlink" title="临时实例恢复完成后的工作"></a>临时实例恢复完成后的工作</h2><p>以上提到的都是恢复误删数据前的数据库状态到一个临时库中的动作，完成之后我们还有确认恢复是否成功。确认之后即可以从临时库恢复数据到线上库了，操作随着情况的不同也不同：</p>
<ul>
<li><p>如果原库是误删了一些行，那只能在临时库里面select数据出来，按照业务的需要去补了</p>
</li>
<li><p>如果原库是删表(例如 truncate)，就把临时库里面的表导过去，小表逻辑导，大表可以用“透明表空间机制”物理导；</p>
<ol>
<li>创建一个同版本的空 MySQL 实例，建一个名字 + 结构一模一样的表</li>
<li>discard这个表的 tablespace</li>
<li>从之前的备份集中 <code>innobackupex --apply-log</code> 并记录binlog位置（用innobackupex备份的）。还原后找到误操作表的.ibd文件，copy到新实例对应的位置</li>
<li>之前创建的 MySQL 实例上 import tablespace</li>
<li>利用 mysqlbinlog 处理增量数据</li>
<li>最后导出 再导入</li>
</ol>
</li>
</ul>
<h2 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h2><p>虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第 6 天发生误操作，那就需要恢复 6 天的日志，这个恢复时间可能是要按天来计算的。那么，我们有什么方法可以缩短恢复数据需要的时间呢？</p>
<p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑预先搭建延迟复制的备库。这个功能是 MySQL 5.6 版本引入的。一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。延迟复制的备库是一种特殊的备库，通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code> 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。</p>
<p>比如你把 N 设置为 3600，这就代表了如果主库上有数据被误删了，并且在 1 小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行 <code>stop slave</code>，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这样的话，你就随时可以得到一个，只需要最多再追 1 小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p>
<h2 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库 / 表的方法"></a>预防误删库 / 表的方法</h2><p>虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，也会给一些减少误删操作风险的建议。</p>
<ol>
<li>第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：<ul>
<li>我们只给业务开发同学 DML 权限，而不给 <code>truncate</code>/<code>drop</code> 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。</li>
<li>即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>
</ul>
</li>
<li>第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：<ul>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>
<li>改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>
</ul>
</li>
</ol>
<h2 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h2><p>其实，对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。当然了，现在不止是 DBA 有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个 MySQL 集群的所有节点都全军覆没。应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《mysql学习笔记：高可用》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/02/16/mysql/gao-ke-yong/" property="cc:attributionName"
               rel="cc:attributionURL">
                阿钟
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '466e387c08bce10f3f28',
        clientSecret: '5b2bf16f8a42bd72eef32e50187c7f2ccb105a1d',
        repo: 'azhong.github.io',
        owner: 'JohnZhongg',
        admin: "JohnZhongg",
        id: '2020/02/16/mysql/gao-ke-yong/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/16/web-qian-duan/xue-xi-qian-duan-zi-liao-ji-lu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="学习前端资料记录">
                        
                        <span class="card-title">学习前端资料记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            测试概述
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-02-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/web前端/" class="post-category" target="_blank">
                                    web前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/学习资料/" target="_blank">
                        <span class="chip bg-color">学习资料</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/16/mq/rabbitmq/untitled/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="rabbit mq 学习总结记录">
                        
                        <span class="card-title">rabbit mq 学习总结记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            rabbit mq 学习记录
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-02-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/rabbit-mq/" class="post-category" target="_blank">
                                    rabbit mq
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/mq/" target="_blank">
                        <span class="chip bg-color">mq</span>
                    </a>
                    
                    <a href="/tags/rabbit-mq/" target="_blank">
                        <span class="chip bg-color">rabbit mq</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2020- Azhong. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">631.5k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JohnZhongg" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:707845008@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/change-94-17" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=707845008&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


<!-- 


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 0;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 12, 20, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>