<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2020/09/24/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/xian-cheng-mo-xing/"/>
      <url>/2020/09/24/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/23/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/16-gao-xiao-bing-fa/"/>
      <url>/2020/09/23/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/16-gao-xiao-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>“让计算机并发执行若干个运算任务”与“更充分地利用计算机处理器的效能”之间的因果关系,看起来理所当然,实际上它们之间的关系并没有想象中那么简单,其中一个重要的复杂性的来源是绝大多数的运算任务都不可能只靠处理器“计算”就能完成。处理器至少要与内存交互,如读取运算数据、存储运算结果等,这个I/O操作就是很难消除的(无法仅靠寄存器来完成所有运算任务)。由于计算机的存储设备与处理器的运算速度有着几个数量级的差距,所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲:将运算需要使用的数据复制到缓存中,让运算能快速进行,当运算结束后再从缓存同步回内存之中,这样处理器就无须等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾,但是也为计算机系统带来更高的复杂度,它引入了一个新的问题:缓存一致性(Cache Coherence)。在多路处理器系统中,每个处理器都有自己的高速缓存,而它们又共享同一主内存(Main Memory),这种系统称为共享内存多核系统(Shared Memory Multiprocessors System),如图12-1所示。当多个处理器的运算任务都涉及同一块主内存区域时,将可能导致各自的缓存数据不一致。如果真的发生这种情况,那同步回到主内存时该以谁的缓存数据为准呢?为了解决一致性的问题,需要各个处理器访问缓存时都遵循一些协议,在读写时要根据协议来进行操作,这类协议有MSI、MESI(Illinois Protocol)、MOSI、Synapse、Firefly及Dragon Protocol等。“内存模型”可以理解为在特定的操作协议下,对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型,而Java虚拟机也有自己的内存模型,并且与这里介绍的内存访问操作及硬件的缓存访问操作具有高度的可类比性。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121204.png" alt="image-20200923160311060"></p><p>除了增加高速缓存之外,为了使处理器内部的运算单元能尽量被充分利用,<strong>处理器可能会对输入代码进行乱序执行</strong>(Out-Of-Order Execution)优化,处理器会在计算之后将乱序执行的结果重组,保证该结果与顺序执行的结果是一致的,但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致,因此如果存在一个计算任务依赖另外一个计算任务的中间结果,那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似,<strong>Java虚拟机的即时编译器中也有指令重排序(Instruction Reorder)优化</strong>。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>《Java虚拟机规范》[^1]中曾试图定义一种“Java内存模型”[^2] (Java Memory Model,JMM)来屏蔽各种硬件和操作系统的内存访问差异,以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前,主流程序语言(如C和C++等)直接使用物理硬件和操作系统的内存模型。因此,由于不同平台上内存模型的差异,有可能导致程序在一套平台上并发完全正常,而在另外一套平台上并发访问却经常出错,所以在某些场景下必须针对不同的平台来编写程序。</p><p>定义Java内存模型并非一件容易的事情,这个模型必须定义得足够严谨,才能让Java的并发内存访问操作不会产生歧义;但是也必须定义得足够宽松,使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性(寄存器、高速缓存和指令集中某些特有的指令)来获取更好的执行速度。经过长时间的验证和修补,直至JDK 5(实现了JSR-133<a href="此处所讲的“复杂”与“程序自己完成线程操作”,并不限于程序直接编写了复杂的实现用户线程的代码,使用用户线程的程序时,很多都依赖特定的线程库来完成基本的线程操作,这些复杂性都封装在线程库之中。">^3</a>)发布后,Java内存模型才终于成熟、完善起来了</p><p>[^1]: 在《Java虚拟机规范》的第2版及之前,专门有一章“Threads and Locks”来描述内存模型,后来由于这部分内容难以把握宽紧限度,被反复修正更新,从第3版(Java SE 7版)开始索性就被移除出规范, 独立以JSR形式维护。<br>[^2]: 在JDK 1.2之后建立起来并在JDK 5中完善过的内存模型，就是指前面笔记中的内存部分的结构<br><a href="此处所讲的“复杂”与“程序自己完成线程操作”,并不限于程序直接编写了复杂的实现用户线程的代码,使用用户线程的程序时,很多都依赖特定的线程库来完成基本的线程操作,这些复杂性都封装在线程库之中。">^3</a>: JSR-133:Java Memory Model and Thread Specification Revision(Java内存模型和线程规范修订)。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p><strong>Java内存模型的主要目的是定义程序中各种变量的访问规则,即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</strong>。此处的变量(Variables)与Java编程中所说的变量有所区别,它包括了实例字段、静态字段和构成数组对象的元素,但是不包括局部变量与方法参数,因为后者是线程私有的<a href="如果局部变量是一个reference类型,它引用的对象在Java堆中可被各个线程共享,但是reference本身在Java栈的局部变量表中是线程私有的。">^4</a>,不会被共享,自然就不会存在竞争问题。为了获得更好的执行效能,Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互,也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。</p><p>Java内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与介绍物理硬件时提到的主内存名字一样,两者也可以类比,但物理上它仅是虚拟机内存的一部分)。<strong>每条线程还有自己的工作内存</strong>(Working Memory,可与前面讲的处理器高速缓存类比),线程的工作内存中保存了被该线程使用的变量的主内存副本<a href="“假设线程中访问一个10MB大小的对象,也会把这10MB的内存复制一份出来吗?”,事实上并不会如此,这个对象的引用、对象中某个在线程访问到的字段是有可能被复制的,但不会有虚拟机把整个对象复制一次。">^5</a>,线程对变量的所有操作(<strong>读取、赋值</strong>等)都必须在工作内存中进行,而不能直接读写主内存中的数据[^6]。<strong>不同的线程之间也无法直接访问对方工作内存中的变量,线程间变量值的传递均需要通过主内存来完成</strong>,线程、主内存、工作内存三者的交互关系如图</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121205.png" alt="image-20200923192052109"></p><p><strong>这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分</strong>,这两者基本上是没有任何关系的。如果两者一定要勉强对应起来,那么从变量、主内存、工作内存的定义来看,主内存主要对应于Java堆中的对象实例数据部分[^7],而工作内存则对应于<strong>虚拟机栈中的部分区域</strong>。<strong>从更基础的层次上说,主内存直接对应于物理硬件的内存,而为了获取更好的运行速度,虚拟机(或者是硬件、操作系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中,因为程序运行时主要访问的是工作内存</strong>。</p><p>[^6]: 根据《Java虚拟机规范》的约定,volatile变量依然有工作内存的拷贝,但是由于它特殊的操作顺序性规定(后文会讲到),所以看起来如同直接在主内存中读写访问一般,因此这里的描述对于volatile 也并不存在例外。<br>[^7]: 除了实例数据,Java堆还保存了对象的其他信息,对于HotSpot虚拟机来讲,有Mark Word(存储对象哈希码、GC标志、GC年龄、同步锁等信息)、Klass Point(指向存储类型元数据的指针)及一些用于字节对齐补白的填充数据(如果实例数据刚好满足8字节对齐,则可以不存在补白)。</p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议,即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节,Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的<strong>每一种操作都是原子的、不可再分的</strong>(对于double和long类型的变量来说, load、store、read和write操作在某些平台上允许有例外)<a href="基于理解难度和严谨性考虑,最新的JSR-133文档中,已经放弃了采用这8种操作去定义Java内存模型的访问协议,缩减为4种(仅是描述方式改变了,Java内存模型并没有改变)。">^8</a>。</p><ul><li>lock(锁定):作用于主内存的变量,它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁):作用于主内存的变量,它把一个处于锁定状态的变量释放出来,<strong>释放后的变量才可以被其他线程锁定</strong>。</li><li>read(读取):作用于主内存的变量,它把一个变量的值从主内存传输到线程的工作内存中,以便随后的load动作使用(<strong>从主存到工作内存中的读buffer</strong>)。</li><li>load(载入):作用于工作内存的变量,它把read操作从主内存中得到的变量值放入工作内存的变量副本中(<strong>从工作内存中的读buffer到工作内存中的缓存</strong>)。</li><li>use(使用):作用于工作内存的变量,它把工作内存中一个变量的值传递给执行引擎,每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作(<strong>从工作内存到ALU寄存器</strong>)。</li><li>assign(赋值):作用于工作内存的变量,它把一个从执行引擎接收的值赋给工作内存的变量, 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作(<strong>从ALU寄存器到工作内存</strong>)。</li><li>store(存储):作用于工作内存的变量,它把工作内存中一个变量的值传送到主内存中,以便随后的write操作使用(<strong>从工作内存中的缓存到工作内存中的写buffer</strong>)。</li><li>write(写入):作用于主内存的变量,它把store操作从工作内存中得到的变量的值放入主内存的变量中(<strong>从工作内存中的写buffer到主存</strong>)。</li></ul><p>如果要把一个变量从主内存拷贝到工作内存,那就要按顺序执行read和load操作,如果要把变量从工作内存同步回主内存,就要按顺序执行store和write操作。<strong>注意,Java内存模型只要求上述两个操作必须按顺序执行,但不要求是连续执行。</strong>也就是说read与load之间、store与write之间是可插入其他指令的,如对主内存中的变量a、b进行访问时,一种可能出现的顺序是read a、read b、load b、load a。除此之外,Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则: </p><ul><li>不允许read和load、store和write操作之一单独出现,即不允许一个变量从主内存读取了但工作内存不接受,或者工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作,即变量<strong>在工作内存中改变了之后必须把该变化同步回主内存</strong>(在工作内存中发生了变化必须同步回主存，无论何时同步)。</li><li>不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中(没有发生变化不能同步)。</li><li>一个新的变量只能在主内存中“诞生”,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量,换句话说就是对一个变量实施use、store操作之前,必须先执行assign和load操作？</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作,但lock操作可以被同一条线程重复执行多次,多次执行lock后,只有执行相同次数的unlock操作,变量才会被解锁。</li><li><strong>如果对一个变量执行lock操作,那将会清空工作内存中此变量的值</strong>,在执行引擎使用这个变量前,需要重新执行load或assign操作以初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定,那就不允许对它执行unlock操作,也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前,必须先把此变量同步回主内存中(执行store、write操作)。</li></ul><p>这8种内存访问操作以及上述规则限定,再加上稍后会介绍的专门针对volatile的一些特殊规定,就已经能准确地描述出Java程序中哪些内存访问操作在并发下才是安全的。这种定义相当严谨,但也是极为烦琐,实践起来更是无比麻烦。可能部分读者阅读到这里已经对多线程开发产生恐惧感了,后来Java设计团队大概也意识到了这个问题,将Java内存模型的操作简化为read、write、lock和unlock四种,但这只是语言描述上的等价化简,Java内存模型的基础设计并未改变,即使是这四种操作,对于普通用户来说阅读使用起来仍然并不方便。不过除了进行虚拟机开发的团队外,大概没有其他开发人员会以这种方式来思考并发问题,我们只需要理解Java内存模型的定义即可。后面将介绍这种定义的一个等效判断原则——先行发生原则,用来确定一个操作在并发环境下是否安全的。</p><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字<code>volatile</code>可以说是Java虚拟机提供的最轻量级的同步机制，它和<code>synchronized</code>具有不同的语义。</p><p>Java内存模型为<code>volatile</code>专门定义了一些特殊的访问规则,在介绍这些比较拗口的规则定义之前, 先用一些不那么正式,但通俗易懂的语言来介绍一下这个关键字的作用。<br>当一个变量被定义成<code>volatile</code>之后,它将具备两项特性:</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>第一项是保证此变量对所有线程的可见性,这里的“可见性”是指当一条线程修改了这个变量的值,新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点,普通变量的值在线程间传递时均需要通过主内存来完成。比如, 线程A修改一个普通变量的值,然后向主内存进行回写,另外一条线程B在线程A回写完成了之后再对主内存进行读取操作,新变量值才会对线程B可见(也就是说线程B如果在线程A回写完成之前读取变量那么得到的还是旧值)。</p><p>关于<code>volatile</code>变量的可见性,经常会被开发人员误解,他们会误以为下面的描述是正确的:“volatile 变量对所有线程是立即可见的,对volatile变量所有的写操作都能立刻反映到其他线程之中。换句话说,volatile变量在各个线程中是一致的,所以基于volatile变量的运算在并发下是线程安全的”。这句话的论据部分并没有错,但是由其论据并不能得出“基于volatile变量的运算在并发下是线程安全的”这样的结论</p><p><strong>volatile变量在各个线程的工作内存中是不存在一致性问题的</strong>(<strong><em>从物理存储的角度看,各个线程的工作内存中volatile变量也可以存在不一致的情况,但由于每次使用之前都要先刷新,执行引擎看不到不一致的情况,因此可以认为不存在一致性问题</em></strong>),但是Java里面的运算操作符并非原子操作, 这导致<code>volatile</code>变量的运算在并发下一样是不安全的,最经典的就是<code>var++</code>的例子，即使在源代码上是一行代码，但是经过编译到底层后就是很多行指令了：</p><ul><li>主存中存在变量<code>var</code>被<code>volatile</code>修饰</li><li>线程A读取变量<code>var</code>，必须从主存中获取最新值，此时经过<code>read</code>、<code>load</code>获取到值为1然后加载到工作内存，执行引擎<code>use</code>开始+1计算</li><li>此时切换到了线程B，同样从主存加载<code>var</code>值到工作内存，此时还是1</li><li>此时切换回线程A，计算完毕，<code>assign</code>计算结果2到工作内存，经过<code>store</code>、<code>write</code>从工作内存回写到主存</li><li>此时再切换回线程B，同样计算完毕，执行同样操作，此时线程A计算结果被覆盖</li></ul><p>由于<code>volatile</code>变量只能保证可见性,在<strong>不符合以下两条规则的运算场景中</strong>,我们仍然要通过加锁(使用<code>synchronized</code>、<code>java.util.concurrent</code>中的锁或原子类)来保证原子性: </p><ul><li>运算结果并不依赖变量的当前值,或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>而在像以下代码所示的这类场景中就很适合使用<code>volatile</code>变量来控制并发,当<code>shutdown()</code>方法被调用时,能保证所有线程中执行的<code>doWork()</code>方法都立即停下来。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRequested<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  shutdownRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdownRequested<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 代码的业务逻辑    </span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>使用<code>volatile</code>变量的第二个语义是禁止指令重排序优化,普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果,而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点,这就是Java内存模型中描述的所谓“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)。</p><p>一个例子说明指令重排序带来的影响：</p><pre class="line-numbers language-java"><code class="language-java">Map configOptions<span class="token punctuation">;</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> configText<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此变量必须定义为volatile </span><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> initialized <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 假设以下代码在线程A中执行</span><span class="token comment" spellcheck="true">// 模拟读取配置信息,当读取完成后</span><span class="token comment" spellcheck="true">// 将initialized设置为true,通知其他线程配置可用</span>configOptions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> configText <span class="token operator">=</span> <span class="token function">readConfigFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">processConfigOptions</span><span class="token punctuation">(</span>configText<span class="token punctuation">,</span> configOptions<span class="token punctuation">)</span><span class="token punctuation">;</span> initialized <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 假设以下代码在线程B中执行</span><span class="token comment" spellcheck="true">// 等待initialized为true,代表线程A已经把配置信息初始化完成</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>initialized<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 使用线程A中初始化好的配置信息</span><span class="token function">doSomethingWithConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果定义<code>initialized</code>变量时没有使用<code>volatile</code>修饰,就可能会由于指令重排序的优化,导致位于线程A中最后一条代码<code>initialized=true</code>被提前执行(这里虽然使用Java作为伪代码,但所指的重排序优化是机器级的优化操作,提前执行是指这条语句对应的汇编代码被提前执行),这样在线程B中使用配置信息的代码就可能出现错误,而<code>volatile</code>关键字则可以避免此类情况的发生。</p><h4 id="可见性和有序性的实现"><a href="#可见性和有序性的实现" class="headerlink" title="可见性和有序性的实现"></a>可见性和有序性的实现</h4><p>下面是一个DCL实现的单例代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反汇编后对<code>instance</code>赋值如下(<code>instance</code>是工作内存里面的变量，仅仅存储的是一个引用或者<code>null</code>)：</p><pre class="line-numbers language-assembly"><code class="language-assembly">0x01a3de0f: mov    $0x3375cdb0,%esi     ;...beb0cd75 33                                                                                                                         ;   {oop('Singleton')} 0x01a3de14: mov    %eax,0x150(%esi)     ;...89865001 0000 0x01a3de1a: shr    $0x9,%esi            ;...c1ee09 0x01a3de1d: movb   $0x0,0x1104800(%esi) ;...c6860048 100100 0x01a3de24: lock addl $0x0,(%esp)       ;...f0830424 00                                                                                                                         ;*putstatic instance                                                                                                                         ; - Singleton::getInstance@24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对比发现,关键变化在于有volatile修饰的变量,赋值后(前面<code>mov %eax,0x150(%esi)</code>这句便是赋值操作)多执行了一个<code>lock addl $0x0,(%esp)</code>操作,这个操作的作用相当于一个内存屏障(Memory Barrier或Memory Fence,<strong>指重排序时不能把后面的指令重排序到内存屏障之前的位置</strong>),只有一个处理器访问内存时,并不需要内存屏障;但如果有两个或更多处理器访问同一块内存,且其中有一个在观测另一个,就需要内存屏障来保证一致性了。</p><p>这句指令中的<code>addl $0x0,(%esp)</code>(把ESP寄存器的值加0)显然是一个空操作,之所以用这个空操作而不是空操作专用指令<code>nop</code>,是因为IA32手册规定<code>lock</code>前缀不允许配合<code>nop</code>指令使用。这里的关键在于<code>lock</code>前缀,查询IA32手册可知,它的作用是将本处理器的缓存写入了内存,该写入动作也会引起别的处理器或者别的内核无效化(<code>Invalidate</code>)其缓存,这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的<code>store</code>和<code>write</code>操作[^10]。所以通过这样一个空操作,可让前面<code>volatile</code>变量的修改对其他处理器立即可见。</p><p>那为何说它禁止指令重排序呢?从硬件架构上讲,指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排,处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10,指令2 把地址A中的值乘以2,指令3把地址B中的值减去3,这时指令1和指令2是有依赖的,它们之间的顺序不能重排——(A+10)<em>2与A</em>2+10显然不相等,但指令3可以重排到指令1、2之前或者中间,只要保证处理器执行后面依赖到A、B值的操作时能获取正确的A和B值即可。所以在同一个处理器中,重排序过的代码看起来依然是有序的。因此,<code>lock addl$0x0,(%esp)</code>指令把修改同步到内存时,意味着所有之前的操作都已经执行完成(即使前面的操作是乱序执行的，但是处理器会保证在单线程中它们计算得到的结果是一致的),这样便形成了“指令重排序无法越过内存屏障”的效果(<strong>这里的有序指的是在对<code>volatile</code>变量赋值之前的指令永远只会在它前面，在它后面的也永远只会在它后面</strong>)。</p><p>解决了<code>volatile</code>的语义问题,再来看看在众多保障并发安全的工具中选用<code>volatile</code>的意义——它能让我们的代码比使用其他的同步工具更快吗?在某些情况下,<code>volatile</code>的同步机制的性能确实要优于锁(使用<code>synchronized</code>关键字或<code>java.util.concurrent</code>包里面的锁),但是由于虚拟机对锁实行的许多消除和优化,使得我们很难确切地说<code>volatile</code>就会比<code>synchronized</code>快上多少。如果让<code>volatile</code>自己与自己比较,那可以确定一个原则:<code>volatile</code>变量读操作的性能消耗与普通变量几乎没有什么差别,但是写操作则可能会慢上一些,因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此,大多数场景下<code>volatile</code>的总开销仍然要比锁来得更低。我们在<code>volatile</code>与锁中选择的唯一判断依据仅仅是<code>volatile</code>的语义能否满足使用场景的需求。</p><p>现在回头来看看Java内存模型中对<code>volatile</code>变量定义的特殊规则的定义。假定<code>T</code>表示一个线程,<code>V</code>和<code>W</code>分别表示两个<code>volatile</code>型变量,那么在进行<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>操作时需要满足如下规则: </p><ul><li><p>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>load</code>的时候,线程<code>T</code>才能对变量<code>V</code>执行<code>use</code>动作(<strong>变量加载到了工作内存就要立即使用</strong>)；</p><p>并且, 只有当线程<code>T</code>对变量<code>V</code>执行的后一个动作是<code>use</code>的时候,线程<code>T</code>才能对变量<code>V</code>执行<code>load</code>动作。线程<code>T</code>对变量<code>V</code>的<code>use</code>动作。可以认为是和线程<code>T</code>对变量<code>V</code>的<code>load</code>、<code>read</code>动作相关联的,必须连续且一起出现(<strong>只有在真正使用变量的前一刻才能从主存读取变量，并且是原子性地读取</strong>)。</p><p>这条规则要求在工作内存中,每次使用<code>V</code>前都必须先从主内存刷新最新的值,用于保证能看见其他线程对变量<code>V</code>所做的修改。</p></li><li><p>只有当线程<code>T</code>对变量<code>V</code>执行的前一个动作是<code>assign</code>的时候,线程<code>T</code>才能对变量<code>V</code>执行<code>store</code>动作(<strong>如果没有修改过变量的值，不能进行值同步，防止无缘由覆盖别的线程地覆盖其他线程的修改</strong>)；</p><p>并且,只有当线程<code>T</code>对变量<code>V</code>执行的后一个动作是<code>store</code>的时候,线程<code>T</code>才能对变量<code>V</code>执行<code>assign</code>动作。线程<code>T</code>对变量<code>V</code>的<code>assign</code>动作可以认为是和线程<code>T</code>对变量<code>V</code>的<code>store</code>、<code>write</code>动作相关联的,必须连续且一起出现(<strong>只要修改了变量的值，就要立即原子性地将其同步到主存</strong>)。</p><p>这条规则要求在工作内存中,每次修改<code>V</code>后都必须立刻同步回主内存中,用于保证其他线程可以看到自己对变量<code>V</code>所做的修改。</p></li><li><p>假定动作<code>A</code>是线程<code>T</code>对变量<code>V</code>实施的<code>use</code>或<code>assign</code>动作,假定动作<code>F</code>是和动作<code>A</code>相关联的<code>load</code>或<code>store</code>动作,假定动作<code>P</code>是和动作<code>F</code>相应的对变量<code>V</code>的<code>read</code>或<code>write</code>动作；</p><p>与此类似,假定动作<code>B</code>是线程<code>T</code>对变量<code>W</code> 实施的<code>use</code>或<code>assign</code>动作,假定动作<code>G</code>是和动作<code>B</code>相关联的<code>load</code>或<code>store</code>动作,假定动作<code>Q</code>是和动作<code>G</code>相应的对变量<code>W</code>的<code>read</code>或<code>write</code>动作。如果<code>A</code>先于<code>B</code>,那么<code>P</code>先于<code>Q</code>。</p><p>这条规则要求<code>volatile</code>修饰的变量不会被<strong>指令重排序</strong>优化,从而保证代码的执行顺序与程序的顺序相同。</p></li></ul><p>[^9]: volatile屏蔽指令重排序的语义在JDK 5中才被完全修复,此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题(主要是volatile变量前后的代码仍然存在重排序问题),这一点也是在JDK 5之前的Java中无法安全地使用DCL(双锁检测)来实现单例模式的原因。<br>[^10]: Doug Lea列出了各种处理器架构下的内存屏障指令:<a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/jmm/cookbook.html</a></p><h3 id="针对long和double型变量的特殊规则"><a href="#针对long和double型变量的特殊规则" class="headerlink" title="针对long和double型变量的特殊规则"></a>针对long和double型变量的特殊规则</h3><p>Java内存模型要求<code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>、<code>write</code>这八种操作都具有原子性, 但是对于64位的数据类型(<code>long</code>和<code>double</code>),在模型中特别定义了一条宽松的规定:<strong>允许虚拟机将没有被<code>volatile</code>修饰的64位数据的读写操作划分为两次32位的操作来进行</strong>,即允许虚拟机实现自行选择是否要保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>和<code>write</code>这四个操作的原子性,这就是所谓的“<code>long</code>和<code>double</code>的非原子性协定”(Non-Atomic Treatment of double and long Variables)。</p><p><strong>如果有多个线程共享一个并未声明为<code>volatile</code>的<code>long</code>或<code>double</code>类型的变量</strong>,并且同时对它们进行读取和修改操作,那么某些线程可能会读取到一个既不是原值,也不是其他线程修改值的代表了“半个变量”的数值。不过这种读取到“半个变量”的情况是非常罕见的,经过实际测试[1],在目前主流平台下商用的64位Java虚拟机中并不会出现非原子性访问行为,但是对于32位的Java虚拟机,譬如比较常用的32 位x86平台下的HotSpot虚拟机,对long类型的数据确实存在非原子性访问的风险。从JDK 9起, HotSpot增加了一个实验性的参数<code>-XX:+AlwaysAtomicAccesses</code>(这是JEP 188对Java内存模型更新的一部分内容)来约束虚拟机对所有数据类型进行原子性的访问。而针对double类型,由于现代中央处理器中一般都包含专门用于处理浮点数据的浮点运算器(Floating Point Unit,FPU),用来专门处理单、双精度的浮点数据,所以哪怕是32位虚拟机中通常也不会出现非原子性访问的问题,实际测试也证实了这一点。笔者的看法是,在实际开发中,除非该数据有明确可知的线程竞争,否则我们在编写代码时一般不需要因为这个原因刻意把用到的long和double变量专门声明为volatile。</p><h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>介绍完Java内存模型的相关操作和规则后,我们再整体回顾一下这个模型的特征。Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的,我们逐个来看一下哪些操作实现了这三个特性。</p><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>由Java内存模型来直接保证的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>和<code>write</code>这六个, 我们大致可以认为,基本数据类型的访问、读写都是具备原子性的(例外就是<code>long</code>和<code>double</code>的非原子性协定,只要知道这件事情就可以了,无须太过在意这些几乎不会发生的例外情况)。</p><p>如果应用场景需要一个更大范围的原子性保证(经常会遇到),Java内存模型还提供了<code>lock</code>和<code>unlock</code>操作来满足这种需求,尽管虚拟机未把<code>lock</code>和<code>unlock</code>操作直接开放给用户使用,但是却提供了更高层次的字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式地使用这两个操作。这两个字节码指令反映到Java 代码中就是同步块——<code>synchronized</code>关键字,因此在<code>synchronized</code>块之间的操作也具备原子性。</p><h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><p>可见性就是指当一个线程修改了共享变量的值时,其他线程能够立即得知这个修改。上文在讲解<code>volatile</code>变量的时候已详细讨论过这一点。Java内存模型是通过在变量修改后将新值同步回主内存,在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的,无论是普通变量还是<code>volatile</code>变量都是如此。普通变量与<code>volatile</code>变量的区别是,<code>volatile</code>的特殊规则保证了新值能<strong>立即</strong>同步到主内存,以及每次使用前<strong>立即</strong>从主内存刷新。因此我们可以说<code>volatile</code>保证了<strong>多线程操作时变量的可见性</strong>,而普通变量则不能保证这一点。</p><p>除了<code>volatile</code>之外,Java还有两个关键字能实现可见性,它们是<code>synchronized</code>和<code>final</code>。</p><ul><li><p>同步块的可见性是由“对一个变量执行<code>unlock</code>操作之前,必须先把此变量同步回主内存中(执行<code>store</code>、<code>write</code>操作)”这条规则获得的。</p></li><li><p>而<code>final</code>关键字的可见性是指:被<code>final</code>修饰的字段在构造器中一旦被初始化完成,并且构造器没有把<code>this</code>的引用传递出去(<code>this</code>引用逃逸是一件很危险的事情,其他线程有可能通过这个引用访问到“初始化了一半”的对象),那么在其他线程中就能看见<code>final</code>字段的值。如下所示,变量<code>i</code>与<code>j</code>都具备可见性,它们无须同步就能被其他线程正确访问。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 省略后续动作</span>    <span class="token punctuation">}</span>    <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 也可以选择在构造函数中初始化    </span>        j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 省略后续动作</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h4><p>Java内存模型的有序性在前面讲解<code>volatile</code>时也比较详细地讨论过了,Java程序中天然的有序性可以总结为一句话:如果在本线程内观察,所有的操作都是有序的;如果在一个线程中观察另一个线程, 所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”(Within-Thread As-If-Serial Semantics),后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p><p>Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性,<code>volatile</code>关键字本身就包含了禁止指令重排序的语义,而<code>synchronized</code>则是由“一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作”这条规则获得的,这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p><h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>如果Java内存模型中所有的有序性都仅靠<code>volatile</code>和<code>synchronized</code>来完成,那么有很多操作都将会变得非常啰嗦,但是我们在编写Java并发代码的时候并没有察觉到这一点,这是因为Java语言中有一个“先行发生”(Happens-Before)的原则。这个原则非常重要,它是判断数据是否存在竞争,线程是否安全的非常有用的手段。依赖这个原则,我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题,而不需要陷入Java内存模型苦涩难懂的定义之中。</p><p>现在就来看看“先行发生”原则指的是什么。先行发生是Java内存模型中定义的两项操作之间的偏序关系,比如说操作A先行发生于操作B,其实就是说在发生操作B之前,操作A产生的影响能被操作B 观察到,“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。这句话不难理解,但它意味着什么呢?我们可以举个例子来说明一下。如代码清单12-8所示的这三条伪代码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下操作在线程A中执行</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以下操作在线程B中执行</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以下操作在线程C中执行</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设线程A中的操作<code>i=1</code>先行发生于线程B的操作<code>j=i</code>,那我们就可以确定在线程B的操作执行后,变量<code>j</code>的值一定是等于1,得出这个结论的依据有两个:</p><ul><li>一是根据先行发生原则,<code>i=1</code>的结果可以被观察到;</li><li>二是线程C还没登场,线程A操作结束之后没有其他线程会修改变量i的值。</li></ul><p>现在再来考虑线程C,我们依然保持线程A和B之间的先行发生关系,而C出现在线程A和B的操作之间,但是C与B没有先行发生关系,那<code>j</code>的值会是多少呢?答案是不确定!1和2都有可能,因为线程C对变量<code>i</code>的影响可能会被线程B观察到,也可能不会,这时候线程B就存在读取到过期数据的风险,不具备多线程安全性。</p><p>下面是Java内存模型下一些“天然的”先行发生关系,这些先行发生关系无须任何同步器协助就已经存在,可以在编码中直接使用。如果两个操作之间的关系不在此列,并且无法从下列规则推导出来,则它们就没有顺序性保障,虚拟机可以对它们随意地进行重排序。</p><ul><li>程序次序规则(Program Order Rule):<strong>在一个线程内</strong>,<strong>按照控制流顺序</strong>,书写在前面的操作先行发生于书写在后面的操作。注意,这里说的是控制流顺序而不是程序代码顺序,因为要考虑分支、循环等结构。</li><li>管程锁定规则(Monitor Lock Rule):一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”,而“后面”是指时间上的先后。</li><li><code>volatile</code>变量规则(Volatile Variable Rule):对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作,这里的“后面”同样是指时间上的先后。</li><li>线程启动规则(Thread Start Rule):<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li><li>线程终止规则(Thread Termination Rule):线程中的所有操作都先行发生于对此线程的终止检测,我们可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行。</li><li>线程中断规则(Thread Interruption Rule):对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生,可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生。</li><li>对象终结规则(Finalizer Rule):一个对象的初始化完成(构造函数执行结束)先行发生于它的<code>finalize()</code>方法的开始。</li><li>传递性(Transitivity):如果操作A先行发生于操作B,操作B先行发生于操作C,那就可以得出操作A先行发生于操作C的结论。</li></ul><p>Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些,下面演示一下如何使用这些规则去判定操作间是否具备顺序性,对于读写共享变量的操作来说,就是线程是否安全。还可以从下面这个例子中感受一下“时间上的先后顺序”与“先<strong>行</strong>发生”之间有什么不同。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示的是一组再普通不过的getter/setter方法,假设存在线程A和B,线程A先(时间上的先后)调用了<code>setValue(1)</code>,然后线程B调用了同一个对象的<code>getValue()</code>,那么线程B收到的返回值是什么? 我们依次分析一下先行发生原则中的各项规则。由于两个方法分别由线程A和B调用,不在一个线程中,所以程序次序规则在这里不适用;由于没有同步块,自然就不会发生lock和unlock操作,所以管程锁定规则不适用;由于<code>value</code>变量没有被<code>volatile</code>关键字修饰,所以<code>volatile</code>变量规则不适用;后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则,所以最后一条传递性也无从谈起,因此我们可以判定,尽管线程A在操作时间上先于线程B,但是无法确定线程B中<code>getValue()</code>方法的返回结果,换句话说,这里面的操作不是线程安全的。</p><p>那怎么修复这个问题呢?我们至少有两种比较简单的方案可以选择:要么把getter/setter方法都定义为<code>synchronized</code>方法,这样就可以套用管程锁定规则;要么把value定义为<code>volatile</code>变量,由于setter方法对value的修改不依赖<code>value</code>的原值,满足<code>volatile</code>关键字使用场景,这样就可以套用<code>volatile</code>变量规则来实现先行发生关系。</p><p>通过上面的例子,我们可以得出结论:一个操作“时间上的先发生”不代表这个操作会是“先<strong>行</strong>发生”。那如果一个操作“先行发生”,是否就能推导出这个操作必定是“时间上的先发生”呢?很遗憾,这个推论也是不成立的。一个典型的例子就是多次提到的“指令重排序”：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 以下操作在同一个线程中执行</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如上所示的两条赋值语句在同一个线程之中,根据程序次序规则,<code>int i=1</code>的操作先行发生于<code>int j=2</code>,但是<code>int j=2</code>的代码完全可能先被处理器执行,这并不影响先行发生原则的正确性, <strong>因为我们在这条线程之中没有办法感知到这一点</strong>。</p><p>上面两个例子综合起来证明了一个结论:<strong>时间先后顺序与先行发生原则之间基本没有因果关系</strong>, 所以我们衡量并发安全问题的时候不要受时间顺序的干扰,<strong>一切必须以先行发生原则为准</strong>。</p><h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><p>并发不一定要依赖多线程(如PHP中很常见的多进程并发),但是在Java里面谈论并发,基本上都与线程脱不开关系。</p><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>我们知道,线程是比进程更轻量级的调度执行单位,线程的引入,可以把一个进程的资源分配和执行调度分开,各个线程既可以共享进程资源(内存地址、文件I/O等),又可以独立调度。目前线程是Java里面进行处理器资源调度的最基本单位,不过如果日后Loom项目能成功为Java引入纤程(Fiber)的话,可能就会改变这一点。</p><p>主流的操作系统都提供了线程实现,Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理,每个已经调用过<code>start()</code>方法且还未结束的<code>java.lang.Thread</code>类的实例就代表着一个线程。我们注意到<code>Thread</code>类与大部分的Java类库API有着显著差别,它的所有关键方法都被声明为<code>Native</code>。在Java类库API中,一个<code>Native</code>方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也可能是为了执行效率而使用<code>Native</code>方法,不过通常最高效率的手段也就是平台相关的手段)。正因为这个原因,本节的标题被定为“线程的实现”而不是“Java线程的实现”,在稍后介绍的实现方式中,我们也先把Java的技术背景放下,以一个通用的应用程序的角度来看看线程是如何实现的。</p><p>实现线程主要有三种方式:使用内核线程实现(1:1实现),使用用户线程实现(1:N实现), 使用用户线程加轻量级进程混合实现(N:M实现)。</p><h4 id="1-内核线程实现"><a href="#1-内核线程实现" class="headerlink" title="1.内核线程实现"></a>1.内核线程实现</h4><p>使用内核线程实现的方式也被称为1:1实现。内核线程(Kernel-Level Thread,KLT)就是直接由操作系统内核(Kernel,下称内核)支持的线程,这种线程由内核来完成线程切换,内核通过操纵调度器(Scheduler)对线程进行调度,并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身,这样操作系统就有能力同时处理多件事情,支持多线程的内核就称为多线程内核(Multi-Threads Kernel)。<br>程序一般不会直接使用内核线程,而是使用内核线程的一种高级接口——<strong>轻量级进程</strong>(Light Weight Process,LWP),轻量级进程就是我们通常意义上所讲的线程,由于每个轻量级进程都由一个内核线程支持,因此只有先支持内核线程,才能有轻量级进程。这种轻量级进程与内核线程之间1:1 的关系称为一对一的线程模型</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121206.png" alt="image-20200923212114160"></p><p>由于内核线程的支持,每个轻量级进程都成为一个独立的调度单元,即使其中某一个轻量级进程在系统调用中被阻塞了,也不会影响整个进程继续工作。轻量级进程也具有它的局限性:</p><ul><li>首先,由于是基于内核线程实现的,所以各种线程操作,如创建、析构及同步,都需要进行系统调用。而系统调用的代价相对较高,需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。</li><li>其次,每个轻量级进程都需要有一个内核线程的支持,因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间),因此一个系统支持轻量级进程的数量是有限的。</li></ul><blockquote><p>所谓轻量级进程指的应该就是内核线程的用户态线程实现(该轻量级进程的所有的资源还是由操作系统创建出来的，但是用户态下用户是可以拥有这些资源的绝大多数权限)，一个线程的具体体现就是它所占据的资源，如栈空间以及占用的CPU时间片。内核线程和用户态线程(轻量级进程)虽然是一对一的，通常对于上层业务来说它们是无区别的，但是对底层系统来说它们却是有区别的，它们分别占用了一定的内存空间作为它们的栈、并且是需要占用一定CPU时间的、涉及到线程切换也增加了CPU时间消耗</p></blockquote><h4 id="2-用户线程实现"><a href="#2-用户线程实现" class="headerlink" title="2.用户线程实现"></a>2.用户线程实现</h4><p>使用用户线程实现的方式被称为1:N实现。广义上来讲,一个线程只要不是内核线程,都可以认为是用户线程(User Thread,UT)的一种,因此从这个定义上看,轻量级进程也属于用户线程,但轻量级进程的实现始终是建立在内核之上的,许多操作都要进行系统调用,因此效率会受到限制,并不具备通常意义上的用户线程的优点。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121207.png" alt="image-20200923211921391"></p><p>而狭义上的用户线程指的是完全建立在用户空间的线程库上,<strong>系统内核不能感知到用户线程的存在及如何实现的</strong>。用户线程的建立、同步、销毁和调度完全在用户态中完成,不需要内核的帮助。如果程序实现得当,这种线程不需要切换到内核态,因此操作可以是非常快速且低消耗的,也能够支持规模更大的线程数量,部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1:N的关系称为一对多的线程模型。</p><p>用户线程的优势在于不需要系统内核支援,<strong>劣势也在于没有系统内核的支援</strong>,所有的线程操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题,而且由于操作系统只把处理器资源分配到进程,那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难,甚至有些是不可能实现的。因为使用用户线程实现的程序通常都比较复杂<a href="此处所讲的“复杂”与“程序自己完成线程操作”,并不限于程序直接编写了复杂的实现用户线程的代码,使用用户线程的程序时,很多都依赖特定的线程库来完成基本的线程操作,这些复杂性都封装在线程库之中。">^3</a>,除了有明确的需求外(譬如以前在不支持多线程的操作系统中的多线程程序、需要支持大规模线程数量的应用),一般的应用程序都不倾向使用用户线程。Java、Ruby等语言都曾经使用过用户线程,最终又都放弃了使用它。但是近年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程,譬如Golang、Erlang等,使得用户线程的使用率有所回升。</p><h4 id="3-混合实现"><a href="#3-混合实现" class="headerlink" title="3.混合实现"></a>3.混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外,还有一种将内核线程与用户线程一起使用的实现方式,被称为N:M实现。在这种混合实现下,既存在用户线程,也存在轻量级进程。</p><p>用户线程还是完全建立在用户空间中,因此用户线程的创建、切换、析构等操作依然廉价,并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁, 这样可以使用内核提供的线程调度功能及处理器映射,并且用户线程的系统调用要通过轻量级进程来完成,这大大降低了整个进程被完全阻塞的风险。在这种混合模式中,用户线程与轻量级进程的数量比是不定的,是N:M的关系</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121208.png" alt="image-20200923212501118"></p><p>许多UNIX系列的操作系统,如Solaris、HP-UX等都提供了M:N的线程模型实现。在这些操作系统上的应用也相对更容易应用M:N的线程模型。</p><h4 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4.Java线程的实现"></a>4.Java线程的实现</h4><p>Java线程如何实现并不受Java虚拟机规范的约束,这是一个与具体虚拟机相关的话题。Java线程在早期的Classic虚拟机上(JDK 1.2以前),是基于一种被称为“绿色线程”(Green Threads)的用户线程实现的,但从JDK 1.3起,“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现,即采用1:1的线程模型。</p><p>以HotSpot为例,它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的,而且中间没有额外的间接结构,所以HotSpot自己是不会去干涉线程调度的(可以设置线程优先级给操作系统提供调度建议),全权交给底下的操作系统去处理,所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等,都是由操作系统完成的,也都是由操作系统全权决定的。</p><p>前面强调是两个“主流”,那就说明肯定还有例外的情况,这里举两个比较著名的例子,一个是用于Java ME的CLDC HotSpot Implementation。它同时支持两种线程模型,默认使用1:N由用户线程实现的线程模型,所有Java线程都映射到一个内核线程上;不过它也可以使用另一种特殊的混合模型,Java线程仍然全部映射到一个内核线程上,但当Java线程要执行一个阻塞调用时,CLDC-HI会为该调用单独开一个内核线程,并且调度执行其他Java线程,等到那个阻塞调用完成之后再重新调度之前的Java线程继续执行。</p><p>另外一个例子是在Solaris平台的HotSpot虚拟机,由于操作系统的线程特性本来就可以同时支持1:1(通过Bound Threads或Alternate Libthread实现)及N:M(通过LWP/Thread Based Synchronization 实现)的线程模型,因此Solaris版的HotSpot也对应提供了两个平台专有的虚拟机参数,即<code>-XX: +UseLWPSynchronization</code>(默认值)和<code>-XX:+UseBoundThreads</code>来明确指定虚拟机使用哪种线程模型。</p><p>操作系统支持怎样的线程模型,在很大程度上会影响上面的Java虚拟机的线程是怎样映射的,这一点在不同的平台上很难达成一致,因此《Java虚拟机规范》中才不去限定Java线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响,对Java程序的编码和运行过程来说,这些差异都是完全透明的。</p><h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程,调度主要方式有两种,分别是协同式(Cooperative Threads-Scheduling)线程调度和抢占式(Preemptive Threads-Scheduling)线程调度。</p><ul><li><p>如果使用协同式调度的多线程系统,线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单,而且由于线程要把自己的事情干完后才会进行线程切换,切换操作对线程自己是可知的,所以一般没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。它的坏处也很明显:线程执行时间不可控制,甚至如果一个线程的代码编写有问题,一直不告知系统进行线程切换,那么程序就会一直阻塞在那里。很久以前的Windows 3.x系统就是使用协同式来实现多进程多任务的,那是相当不稳定的,只要有一个进程坚持不让出处理器执行时间,就可能会导致整个系统崩溃。</p></li><li><p>如果使用抢占式调度的多线程系统,那么每个线程将由系统来分配执行时间,线程的切换不由线程本身来决定。譬如在Java中,有<code>Thread::yield()</code>方法可以主动让出执行时间,但是如果想要主动获取执行时间,线程本身是没有什么办法的。在这种实现线程调度的方式下,线程的执行时间是系统可控的,也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度。与前面所说的Windows 3.x的例子相对,在Windows 9x/NT内核中就是使用抢占式来实现多进程的,当一个进程出了问题,我们还可以使用任务管理器把这个进程杀掉,而不至于导致系统崩溃。</p></li></ul><p>虽然说Java线程调度是系统自动完成的,但是我们仍然可以“建议”操作系统给某些线程多分配一点执行时间,另外的一些线程则可以少分配一点——这项操作是通过设置线程优先级来完成的。<strong>Java 语言一共设置了10个级别的线程优先级</strong>(<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>)。在两个线程同时处于Ready状态时,优先级越高的线程越容易被系统选择执行。</p><p>不过,线程优先级并不是一项稳定的调节手段,很显然因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的,所以线程调度最终还是由操作系统说了算。尽管现代的操作系统基本都提供线程优先级的概念,但是并不见得能与Java线程的优先级一一对应,如Solaris中线程有<code>2147483648(2的31次幂)</code>种优先级,但Windows中就只有七种优先级。如果操作系统的优先级比Java 线程优先级更多,那问题还比较好处理,中间留出一点空位就是了,但对于比Java线程优先级少的系统,就不得不出现几个线程优先级对应到同一个操作系统优先级的情况了。下面显示了Java线程优先级与Windows线程优先级之间的对应关系,Windows平台的虚拟机中使用了除<code>THREAD_PRIORITY_IDLE</code>之外的其余6种线程优先级,因此在Windows下设置线程优先级为1和2、3 和4、6和7、8和9的效果是完全相同的。</p><table><thead><tr><th>Java线程优先级</th><th>Windows线程优先级</th></tr></thead><tbody><tr><td>1 ( Thread.MIN_PRIORITY)</td><td>THREAD_PRORIY_LOWEST</td></tr><tr><td>2</td><td>THREAD_PRIORITY_LOWEST</td></tr><tr><td>3</td><td>THREAD_PRIORITY_BELOW_NORMAL</td></tr><tr><td>4</td><td>THREAD_PRIORITY_BELOW_NORMAL</td></tr><tr><td>5 (Thread.NORM_PRIORITY)</td><td>THREAD_PRIORITY_NORMAL</td></tr><tr><td>6</td><td>THREAD_PRIORITY_ABOVE_NORMAL</td></tr><tr><td>7</td><td>THREAD_PRIORITY_ABOVE_NORMAL</td></tr><tr><td>8</td><td>THREAD_PRORITY_HIGHEST</td></tr><tr><td>9</td><td>THREAD_PRORITY_HIGHEST</td></tr><tr><td>10</td><td>THREAD_PRIORITY_CRITICAL</td></tr></tbody></table><p>线程优先级并不是一项稳定的调节手段,这不仅仅体现在某些操作系统上不同的优先级实际会变得相同这一点上,还有其他情况让我们不能过于依赖线程优先级: 优先级可能会被系统自行改变,例如在Windows系统中存在一个叫“优先级推进器”的功能(Priority Boosting,当然它可以被关掉),大致作用是当系统发现一个线程被执行得特别频繁时,可能会越过线程优先级去为它分配执行时间,从而减少因为线程频繁切换而带来的性能损耗。因此,我们并不能在程序中通过优先级来完全准确判断一组状态都为Ready的线程将会先执行哪一个。</p><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了6种线程状态,在任意一个时间点中,一个线程只能有且只有其中的一种状态,并且可以通过特定的方法在不同状态之间转换。这6种状态分别是:</p><ul><li>新建(New):创建后尚未启动的线程处于这种状态。</li><li>运行(Runnable):包括操作系统线程状态中的Running和Ready,也就是处于此状态的线程有可能正在执行,也有可能正在等待着操作系统为它分配执行时间。</li><li>无限期等待(Waiting):处于这种状态的线程不会被分配处理器执行时间,它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态: <ul><li>没有设置Timeout参数的<code>Object::wait()</code>方法; </li><li>没有设置Timeout参数的<code>Thread::join()</code>方法; </li><li><code>LockSupport::park()</code>方法。</li></ul></li><li>限期等待(Timed Waiting):处于这种状态的线程也不会被分配处理器执行时间,不过无须等待被其他线程显式唤醒,在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态: <ul><li><code>Thread::sleep()</code>方法; </li><li>设置了Timeout参数的Object::wait()方法; </li><li>设置了Timeout参数的Thread::join()方法; </li><li>LockSupport::parkNanos()方法; </li><li>LockSupport::parkUntil()方法。</li></ul></li><li>阻塞(Blocked):线程被阻塞了,“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁,这个事件将在另外一个线程放弃这个锁的时候发生;而“等待状态”则是在等待一段时间,或者唤醒动作的发生。在程序等待进入同步区域的时候,线程将进入这种状态。</li><li>结束(Terminated):已终止线程的线程状态,线程已经结束执行。</li></ul><p>上述6种状态在遇到特定事件发生的时候将会互相转换,它们的转换关系如下</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121209.png" alt="image-20200923213849273"></p><h3 id="JVM线程知识补充"><a href="#JVM线程知识补充" class="headerlink" title="JVM线程知识补充"></a>JVM线程知识补充</h3><ul><li><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p></li><li><p>在Hotsport VM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p></li><li><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p></li><li><p>线程分为守护线程(参考下面的例子，主要作用是在某个抽象维度下维护程序的正常运行)和普通线程，所有普通线程终止后，程序退出(不会收到守护线程影响，而是会主动终止所有守护线程)。</p></li><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程。这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM到达安全点，这样堆才不会变化。这种线程的执行类型包括”Stop-The-World”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的出现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul></li></ul><h2 id="Java与协程"><a href="#Java与协程" class="headerlink" title="Java与协程"></a>Java与协程</h2><p>在Java时代的早期,Java语言抽象出来隐藏了<strong>各种操作系统线程差异性的统一线程接口</strong>,这曾经是它区别于其他编程语言的一大优势。在此基础上,涌现过无数多线程的应用与框架,譬如在网页访问时,HTTP请求可以直接与Servlet API中的一条处理线程绑定在一起,以“一对一服务”的方式处理由浏览器发来的信息。语言与框架已经自动屏蔽了相当多同步和并发的复杂性,对于普通开发者而言,几乎不需要专门针对多线程进行学习训练就能完成一般的并发任务。时至今日,这种便捷的并发编程方式和同步的机制依然在有效地运作着,但是在某些场景下,却也已经显现出了疲态。</p><h3 id="内核线程的局限"><a href="#内核线程的局限" class="headerlink" title="内核线程的局限"></a>内核线程的局限</h3><p>通过一个具体场景来解释目前Java线程面临的困境。今天对Web应用的服务要求,不论是在请求数量上还是在复杂度上,与十多年前相比已不可同日而语,这一方面是源于业务量的增长,另一方面来自于为了应对业务复杂化而不断进行的服务细分。现代B/S系统中一次对外部业务请求的响应,往往需要分布在不同机器上的大量服务共同协作来实现,这种服务细分的架构在减少单个服务复杂度、增加复用性的同时,也不可避免地增加了服务的数量,缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算,这样组合多个服务的总耗时才不会太长;也要求每一个服务提供者都要能同时处理数量更庞大的请求,这样才不会出现请求由于某个服务被阻塞而出现等待。</p><p>Java目前的并发编程机制就与上述架构趋势产生了一些矛盾,1:1的内核线程模型是如今Java虚拟机线程实现的主流选择,但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂,系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中,具有这种线程切换的成本也是无伤大雅的,但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下, 用户线程切换的开销甚至可能会接近用于计算本身的开销,这就会造成严重的浪费。</p><p>传统的Java Web服务器的线程池的容量通常在几十个到两百之间,当程序员把数以百万计的请求往线程池里面灌时,系统即使能处理得过来,但其中的切换损耗也是相当可观的。现实的需求在迫使Java去研究新的解决方案,同大家又开始怀念以前绿色线程的种种好处,绿色线程已随着Classic虚拟机的消失而被尘封到历史之中,它还会有重现天日的一天吗?</p><h3 id="协程的复苏"><a href="#协程的复苏" class="headerlink" title="协程的复苏"></a>协程的复苏</h3><p>为什么内核线程调度切换起来成本就要更高? 内核线程的调度成本主要来自于用户态与核心态之间的状态转换,而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。请读者试想以下场景,假设发生了这样一次线程切换:</p><pre><code>线程A -&gt; 系统中断 -&gt; 线程B</code></pre><p>处理器要去执行线程A的程序代码时,并不是仅有代码程序就能跑得起来,程序是数据与代码的组合体,代码执行时还必须要有上下文数据的支撑。而这里说的“上下文”,以程序员的角度来看,是方法调用过程中的各种局部的变量与资源;以线程的角度来看,是方法的调用栈中存储的各类信息; 而以操作系统和硬件的角度来看,则是存储在内存、缓存和寄存器中的一个个具体数值。物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源,<strong>当中断发生,从线程A切换到线程B去执行之前,操作系统首先要把线程A的上下文数据妥善保管好,然后把寄存器、内存分页等恢复到线程B 挂起时候的状态,这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作,免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝,当然不可能是一种轻量级的操作</strong>。</p><p><strong>如果说内核线程的切换开销是来自于保护和恢复现场的成本,那如果改为采用用户线程,这部分开销就能够省略掉吗?答案是“不能”。但是,一旦把保护、恢复现场及调度的工作从操作系统交到程序员手上,那我们就可以打开脑洞,通过玩出很多新的花样来缩减这些开销。</strong><br>有一些古老的操作系统(譬如DOS)是单人单工作业形式的,天生就不支持多线程,自然也不会有多个调用栈这样的基础设施。而早在那样的蛮荒时代,就已经出现了今天被称为栈纠缠(Stack Twine)的、由用户自己模拟多线程、自己保护恢复现场的工作模式。其大致的原理是通过在内存里划出一片额外空间来模拟调用栈,只要其他“线程”中方法压栈、退栈时遵守规则,不破坏这片空间即可,这样多段代码执行时就会像相互缠绕着一样,非常形象。</p><p>到后来,操作系统开始提供多线程的支持,靠应用自己模拟多线程的做法自然是变少了许多,但也并没有完全消失,而是演化为用户线程继续存在。<strong>由于最初多数的用户线程是被设计成协同式调度(Cooperative Scheduling)的,所以它有了一个别名——“协程”(Coroutine)</strong>。<strong>又由于这时候的协程会完整地做调用栈的保护、恢复工作,所以今天也被称为“有栈协程”(Stackfull Coroutine)</strong>,<strong>起这样的名字是为了便于跟后来的“无栈协程”(Stackless Coroutine)区分开</strong>。无栈协程不是本节的主角,不过还是可以简单提一下它的典型应用,即各种语言中的<code>await</code>、<code>async</code>、<code>yield</code>这类关键字。<strong>无栈协程本质上是一种有限状态机,状态保存在闭包里,自然比有栈协程恢复调用栈要轻量得多,但功能也相对更有限</strong>。</p><p>协程的主要优势是轻量,无论是有栈协程还是无栈协程,都要比传统内核线程要轻量得多。如果进行量化的话,那么如果不显式设置<code>-Xss</code>或<code>-XX:ThreadStackSize</code>,则在64位Linux上HotSpot的线程栈容量默认是1MB,此外内核数据结构(Kernel Data Structures)还会额外消耗16KB内存。与之相对的,一个协程的栈通常在几百个字节到几KB之间,所以Java虚拟机里线程池容量达到两百就已经不算小了,而很多支持协程的应用中,同时并存的协程数量可数以十万计。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>协程当然也有它的局限,需要在应用层面实现的内容(调用栈、调度器这些)特别多,这个缺点就不赘述了。除此之外,协程在最初,甚至在今天很多语言和框架中会被设计成协同式调度,这样在语言运行平台或者框架上的调度器就可以做得非常简单。不过有不少资料上显示,既然取了“协程”这样的名字,它们之间就一定以协同调度的方式工作。这种“规定”的出处没有经过查证,只能说这种提法在今天太过狭隘了,非协同式、可自定义调度的协程的例子并不少见。</p><p>具体到Java语言,还会有一些别的限制,譬如HotSpot这样的虚拟机,Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法,还能否正常切换协程而不影响整个线程?另外,如果协程中遇传统的线程同步措施会怎样?譬如Kotlin提供的协程实现,一旦遭遇<code>synchronize</code>关键字,那挂起来的仍将是整个线程。</p><h3 id="Java的解决方案"><a href="#Java的解决方案" class="headerlink" title="Java的解决方案"></a>Java的解决方案</h3><p>对于有栈协程,有一种特例实现名为纤程(Fiber),这个词最早是来自微软公司,后来微软还推出过系统层面的纤程包来方便应用做现场保存、恢复和纤程调度。OpenJDK在2018年创建了Loom项目,这是Java用来应对本节开篇所列场景的官方解决方案,根据目前公开的信息,如无意外,日后该项目为Java语言引入的、与现在线程模型平行的新并发编程机制中应该也会采用“纤程”这个名字,不过这显然跟微软是没有任何关系的。从Oracle官方对“什么是纤程”的解释里可以看出,它就是一种典型的有栈协程</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121210.png" alt="image-20200923215113676"></p><p>Loom项目背后的意图是重新提供对用户线程的支持,但与过去的绿色线程不同,这些新功能不是为了取代当前基于操作系统的线程实现,而是会有两个并发编程模型在Java虚拟机中并存,可以在程序中同时使用。新模型有意地保持了与目前线程模型相似的API设计,它们甚至可以拥有一个共同的基类,这样现有的代码就不需要为了使用纤程而进行过多改动,甚至不需要知道背后采用了哪个并发编程模型。Loom团队在JVMLS 2018大会上公布了他们对Jetty基于纤程改造后的测试结果,同样在5000QPS的压力下,以容量为400的线程池的传统模式和每个请求配以一个纤程的新并发处理模式进行对比,前者的请求响应延迟在10000至20000毫秒之间,而后者的延迟普遍在200毫秒以下,具体结果如图</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121211.png" alt="image-20200923215222185"></p><p>在新并发模型下,一段使用纤程并发的代码会被分为两部分——执行过程(Continuation)和调度器(Scheduler)。执行过程主要用于维护执行现场保护、恢复上下文状态,而调度器则负责编排所有要执行的代码的顺序。将调度程序与执行过程分离的好处是,用户可以选择自行控制其中的一个或者多个,而且Java中现有的调度器也可以被直接重用。事实上,Loom中默认的调度器就是原来已存在的用于任务分解的Fork/Join池(JDK 7中加入的<code>ForkJoinPool</code>)。</p><p>Loom项目目前仍然在进行当中,还没有明确的发布日期,上面提到的内容日后都有被改动的可能。如果现在就想尝试协程,那可以在项目中使用Quasar协程库,这是一个不依赖Java虚拟机的独立实现的协程库。不依赖虚拟机来实现协程是完全可能的,Kotlin语言的协程就已经证明了这一点。Quasar的实现原理是字节码注入,在字节码层面对当前被调用函数中的所有局部变量进行保存和恢复。这种不依赖Java虚拟机的现场保护虽然能够工作,但很影响性能,对即时编译器的干扰也非常大,而且必须要求用户手动标注每一个函数是否会在协程上下文被调用,这些都是未来Loom项目要解决的问题。</p><h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>《Java并发编程实战(Java Concurrency In Practice)》的作者Brian Goetz为“线程安全”做出了一个比较恰当的定义:“当多个线程同时访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步,或者在调用方进行任何其他的协调操作,调用这个对象的行为都可以获得正确的结果,那就称这个对象是线程安全的。”</p><p>这个定义就很严谨而且有可操作性,它要求线程安全的代码都必须具备一个共同特征:<strong>代码本身封装了所有必要的正确性保障手段</strong>(如互斥同步等),令调用者无须关心多线程下的调用问题,更无须自己实现任何措施来保证多线程环境下的正确调用。这点听起来简单,但其实并不容易做到,在许多场景中,我们都会将这个定义弱化一些。如果把“调用这个对象的行为”限定为“单次调用”,这个定义的其他描述能够成立的话,那么就已经可以称它是线程安全了。</p><h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><p>我们已经有了线程安全的一个可操作的定义,那接下来就讨论一下:在Java语言中,线程安全具体是如何体现的?有哪些操作是线程安全的?我们这里讨论的线程安全,将以多个线程之间存在共享数据访问为前提。因为如果根本不存在多线程,又或者一段代码根本不会与其他线程共享数据,那么从线程安全的角度上看,程序是串行执行还是多线程执行对它来说是没有什么区别的。</p><p>为了更深入地理解线程安全,在这里我们可以不把线程安全当作一个非真即假的二元排他选项来看待,而是按照线程安全的“安全程度”由强至弱来排序,可以将Java语言中各种操作共享的数据分为以下五类:<strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</strong>。</p><h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1.不可变"></a>1.不可变</h4><p>在Java语言里面(特指JDK 5以后,即Java内存模型被修正之后的Java语言),不可变(Immutable)的对象一定是线程安全的,无论是对象的方法实现还是方法的调用者,都不需要再进行任何线程安全保障措施。“final关键字带来的可见性”:只要一个不可变的对象被正确地构建出来(即没有发生<code>this</code>引用逃逸的情况),那其外部的可见状态永远都不会改变,永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p><p>Java语言中,如果多线程共享的数据是一个基本数据类型,那么只要在定义时使用<code>final</code>关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象,由于Java语言目前暂时还没有提供值类型的支持,那就需要对象自行保证其行为不会对其状态产生任何影响才行。类比<code>java.lang.String</code>类的对象实例,它是一个典型的不可变对象,用户调用它的<code>substring()</code>、<code>replace()</code>和<code>concat()</code>这些方法都不会影响它原来的值,只会返回一个新构造的字符串对象。</p><p>保证对象行为不影响自己状态的途径有很多种,最简单的一种就是把对象里面带有状态的变量都声明为<code>final</code>,这样在构造函数结束之后,它就是不可变的,如下所示的<code>java.lang.Integer</code> 构造函数,它通过将内部状态变量<code>value</code>定义为<code>final</code>来保障状态不变。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * The value of the {@code Integer}.     *     * @serial     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Constructs a newly allocated {@code Integer} object that     * represents the specified {@code int} value.     *     * @param   value   the value to be represented by the     *                  {@code Integer} object.     */</span>    <span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Java类库API中符合不可变要求的类型,除了上面提到的<code>String</code>之外,常用的还有枚举类型及<code>java.lang.Number</code>的部分子类,如<code>Long</code>和<code>Double</code>等数值包装类型、<code>BigInteger</code>和<code>BigDecimal</code>等大数据类型。</p><p>但同为<code>Number</code>子类型的原子类<code>AtomicInteger</code>和<code>AtomicLong</code>则是可变的。</p><h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2.绝对线程安全"></a>2.绝对线程安全</h4><p>绝对的线程安全能够完全满足Brian Goetz给出的线程安全的定义,这个定义其实是很严格的,一个类要达到“不管运行时环境如何,调用者都不需要任何额外的同步措施”可能需要付出非常高昂的, 甚至不切实际的代价。在Java API中标注自己是线程安全的类,大多数都不是绝对的线程安全。我们可以通过Java API中一个不是“绝对线程安全”的“线程安全类型”来看看这个语境里的“绝对”究竟是什么意思。<br>如果说<code>java.util.Vector</code>是一个线程安全的容器,相信所有的Java程序员对此都不会有异议,因为它的<code>add()</code>、<code>get()</code>和<code>size()</code>等方法都是被<code>synchronized</code>修饰的,尽管这样效率不高,但保证了具备原子性、可见性和有序性。不过,即使它所有的方法都被修饰成<code>synchronized</code>,也不意味着调用它的时候就永远都不再需要同步手段了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Vector<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestVector</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Vector<span class="token operator">&lt;</span>Integer<span class="token operator">></span> vector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                vector<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Thread removeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread printThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            removeThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            printThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//不要同时产生过多的线程,否则会导致操作系统假死</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会遇到以下输出</p><pre><code>Exception in thread &quot;Thread-81127&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 15    at java.util.Vector.get(Vector.java:751)    at john.TestVector$2.run(TestVector.java:30)    at java.lang.Thread.run(Thread.java:748)Exception in thread &quot;Thread-81375&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 14</code></pre><p>很明显,尽管这里使用到的<code>Vector</code>的<code>get()</code>、<code>remove()</code>和<code>size()</code>方法都是同步的,但是在多线程的环境中,如果不在方法调用端做额外的同步措施,使用这段代码仍然是不安全的。因为如果另一个线程恰好在错误的时间里删除了一个元素,导致序号i已经不再可用,再用i访问数组就会抛出一个<code>ArrayIndexOutOfBoundsException</code>异常。如果要保证这段代码能正确执行下去,我们不得不把<code>removeThread</code>和<code>printThread</code>的定义进行修改</p><pre class="line-numbers language-java"><code class="language-java">            Thread removeThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            vector<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread printThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>vector<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vector<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>vector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如<code>Vector</code>一定要做到绝对的线程安全,那就必须在它内部维护一组一致性的快照访问才行,每次对其中元素进行改动都要产生新的快照,这样要付出的时间和空间成本都是非常大的。</p><h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3.相对线程安全"></a>3.相对线程安全</h4><p>相对线程安全就是我们通常意义上所讲的线程安全,它需要保证对这个对象单次的操作是线程安全的,我们在调用的时候不需要进行额外的保障措施,但是对于一些特定顺序的连续调用,就可能需要在调用端使用额外的同步手段来保证调用的正确性。上面的代码就是相对线程安全的案例。</p><p>在Java语言中,大部分声称线程安全的类都属于这种类型,例如<code>Vector</code>、<code>HashTable</code>、<code>Collections</code>的<code>synchronizedCollection()</code>方法包装的集合等。</p><h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4.线程兼容"></a>4.线程兼容</h4><p><strong>线程兼容是指对象本身并不是线程安全的,但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</strong>我们平常说一个类不是线程安全的,通常就是指这种情况。Java类库API中大部分的类都是线程兼容的,如与前面的<code>Vector</code>和<code>HashTable</code>相对应的集合类<code>ArrayList</code>和<code>HashMap</code>等。</p><h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5.线程对立"></a>5.线程对立</h4><p><strong>线程对立是指不管调用端是否采取了同步措施,都无法在多线程环境中并发使用代码</strong>。由于Java 语言天生就支持多线程的特性,线程对立这种排斥多线程的代码是很少出现的,而且通常都是有害的,应当尽量避免。</p><p>一个线程对立的例子是<code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法。如果有两个线程同时持有一个线程对象,一个尝试去中断线程,一个尝试去恢复线程,在并发进行的情况下,无论调用时是否进行了同步,目标线程都存在死锁风险——假如<code>suspend()</code>中断的线程就是即将要执行<code>resume()</code>的那个线程,那就肯定要产生死锁了。也正是这个原因,<code>suspend()</code>和<code>resume()</code>方法都已经被声明废弃了。常见的线程对立的操作还有<code>System.setIn()</code>、<code>Sytem.setOut()</code>和<code>System.runFinalizersOnExit()</code>等。</p><h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><h4 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1.互斥同步"></a>1.互斥同步</h4><p>互斥同步(Mutual Exclusion &amp; Synchronization)是一种最常见也是最主要的并发正确性保障手段。同步是指在多个线程并发访问共享数据时,保证共享数据在同一个时刻只被一条(或者是一些, 当使用信号量的时候)线程使用。而互斥是实现同步的一种手段,<strong>临界区(Critical Section)、互斥量(Mutex)和信号量(Semaphore)</strong>都是常见的互斥实现方式。因此在“互斥同步”这四个字里面,互斥是因,同步是果;互斥是方法,同步是目的。</p><p>在Java里面,最基本的互斥同步手段就是<code>synchronized</code>关键字,这是一种块结构(Block Structured)的同步语法。<code>synchronized</code>关键字经过Javac编译之后,会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令。这两个字节码指令都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。如果Java源码中的<code>synchronized</code>明确指定了对象参数,那就以这个对象的引用作为<code>reference</code>;如果没有明确指定,那将根据<code>synchronized</code>修饰的方法类型(如实例方法或类方法),来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</p><p>根据《Java虚拟机规范》的要求,在执行<code>monitorenter</code>指令时,首先要去尝试获取对象的锁。如果这个对象没被锁定,或者当前线程已经持有了那个对象的锁,就把锁的计数器的值增加一,而在执行<code>monitorexit</code>指令时会将锁计数器的值减一。一旦计数器的值为零,锁随即就被释放了。如果获取对象锁失败,那当前线程就应当被阻塞等待,直到请求锁定的对象被持有它的线程释放为止。</p><p>从功能上看,根据以上《Java虚拟机规范》对<code>monitorenter</code>和<code>monitorexit</code>的行为描述,我们可以得出两个关于<code>synchronized</code>的直接推论,这是使用它时需特别注意的:</p><ul><li>被<code>synchronized</code>修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li><li>被<code>synchronized</code>修饰的同步块在持有锁的线程执行完毕并释放锁之前,会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样,强制已获取锁的线程释放锁;也无法强制正在等待锁的线程中断等待或超时退出。</li></ul><p>从执行成本的角度看,持有锁是一个重量级(Heavy-Weight)的操作。Java的线程是映射到操作系统的原生内核线程之上的,如果要阻塞或唤醒一条线程,则需要操作系统来帮忙完成,这就不可避免地陷入用户态到核心态的转换中,进行这种状态转换需要耗费很多的处理器时间。尤其是对于代码特别简单的同步块(譬如被<code>synchronized</code>修饰的<code>getter()</code> 或<code>setter()</code>方法),状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说,<code>synchronized</code>是Java语言中一个重量级的操作,有经验的程序员都只会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化,<strong>譬如在通知操作系统阻塞线程之前加入一段自旋等待过程, 以避免频繁地切入核心态之中</strong>。</p><p>从上面的介绍中我们可以看到<code>synchronized</code>的局限性,除了<code>synchronized</code>关键字以外,自JDK 5起(实现了JSR 166<a href="此处所讲的“复杂”与“程序自己完成线程操作”,并不限于程序直接编写了复杂的实现用户线程的代码,使用用户线程的程序时,很多都依赖特定的线程库来完成基本的线程操作,这些复杂性都封装在线程库之中。">^3</a>),Java类库中新提供了<code>java.util.concurrent</code>包(下文称J.U.C包),其中的<code>java.util.concurrent.locks.Lock</code>接口便成了Java的另一种全新的互斥同步手段。基于<code>Lock</code>接口,用户能够以非块结构(Non-Block Structured)来实现互斥同步,从而摆脱了语言特性的束缚,改为在类库层面去实现同步,这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。</p><p>重入锁(ReentrantLock)是<code>Lock</code>接口最常见的一种实现<a href="如果局部变量是一个reference类型,它引用的对象在Java堆中可被各个线程共享,但是reference本身在Java栈的局部变量表中是线程私有的。">^4</a>,顾名思义,它与<code>synchronized</code>一样是可重入<a href="“假设线程中访问一个10MB大小的对象,也会把这10MB的内存复制一份出来吗?”,事实上并不会如此,这个对象的引用、对象中某个在线程访问到的字段是有可能被复制的,但不会有虚拟机把整个对象复制一次。">^5</a>的。在基本用法上,<code>ReentrantLock</code>也与<code>synchronized</code>很相似,只是代码写法上稍有区别而已。不过,<code>ReentrantLock</code>与<code>synchronized</code>相比增加了一些高级功能,主要有以下三项:<strong>等待可中断、可实现公平锁及锁可以绑定多个条件</strong>。</p><ul><li>等待可中断:是指当持有锁的线程长期不释放锁的时候,正在等待的线程可以选择放弃等待,改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li><li><strong>公平锁:是指多个线程在等待同一个锁时,必须按照申请锁的时间顺序来依次获得锁;而非公平锁则不保证这一点,在锁被释放时,任何一个等待锁的线程都有机会获得锁。</strong><code>synchronized</code>中的锁是非公平的,<code>ReentrantLock</code>在默认情况下也是非公平的,但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁,将会导致<code>ReentrantLock</code>的性能急剧下降,会明显影响吞吐量。</li><li>锁绑定多个条件:是指一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象。在<code>synchronized</code> 中,锁对象的<code>wait()</code>跟它的<code>notify()</code>或者<code>notifyAll()</code>方法配合可以实现一个隐含的条件,如果要和多于一个的条件关联的时候,就不得不额外添加一个锁;而<code>ReentrantLock</code>则无须这样做,多次调用<code>newCondition()</code>方法即可。</li></ul><p>如果需要使用上述功能,使用<code>ReentrantLock</code>是一个很好的选择,那如果是基于性能考虑呢? <code>synchronized</code>对性能的影响,尤其在JDK 5之前是很显著的,为此在JDK 6中还专门进行过针对性的优化。以<code>synchronized</code>和<code>ReentrantLock</code>的性能对比为例,Brian Goetz对这两种锁在<strong>JDK 5</strong>、单核处理器及双Xeon处理器环境下做了一组吞吐量对比的实验</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121212.png" alt="image-20200923222946804"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121213.png" alt="image-20200923223011124"></p><p>可以看出,多线程环境下<code>synchronized</code>的吞吐量下降得非常严重,而<code>ReentrantLock</code>则能基本保持在同一个相对稳定的水平上。但与其说<code>ReentrantLock</code>性能好,倒不如说当时的<code>synchronized</code>有非常大的优化余地,后续的技术发展也证明了这一点。当JDK 6中加入了大量针对<code>synchronized</code>锁的优化措施之后,相同的测试中就发现<code>synchronized</code>与<code>ReentrantLock</code>的性能基本上能够持平。相信现在所开发的程序应该都是使用JDK 6或以上版本来部署的,所以性能已经不再是选择<code>synchronized</code>或者<code>ReentrantLock</code>的决定因素。</p><p>根据上面的讨论,<code>ReentrantLock</code>在功能上是<code>synchronized</code>的超集,在性能上又至少不会弱于<code>synchronized</code>,那<code>synchronized</code>修饰符是否应该被直接抛弃,不再使用了呢?当然不是,基于以下理由,仍然推荐在<code>synchronized</code>与<code>ReentrantLock</code>都可满足需要时优先使用<code>synchronized</code>: </p><ul><li><code>synchronized</code>是在Java语法层面的同步,足够清晰,也足够简单。每个Java程序员都熟悉<code>synchronized</code>,但J.U.C中的<code>Lock</code>接口则并非如此。因此在只需要基础的同步功能时,更推荐<code>synchronized</code>。</li><li><code>Lock</code>应该确保在<code>finally</code>块中释放锁,否则一旦受同步保护的代码块中抛出异常,则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证,而使用<code>synchronized</code>的话则可以由Java虚拟机来确保即使出现异常,锁也能被自动释放。</li><li>尽管在JDK 5时代<code>ReentrantLock</code>曾经在性能上领先过<code>synchronized</code>,但这已经是十多年之前的胜利了。从长远来看,Java虚拟机更容易针对<code>synchronized</code>来进行优化,因为Java虚拟机可以在<strong>线程和对象的元数据中记录</strong><code>synchronized</code>中锁的相关信息,而使用J.U.C中的Lock的话,Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li></ul><p><a href="此处所讲的“复杂”与“程序自己完成线程操作”,并不限于程序直接编写了复杂的实现用户线程的代码,使用用户线程的程序时,很多都依赖特定的线程库来完成基本的线程操作,这些复杂性都封装在线程库之中。">^3</a>: JSR 166:Concurrency Utilities。<br><a href="如果局部变量是一个reference类型,它引用的对象在Java堆中可被各个线程共享,但是reference本身在Java栈的局部变量表中是线程私有的。">^4</a>: 还有另外一种常见的实现——重入读写锁(ReentrantReadWriteLock,尽管名字看起来很像,但它并不是ReentrantLock的子类)<br><a href="“假设线程中访问一个10MB大小的对象,也会把这10MB的内存复制一份出来吗?”,事实上并不会如此,这个对象的引用、对象中某个在线程访问到的字段是有可能被复制的,但不会有虚拟机把整个对象复制一次。">^5</a>: 可重入性是指一条线程能够反复进入被它自己持有锁的同步块的特性,即锁关联的计数器,如果持有锁的线程再次获得它,则将计数器的值加一,每次释放锁时计数器的值减一,当计数器的值为零时,才能真正释放锁。</p><h4 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h4><p>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销,因此这种同步也被称为阻塞同步(Blocking Synchronization)。从解决问题的方式上看,互斥同步属于一种悲观的并发策略,其总是认为只要不去做正确的同步措施(例如加锁),那就肯定会出现问题,无论共享的数据是否真的会出现竞争,它都会进行加锁(这里讨论的是概念模型,实际上虚拟机会优化掉很大一部分不必要的加锁),这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。随着硬件指令集的发展,我们已经有了另外一个选择:基于冲突检测的乐观并发策略,通俗地说就是不管风险,先进行操作,如果没有其他线程争用共享数据,那操作就直接成功了;如果共享的数据的确被争用,产生了冲突,那再进行其他的补偿措施,最常用的补偿措施是不断地重试,直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起,因此这种同步操作被称为非阻塞同步(Non-Blocking Synchronization),使用这种措施的代码也常被称为无锁(Lock-Free) 编程。</p><p>为什么说使用乐观并发策略需要“硬件指令集的发展”?因为我们必须要求操作和冲突检测这两个步骤具备原子性。靠什么来保证原子性?如果这里再使用互斥同步来保证就完全失去意义了,所以我们只能靠硬件来实现这件事情,硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成,这类指令常用的有:</p><ul><li>测试并设置(Test-and-Set); </li><li>获取并增加(Fetch-and-Increment); </li><li>交换(Swap); </li><li>比较并交换(Compare-and-Swap,下文称CAS); </li><li>加载链接/条件储存(Load-Linked/Store-Conditional,下文称LL/SC)。</li></ul><p>其中,前面的三条是20世纪就已经存在于大多数指令集之中的处理器指令,后面的两条是现代处理器新增的,而且这两条指令的目的和功能也是类似的。在IA64、x86指令集中有用<code>cmpxchg</code>指令完成的CAS功能,在SPARC-TSO中也有用casa指令实现的,而在ARM和PowerPC架构下,则需要使用一对<code>ldrex/strex</code>指令来完成LL/SC的功能。因为Java里最终暴露出来的是CAS操作,所以我们以CAS指令为例进行讲解。</p><p>CAS指令需要有三个操作数,分别是内存位置(在Java中可以简单地理解为变量的内存地址,用V 表示)、旧的预期值(用A表示)和准备设置的新值(用B表示)。CAS指令执行时,当且仅当V符合A时,处理器才会用B更新V的值,否则它就不执行更新。但是,不管是否更新了V的值,都会返回V的旧值,上述的处理过程是一个原子操作,执行期间不会被其他线程中断。</p><p>在JDK 5之后,Java类库中才开始使用CAS操作,该操作由<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供。HotSpot虚拟机在内部对这些方法做了特殊处理,即时编译出来的结果就是一条平台相关的处理器CAS指令,没有方法调用的过程, 或者可以认为是无条件内联进去了[^12]。不过由于<code>Unsafe</code>类在设计上就不是提供给用户程序调用的类(<code>Unsafe::getUnsafe()</code>的代码中限制了只有启动类加载器(Bootstrap ClassLoader)加载的Class才能访问它),因此在JDK 9之前只有Java类库可以使用CAS,譬如J.U.C包里面的整数原子类,其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了<code>Unsafe</code>类的CAS操作来实现。而如果用户程序也有使用CAS操作的需求,那要么就采用反射手段突破<code>Unsafe</code>的访问限制,要么就只能通过Java类库API来间接使用它。直到JDK 9之后,Java类库才在<code>VarHandle</code>类里开放了面向用户程序使用的CAS操作。</p><p><code>incrementAndGet()</code>方法的JDK源码</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Atomically increment by one the current value.     *     * @return the updated value     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>incrementAndGet()</code>方法在一个无限循环中,不断尝试将一个比当前值大一的新值赋值给自己。如果失败了,那说明在执行CAS操作的时候,旧值已经发生改变,于是再次循环进行下一次操作,直到设置成功为止。</p><p>尽管CAS看起来很美好,既简单又高效,但显然这种操作无法涵盖互斥同步的所有使用场景,并且CAS从语义上来说并不是真正完美的,它存在一个逻辑漏洞:如果一个变量V初次读取的时候是A 值,并且在准备赋值的时候检查到它仍然为A值,那就能说明它的值没有被其他线程改变过了吗?这是不能的,因为如果在这段期间它的值曾经被改成B,后来又被改回为A,那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA问题”。J.U.C包为了解决这个问题,提供了一个带有标记的原子引用类<code>AtomicStampedReference</code>,它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类处于相当鸡肋的位置,大部分情况下ABA问题不会影响程序并发的正确性,如果需要解决ABA问题,改用传统的互斥同步可能会比原子类更为高效。</p><p>[^12]: 这种被虚拟机特殊处理的方法称为固有函数(Intrinsics)优化,类似的固有函数还有Math类的一系列算数计算函数、Object的构造函数等,目前已有数百个,具体的清单(以JDK 9为例)可以见: <a href="https://gist.github.com/apangin/8bc69f06879a86163e490a61931b37e8。" target="_blank" rel="noopener">https://gist.github.com/apangin/8bc69f06879a86163e490a61931b37e8。</a></p><h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h4><p>要保证线程安全,也并非一定要进行阻塞或非阻塞同步,同步与线程安全两者没有必然的联系。</p><p>同步只是保障存在共享数据争用时正确性的手段,如果能让一个方法本来就不涉及共享数据,那它自然就不需要任何同步措施去保证其正确性,因此会有一些代码天生就是线程安全的,笔者简单介绍其中的两类。</p><p>可重入代码(Reentrant Code):这种代码又称纯代码(Pure Code),是指可以在代码执行的任何时刻中断它,转而去执行另外一段代码(包括递归调用它本身),而在控制权返回后,原来的程序不会出现任何错误,也不会对结果有所影响。在特指多线程的上下文语境里(不涉及信号量等因素),我们可以认为可重入代码是线程安全代码的一个真子集,这意味着相对线程安全来说,可重入性是更为基础的特性,它可以保证代码线程安全,即所有可重入的代码都是线程安全的,但并非所有的线程安全的代码都是可重入的。</p><p>可重入代码有一些共同的特征,例如,不依赖全局变量、存储在堆上的数据和公用的系统资源, 用到的状态量都由参数中传入,不调用非可重入的方法等。我们可以通过一个比较简单的原则来判断代码是否具备可重入性:如果一个方法的返回结果是可以预测的,只要输入了相同的数据,就都能返回相同的结果,那它就满足可重入性的要求,当然也就是线程安全的。</p><p>线程本地存储(Thread Local Storage):如果一段代码中所需要的数据必须与其他代码共享,那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证,我们就可以把共享数据的可见范围限制在同一个线程之内,这样,无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见,大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程限制在一个线程中消费完,其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式,这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>Java语言中,如果一个变量要被多线程访问,可以使用<code>volatile</code>关键字将它声明为“易变的”;如果一个变量只要被某个线程独享,Java中就没有类似C++中<code>__declspec(thread)</code>这样的关键字去修饰,不过我们还是可以通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个<code>ThreadLocalMap</code>对象,这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键,以本地线程变量为值的K-V值对,<code>ThreadLocal</code>对象就是当前线程的<code>ThreadLocalMap</code>的访问入口,每一个<code>ThreadLocal</code>对象都包含了一个独一无二的<code>threadLocalHashCode</code>值,使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>高效并发是从JDK 5升级到JDK 6后一项重要的改进项,HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术,如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁膨胀(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等,这些技术都是为了在线程之间更高效地共享数据及解决竞争问题,从而提高程序的执行效率。</p><h3 id="自旋锁与自适应锁"><a href="#自旋锁与自适应锁" class="headerlink" title="自旋锁与自适应锁"></a>自旋锁与自适应锁</h3><p>互斥同步对性能最大的影响是阻塞的实现,挂起线程和恢复线程的操作都需要转入内核态中完成,这些操作给Java虚拟机的并发性能带来了很大的压力。同时,虚拟机的开发团队也注意到在许多应用上,共享数据的锁定状态只会持续很短的一段时间,为了这段时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多路(核)处理器系统,如果物理机器有一个以上的处理器或者处理器核心,能让两个或以上的线程同时并行执行,我们就可以让后面请求锁的那个线程“稍等一会”,但不放弃处理器的执行时间,看看持有锁的线程是否很快就会释放锁。为了让线程等待,我们只须让线程执行一个忙循环(自旋),这项技术就是所谓的自旋锁。</p><p>自旋锁在JDK 1.4.2中就已经引入,只不过默认是关闭的,可以使用<code>-XX:+UseSpinning</code>参数来开启,在JDK 6中就已经改为默认开启了。自旋等待不能代替阻塞,且先不说对处理器数量的要求,自旋等待本身虽然避免了线程切换的开销,但它是要占用处理器时间的,所以如果锁被占用的时间很短,自旋等待的效果就会非常好,反之如果锁被占用的时间很长,那么自旋的线程只会白白消耗处理器资源,而不会做任何有价值的工作,这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度,如果自旋超过了限定的次数仍然没有成功获得锁,就应当使用传统的方式去挂起线程。自旋次数的默认值是十次,用户也可以使用参数<code>-XX:PreBlockSpin</code>来自行更改。</p><p>不过无论是默认值还是用户指定的自旋次数,对整个Java虚拟机中所有的锁来说都是相同的。在JDK 6中对自旋锁的优化,引入了自适应的自旋。<strong>自适应意味着自旋的时间不再是固定的了,而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</strong>。如果在同一个锁对象上,自旋等待刚刚成功获得过锁,并且持有锁的线程正在运行中,那么虚拟机就会认为这次自旋也很有可能再次成功,进而允许自旋等待持续相对更长的时间,比如持续100次忙循环。另一方面,如果对于某个锁,自旋很少成功获得过锁,那在以后要获取这个锁时将有可能直接省略掉自旋过程,以避免浪费处理器资源。有了自适应自旋,随着程序运行时间的增长及性能监控信息的不断完善,虚拟机对程序锁的状况预测就会越来越精准,虚拟机就会变得越来越“聪明”了。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时,对一些代码要求同步,但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持,如果判断到一段代码中,在堆上的所有数据都不会逃逸出去被其他线程访问到,那就可以把它们当作栈上数据对待,认为它们是线程私有的,同步加锁自然就无须再进行。</p><p>变量是否逃逸,对于虚拟机来说是需要使用复杂的过程间分析才能确定的, 但是程序员自己应该是很清楚的,怎么会在明知道不存在数据争用的情况下还要求同步呢?这个问题的答案是:有许多同步措施并不是程序员自己加入的,同步的代码在Java程序中出现的频率是很高的，如下例子所示：</p><p><code>String</code>是一个不可变的类,对字符串的连接操作总是通过生成新的<code>String</code>对象来进行的,因此Javac编译器会对<code>String</code>连接做自动优化。在JDK 5之前,字符串加法会转化为<code>StringBuffer</code> 对象的连续<code>append()</code>操作,在JDK 5及以后的版本中,会转化为<code>StringBuilder</code>对象的连续<code>append()</code>操作。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> String s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在每个<code>StringBuffer.append()</code>方法中都有一个同步块,锁就是<code>sb</code>对象。虚拟机观察变量<code>sb</code>,经过逃逸分析后会发现它的动态作用域被限制在<code>concatString()</code>方法内部。也就是<code>sb</code>的所有引用都永远不会逃逸到<code>concatString()</code>方法之外,其他线程无法访问到它,所以这里虽然有锁,但是可以被安全地消除掉。在解释执行时这里仍然会加锁,但在经过服务端编译器的即时编译之后,这段代码就会忽略所有的同步措施而直接执行。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上,我们在编写代码的时候,总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步,这样是为了使得需要同步的操作数量尽可能变少,即使存在锁竞争,等待锁的线程也能尽可能快地拿到锁。</p><p>大多数情况下,上面的原则都是正确的,但是如果一系列的连续操作都对同一个对象反复加锁和解锁,甚至加锁操作是出现在循环体之中的,那即使没有线程竞争,频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>以上代码所示连续的<code>append()</code>方法就属于这类情况。如果虚拟机探测到有这样一串零碎(<strong>执行时间相对加锁时间短</strong>)的操作都对同一个对象加锁,将会把加锁同步的范围扩展(粗化)到整个操作序列的外部,上面代码为例,就是扩展到第一个<code>append()</code>操作之前直至最后一个<code>append()</code>操作之后,这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是JDK 6时加入的新型锁机制,它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的,因此传统的锁机制就被称为“重量级”锁。不过,需要强调一点,轻量级锁并不是用来代替重量级锁的,它设计的初衷是在没有多线程竞争的前提下,减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>要理解轻量级锁,以及后面会讲到的偏向锁的原理和运作过程,必须要对HotSpot虚拟机对象的内存布局(尤其是对象头部分)有所了解。HotSpot虚拟机的对象头(Object Header)分为两部分,第一部分用于存储对象自身的运行时数据,如哈希码(HashCode)、GC分代年龄(Generational GC Age) 等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特,官方称它为“Mark Word”。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针,如果是数组对象,还会有一个额外的部分用于存储数组长度。</p><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本,考虑到Java虚拟机的空间使用效率,Mark Word被设计成一个非固定的动态数据结构,以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中,对象未被锁定的状态下, Mark Word的32个比特空间里的25个比特将用于存储对象哈希码,4个比特用于存储对象分代年龄,2 个比特用于存储锁标志位,还有1个比特固定为0(这表示未进入偏向模式)。对象除了未被锁定的正常状态外,还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同状态,这些状态下对象头的存储内容如下<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121214.png" alt="image-20200924075130335"></p><p>轻量级锁的工作过程:在代码即将进入同步块的时候,如果此同步对象没有被锁定(锁标志位为“01”状态),虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间,用于存储锁对象目前的Mark Word的拷贝(官方为这份拷贝加了一个Displaced前缀,即Displaced Mark Word),这时候线程堆栈与对象头的状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121215.png" alt="image-20200924075237466"></p><p>然后,虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了,即代表该线程拥有了这个对象的锁,并且对象Mark Word的锁标志位(Mark Word的最后两个比特)将转变为“00”,表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121216.png" alt="image-20200924075327306"></p><p>如果这个更新操作失败了,那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧,如果是,说明当前线程已经拥有了这个对象的锁,那直接进入同步块继续执行就可以了,否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况,那轻量级锁就不再有效,必须要膨胀为重量级锁,锁标志的状态值变为“10”,此时Mark Word中存储的就是指向重量级锁(互斥量)的指针,后面等待锁的线程也必须进入阻塞状态。</p><p>上面描述的是轻量级锁的加锁过程,它的解锁过程也同样是通过CAS操作来进行的,如果对象的Mark Word仍然指向线程的锁记录,那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换,那整个同步过程就顺利完成了;如果替换失败,则说明有其他线程尝试过获取该锁,就要在释放锁的同时,唤醒被挂起的线程[^14]。</p><p><strong>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁,在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争,轻量级锁便通过CAS操作成功避免了使用互斥量的开销;但如果确实存在锁竞争,除了互斥量的本身开销外,还额外发生了CAS操作的开销。因此在有竞争的情况下, 轻量级锁反而会比传统的重量级锁更慢。</strong></p><p>[^14]: 替换失败是因为有其它线程将轻量级锁标识改成重量级锁了，当前线程还是拿旧值也就是轻量级锁标识记进行CAS，无论是CAS的一瞬间产生竞争还是轻量级锁标识被改了较长时间了都会导致失败，此时其他线程肯定都在重量级锁的互斥量上挂起了。此时当前线程需要获取对象头的新mark word进行CAS，然后根据此时mark word中的互斥量指针得到互斥量对在互斥量上挂起的线程进行唤醒</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 6中引入的一项锁优化措施,它的目的是消除数据在无竞争情况下的同步原语, 进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量,那偏向锁就是在无竞争的情况下把整个同步都消除掉,连CAS操作都不去做了。</p><p>偏向锁中的“偏”,就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程,如果在接下来的执行过程中,该锁一直没有被其他的线程获取,则持有偏向锁的线程将永远不需要再进行同步。</p><p>假设当前虚拟机启用了偏向锁(启用参数<code>-XX:+UseBiased Locking</code>,这是自JDK 6 起HotSpot虚拟机的默认值),那么当锁对象第一次被线程获取的时候,虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”,表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功,持有偏向锁的线程以后每次进入这个锁相关的同步块时,虚拟机都可以不再进行任何同步操作(例如加锁、解锁及对Mark Word的更新操作等)。</p><p>一旦出现另外一个线程去尝试获取这个锁的情况,偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向(偏向模式设置为“0”),撤销后标志位恢复到未锁定(标志位为“01”)或轻量级锁定(标志位为“00”)的状态,后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121217.png" alt="image-20200924080441295"></p><p>细心的读者看到这里可能会发现一个问题:当对象进入偏向状态的时候,Mark Word大部分的空间(23个比特)都用于存储持有锁的线程ID了,这部分空间占用了原有存储对象哈希码的位置,那原来对象的哈希码怎么办呢? 在Java语言里面一个对象如果计算过哈希码,就应该一直保持该值不变(强烈推荐但不强制,因为用户可以重载hashCode()方法按自己的意愿返回哈希码),否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的<code>Object::hashCode()</code>方法,返回的是对象的一致性哈希码(Identity Hash Code),这个值是能强制保证不变的,它通过在对象头中存储计算结果来保证第一次计算之后,再次调用该方法取到的哈希码值永远不会再发生改变。<strong>因此,当一个对象已经计算过一致性哈希码后,它就再也无法进入偏向锁状态了;而当一个对象当前正处于偏向锁状态,又收到需要计算其一致性哈希码请求<a href="注意,这里说的计算请求应来自于对Object::hashCode()或者System::identityHashCode(Object)方法的调用,如果重写了对象的hashCode()方法,计算哈希码时并不会产生这里所说的请求。">^15</a>时,它的偏向状态会被立即撤销,并且锁会膨胀为重量级锁。在重量级锁的实现中,对象头指向了重量级锁的位置,代表重量级锁的<code>ObjectMonitor</code>类里有字段可以记录非加锁状态(标志位为“01”)下的Mark Word,其中自然可以存储原来的哈希码。</strong></p><p>偏向锁可以提高带有同步但无竞争的程序性能,但它同样是一个带有效益权衡(Trade Off)性质的优化,也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问,那偏向模式就是多余的。在具体问题具体分析的前提下,有时候使用参数<code>-XX:- UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/20/jvm/diao-you/diao-you-gong-ju-ji-fu-zhu-gong-ju/"/>
      <url>/2020/09/20/jvm/diao-you/diao-you-gong-ju-ji-fu-zhu-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h1><h2 id="jps-JVM-Process-Status-Tool"><a href="#jps-JVM-Process-Status-Tool" class="headerlink" title="jps(JVM Process Status Tool)"></a>jps(JVM Process Status Tool)</h2><p>虚拟机进程状况工具。命令格式：</p><p><code>jps [ options ] [ hostid ]</code></p><p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态,参数hostid为RMI注册表中注册的主机名。</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><pre class="line-numbers language-shell"><code class="language-shell"># 列出Java程序进程ID和Main函数名称jps# 只输出进程IDjps -q# 输出传递给Java进程(主函数)的参数 jps -m# 输出主函数的完整路径jps -l# 显示传递给Java虚拟的参数jps -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="jstat-JVM-Statistics-Monitoring-Tool"><a href="#jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="jstat(JVM Statistics Monitoring Tool)"></a>jstat(JVM Statistics Monitoring Tool)</h2><p>jstat 是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程<a href="需要远程主机提供RMI支持,JDK中提供了jstatd工具可以很方便地建立远程RMI服务器">^1</a>中的类加载、内存、垃圾收集、即时编译等运行时数据,在没有GUI图形界面、只提供了纯文本控制台环境的服务器上,它将是运行期定位虚拟机性能问题的常用工具。在实际生产环境中不一定可以使用图形界面,而且多数服务器管理员也都已经习惯了在文本控制台工作,直接在控制台中使用jstat命令依然是一种常用的监控方式。</p><p>jstat命令格式为：</p><p><code>jstat [ option vmid [interval[s|ms] [count]] ]</code></p><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><p>对于命令格式中的VMID与LVMID需要特别说明一下:<strong>如果是本地虚拟机进程,VMID与LVMID 是一致的（为操作系统进程ID）</strong>;如果是远程虚拟机进程,那VMID的格式应当是:</p><p><code>[protocol:][//]lvmid[@hostname[:port]/servername]</code></p><p>参数interval和count代表查询间隔和次数,如果省略这2个参数,说明只查询一次。假设需要每250 毫秒查询一次进程2764垃圾收集状况,一共查询20次,那命令应当是:</p><pre class="line-numbers language-shell"><code class="language-shell">jstat -gc 2764 250 20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项option代表用户希望查询的虚拟机信息,主要分为三类:类加载、垃圾收集、运行期编译状况。</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视Java堆状况,包括Eden区、2个 Survivor区、老年代、永久代等的容量已用空间,垃圾收集时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同,但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同,但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与-gcutil功能一样,但是会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gcnew基本相同,输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同,输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法</td></tr><tr><td>-t</td><td>在输出信息前加上一个Timestamp列，显示程序的运行时间</td></tr><tr><td>-h</td><td>可以在周期性数据输出后，输出多少行数据后，跟着一个表头信息</td></tr><tr><td>interval</td><td>用于指定输出统计数据的周期，单位为毫秒</td></tr><tr><td>count</td><td>用于指定一个输出多少次数据</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="jstat-gc"><a href="#jstat-gc" class="headerlink" title="jstat -gc"></a>jstat -gc</h4><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon ~ % jstat -gc 3230 250 4 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010 0.0   4096.0  0.0   4096.0 64512.0  11264.0   455680.0   15242.4   30336.0 29368.5 3456.0 3226.7      3    0.010   0      0.000    0.010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>输出列</th><th>说明</th></tr></thead><tbody><tr><td>S0C</td><td>年轻代中第一个survivor(幸存区)的容量 (字节)</td></tr><tr><td>S1C</td><td>年轻代中第二个survivor(幸存区)的容量 (字节)</td></tr><tr><td>S0U</td><td>年轻代中第一个survivor(幸存区)目前已使用空间 (字节)</td></tr><tr><td>S1U</td><td>年轻代中第二个survivor(幸存区)目前已使用空间 (字节)</td></tr><tr><td>EC</td><td>年轻代中Eden(伊甸园)的容量 (字节)</td></tr><tr><td>EU</td><td>年轻代中Eden(伊甸园)目前已使用空间 (字节)</td></tr><tr><td>OC</td><td>Old代的容量 (字节)</td></tr><tr><td>OU</td><td>Old代目前已使用空间 (字节)</td></tr><tr><td>MC</td><td>metaspace(元空间)的容量 (字节)</td></tr><tr><td>MU</td><td>metaspace(元空间)目前已使用空间 (字节)</td></tr><tr><td>CCSC</td><td>压缩类空间大小</td></tr><tr><td>CCSU</td><td>压缩类空间使用大小</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时年轻代中gc次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时年轻代中gc所用时间(s)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时old代(全gc)gc次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时old代(全gc)gc所用时间(s) GCT:从应用程序启动到采样时gc用的总时间(s)</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时gc用的总时间(s)</td></tr></tbody></table><h4 id="jstat-class"><a href="#jstat-class" class="headerlink" title="jstat -class"></a>jstat -class</h4><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon ~ % jstat -class 3230Loaded  Bytes  Unloaded  Bytes     Time  4714  9787.2        0     0.0       1.28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>输出列</th><th>说明</th></tr></thead><tbody><tr><td>Loaded</td><td>已经装载的类的数量</td></tr><tr><td>Bytes</td><td>装载类所占用的字节数</td></tr><tr><td>Unloaded</td><td>已经卸载类的数量</td></tr><tr><td>Bytes</td><td>卸载类的字节数</td></tr><tr><td>Time</td><td>装载和卸载类所花费的时间</td></tr></tbody></table><h2 id="jinfo-Configuration-Info-for-Java"><a href="#jinfo-Configuration-Info-for-Java" class="headerlink" title="jinfo(Configuration Info for Java)"></a>jinfo(Configuration Info for Java)</h2><p>Java配置信息工具的作用是实时查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表,但如果想知道未被显式指定的参数的系统默认值,除了去找资料外,就只能使用jinfo的-flag选项进行查询了(如果只限于JDK 6或以上版本的话,使用<code>java- XX:+PrintFlagsFinal</code>查看参数默认值也是一个很好的选择)。</p><p>在JDK 6中,jinfo对于Windows平台功能仍然有较大限制,只提供了最基本的-flag选项。</p><p>格式：<code>jinfo [option] &lt;pid&gt;</code></p><h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-flag &lt;name&gt;</code></td><td>打印JVM参数<code>&lt;name&gt;</code>的值</td></tr><tr><td><code>-flag [+/-]&lt;name&gt;</code></td><td>在运行期修改部分参数值的</td></tr><tr><td><code>-flag &lt;name&gt;=&lt;value&gt;</code></td><td>在运行期修改部分参数值的</td></tr><tr><td>-sysprops</td><td>把虚拟机进程的<code>System.getProperties()</code>的内容打印出来</td></tr><tr><td><code>&lt;no option&gt;</code></td><td>打印以上所有</td></tr><tr><td>-h/-help</td><td>帮助信息</td></tr></tbody></table><h2 id="jmap-Memory-Map-for-Java"><a href="#jmap-Memory-Map-for-Java" class="headerlink" title="jmap(Memory Map for Java)"></a>jmap(Memory Map for Java)</h2><p>jmap命令用于生成堆转储快照(一般称为heapdump或dump文件)。如果不使用jmap命令,要想获取Java堆转储快照也还有一些比较“暴力”的手段:</p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code>参数,可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件</li><li>通过<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件</li><li>又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机,也能顺利拿到堆转储快照。</li><li>使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储。 </li><li>使用 hprof 命令。</li></ul><p>jmap的作用并不仅仅是为了获取堆转储快照,它还可以查询finalize执行队列、Java堆和方法区的详细信息,如空间使用率、当前用的是哪种收集器等。和jinfo命令一样,jmap有部分功能在Windows平台下是受限的,除了生成堆转储快照的<code>-dump</code>选项和用于查看每个类的实例、空间占用统计的<code>-histo</code>选项在所有操作系统中都可以使用之外,其余选项都只能在Linux/Solaris中使用。</p><p>命令格式：</p><ul><li><code>jmap [option] &lt;pid&gt;</code></li><li><code>jmap [option] &lt;executable&gt; &lt;core&gt;</code></li><li><code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code></li></ul><h3 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>pid</td><td>需要打印配置信息的进程ID。</td></tr><tr><td>executable</td><td>产生核心dump的Java可执行文件。</td></tr><tr><td>core</td><td>需要打印配置信息的核心文件。</td></tr><tr><td>server-id</td><td>可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。(VMID?)</td></tr><tr><td>remote server IP or hostname</td><td>远程调试服务器的IP地址或主机名。</td></tr></tbody></table><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>no option</td><td>查看进程的内存映像信息,类似 Solaris pmap 命令。</td></tr><tr><td>-heap</td><td>显示Java堆详细信息,如使用哪种回收器、参数配置、分代状况等。只在 Linux/Solaris平台下有效</td></tr><tr><td>-dump</td><td>生成Java堆转储快照。格式为 <code>-dump:[live,]format=b,file= &lt;filename&gt;</code>, 其中live子参数说明是否只dump出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在F-Queue中等待 Finalizer线程执行 finalize方法的对象。只在 Linux/ Solaris平下有效</td></tr><tr><td>-histo[:live]</td><td>显示堆中对象统计信息,包括类、实例数量、合计容量</td></tr><tr><td>-F</td><td>当虚拟机进程对-dump选项没有响应时,可使用这个选项强制生成dump快照。只在Linux/ Solaris平台下有效</td></tr><tr><td>-permstat</td><td>以 Classloader为统计口径显示永久代内存状态。只在 Linux/ Solaris平台下有效</td></tr><tr><td>-clstats</td><td>打印类加载器相关统计信息</td></tr><tr><td><code>-J&lt;flag&gt;</code></td><td>to pass <code>&lt;flag&gt;</code> directly to the runtime system</td></tr></tbody></table><h2 id="jhat-JVM-Heap-Analysis-Tool"><a href="#jhat-JVM-Heap-Analysis-Tool" class="headerlink" title="jhat(JVM Heap Analysis Tool)"></a>jhat(JVM Heap Analysis Tool)</h2><p>JDK提供jhat(JVM Heap Analysis Tool)命令与jmap搭配使用,来分析jmap生成的堆转储快照。<br>jhat内置了一个微型的HTTP/Web服务器,生成堆转储快照的分析结果后,可以在浏览器中查看。不过实事求是地说,在实际工作中,除非手上真的没有别的工具可用,否则多数人是不会直接使用jhat命令来分析堆转储快照文件的,主要原因有两个方面：</p><ol><li>一般不会在部署应用程序的服务器上直接分析堆转储快照,即使可以这样做,也会尽量将堆转储快照文件复制到其他机器上进行分析,因为分析工作是一个耗时而且极为耗费硬件资源的过程,既然都要在其他机器上进行,就没有必要再受命令行工具的限制了</li><li>另外一个原因是jhat的分析功能相对来说比较简陋,如VisualVM以及专业用于分析堆转储快照文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具,都能实现比jhat更强大专业的分析功能。</li></ol><p>命令格式：<code>jhat [ options ] heap-dump-file</code></p><h3 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>options</td><td>可选命令行参数</td></tr><tr><td>heap-dump-file</td><td>要查看的二进制Java堆转储文件(Java binary heap dump file)。 如果某个转储文件中包含了多份 heap dumps, 可在文件名之后加上 <code>#</code> 的方式指定解析哪一个 dump, 如: <code>myfile.hprof#3</code></td></tr></tbody></table><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-stack false/true</td><td>关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true .</td></tr><tr><td>-refs false/true</td><td>关闭对象引用跟踪(tracking of references to objects)。 默认值为 true . 默认情况下, 返回的指针是指 向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的 所有对象。</td></tr><tr><td>-port port-number</td><td>设置 jhat HTTP server 的端口号. 默认值 7000 .</td></tr><tr><td>-exclude exclude-file</td><td>指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。</td></tr><tr><td>-baseline exclude-file</td><td>指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很 有用.</td></tr><tr><td>-debug int</td><td>设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.</td></tr><tr><td>-version</td><td>启动后只显示版本信息就退出</td></tr><tr><td>-help/-h</td><td>显示帮助信息并退出</td></tr><tr><td><code>-J&lt;flag&gt;</code></td><td>因为 jhat 命令实际上会启动一个JVM来执行, 通过 <code>-J</code> 可以在启动JVM时传入一些启动参数. 例如, <code>-JXmx512m</code> 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数, 则传入多个 <code>-Jxxxxxx</code>.</td></tr></tbody></table><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>执行命令启动服务器</p><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon heapdump % jhat ./heapdump-1600348822631.hprof Reading from ./heapdump-1600348822631.hprof...Dump file created Thu Sep 17 21:20:22 CST 2020Snapshot read, resolving...Resolving 38612 objects...Chasing references, expect 7 dots.......Eliminating duplicate references.......Snapshot resolved.Started HTTP server on port 7000Server is ready.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105515.png" alt="image-20200920093053766"></p><p>分析结果默认以包为单位进行分组显示,分析内存泄漏问题主要会使用到其中的“Heap Histogram”(与jmap-histo功能一样)与OQL页签的功能,前者可以找到内存中总容量最大的对象,后者是标准的对象查询语言,使用类似SQL的语法对内存中的对象进行查询统计。</p><p>jhat 启动后显示的 html ⻚面中包含有:</p><ul><li>All classes including platform:显示出堆中所包含的所有的类</li><li>Show all members of the rootset :从根集能引用到的对象</li><li>Show instance counts for all classes (including platform/excluding platform):显示平台包括的 所有类的实例数量</li><li>Show heap histogram:堆实例的分布表</li><li>Show finalizer summary:Finalizer 摘要</li><li>Execute Object Query Language (OQL) query:执行对象查询语句(OQL)</li></ul><h2 id="jstack-Stack-Trace-for-Java"><a href="#jstack-Stack-Trace-for-Java" class="headerlink" title="jstack(Stack Trace for Java)"></a>jstack(Stack Trace for Java)</h2><p>jstack命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合,生成线程快照的目的通常是定位线程出现长时间停顿的原因,如线程间死锁、死循环、请求外部资源导致的长时间挂起等,都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈, 就可以获知没有响应的线程到底在后台做些什么事情,或者等待着什么资源。</p><p>命令格式：</p><ul><li><p><code>jstack [ option ] pid</code>： 查看当前时间点，指定进程的dump堆栈信息。</p></li><li><p><code>jstack [ option ] pid &gt; 文件</code>： 将当前时间点的指定进程的dump堆栈信息，写入到指定文件中。</p><p>注:若该文件不存在，则会自动生成;若该文件存在，则会覆盖源文件。</p></li><li><p><code>jstack [ option ] executable core</code>： 查看当前时间点，core文件的dump堆栈信息。</p></li><li><p><code>jstack [ option ] [server_id@]&lt;remote server IP or hostname&gt;</code>： 查看当前时间点，远程 机器的dump堆栈信息。</p></li></ul><h3 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时,强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外,显示关于锁的附加信息。⻓列表. 打印关于锁的附加信息。例如属于java.util.concurrent的ownable synchronizers 列表，会使得JVM停顿得⻓久得多(可能会差很多倍，比如普通的jstack可能几毫秒和一次GC没区别，加了-l 就是近一秒的时间)，-l 建议不要用。一般情况不需要使用。</td></tr><tr><td>-m</td><td>如果调用到本地方法的话,可以显示C/C++的堆栈，一般应用排查不需要使用。</td></tr></tbody></table><h3 id="在thread-dump中要留意的状态"><a href="#在thread-dump中要留意的状态" class="headerlink" title="在thread dump中要留意的状态"></a>在thread dump中要留意的状态</h3><ul><li>死锁，Deadlock(重点关注)</li><li>等待资源，Waiting on condition(重点关注) </li><li>等待获取监视器，Waiting on monitor entry(重点关注) </li><li>阻塞，Blocked(重点关注)</li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED_WAITING </li><li>停止，Parked</li></ul><h3 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h3><p>从JDK5起,<code>java.lang.Thread</code>类新增了一个<code>getAllStackTraces()</code>方法用于获取虚拟机中所有线程的<code>StackTraceElement</code>对象。使用这个方法可以通过简单的几行代码完成jstack的大部分功能,在实际项目中不妨调用这个方法做个管理员页面,可以随时使用浏览器来查看线程堆栈：</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Thread<span class="token punctuation">,</span> StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> stackTrace <span class="token operator">:</span> Thread<span class="token punctuation">.</span><span class="token function">getAllStackTraces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread thread <span class="token operator">=</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">)</span> stackTrace<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>StackTraceElement<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> stackTrace<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n线程:"</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>StackTraceElement element <span class="token operator">:</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\t"</span> <span class="token operator">+</span> element <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hprof-Heap-CPU-Profiling-Tool"><a href="#hprof-Heap-CPU-Profiling-Tool" class="headerlink" title="hprof(Heap/CPU Profiling Tool)"></a>hprof(Heap/CPU Profiling Tool)</h2><p>J2SE中提供了一个简单的命令行工具来对java程序的cpu和heap进行 profiling，叫做HPROF。 HPROF实际上是JVM中的一个native的库，它会在JVM启动的时候通过命令行参数来动态加载，并成为 JVM进程的一部分。若要在java进程启动的时候使用HPROF，用户可以通过各种命令行参数类型来使用 HPROF对java进程的heap或者 (和)cpu进行profiling的功能。HPROF产生的profiling数据可以是二 进制的，也可以是文本格式的。这些日志可以用来跟踪和分析 java进程的性能问题和瓶颈，解决内存使用上不优的地方或者程序实现上的不优之处。二进制格式的日志还可以被JVM中的HAT工具来进行浏览 和分析，用 以观察java进程的heap中各种类型和数据的情况。在J2SE 5.0以后的版本中，HPROF已经被 并入到一个叫做Java Virtual Machine Tool Interface(JVM TI)中。</p><p>命令格式：</p><ul><li><code>java -agentlib:hprof[=options] ToBeProfiledClass</code></li><li><code>java -Xrunprof[:options] ToBeProfiledClass</code></li><li><code>javac -J-agentlib:hprof[=options] ToBeProfiledClass</code></li></ul><h3 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>选项</th><th>说明</th><th>默认</th></tr></thead><tbody><tr><td>heap=dump|site|sall</td><td>heap profiling</td><td>all</td></tr><tr><td>cpu=samples|times|old</td><td>CPU usage</td><td>off</td></tr><tr><td>monitor=y|n</td><td>monitor contention</td><td>n</td></tr><tr><td>format=a|b</td><td>text(txt) or binary output</td><td>a</td></tr><tr><td><code>file=&lt;file&gt;</code></td><td>write data to file</td><td>java.hprof[.txt]</td></tr><tr><td><code>net=&lt;host&gt;:&lt;port&gt;</code></td><td>send data over a socket</td><td>off</td></tr><tr><td><code>depth=&lt;size&gt;</code></td><td>stack trace depth</td><td>4</td></tr><tr><td><code>interval=&lt;ms&gt;</code></td><td>sample interval in ms</td><td>10</td></tr><tr><td><code>cutoff=&lt;value&gt;</code></td><td>output cutoff point</td><td>0.0001</td></tr><tr><td>lineno=y|n</td><td>line number in traces?</td><td>y</td></tr><tr><td>thread=y|n</td><td>thread in traces?</td><td>n</td></tr><tr><td>doe=y|n</td><td>dump on exit?</td><td>y</td></tr><tr><td>msa=y|n</td><td>Solaris micro state accounting</td><td>n</td></tr><tr><td>force=y|n</td><td><code>force output to &lt;file&gt;</code></td><td>y</td></tr><tr><td>verbose=y|n</td><td>print messages about dumps</td><td>y</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>命令示例：</p><pre class="line-numbers language-shell"><code class="language-shell"># 每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称 java.hprof.txt，在当前目录。java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello# CPU Usage Times Profiling(cpu=times)的例子，它相对于CPU Usage Sampling Profile能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术 (BCI):javac -J-agentlib:hprof=cpu=times Hello.java# Heap Allocation Profiling(heap=sites)的例子:javac -J-agentlib:hprof=heap=sites Hello.java# Heap Dump(heap=dump)的例子，它比上面的Heap Allocation Profiling能生成更详细的Heap Dump信息:javac -J-agentlib:hprof=heap=dump Hello.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计方法耗时：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/20 10:03 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HprofTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// java -agentlib:hprof=cpu=times,interval=10 demo.HprofTest demo.HprofTest</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">slowMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">slowerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fastMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HprofTest test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HprofTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test<span class="token punctuation">.</span><span class="token function">fastMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test<span class="token punctuation">.</span><span class="token function">slowMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test<span class="token punctuation">.</span><span class="token function">slowerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>虽然在JVM启动参数中加入<code>-Xrunprof:heap=sites</code>参数可以生成CPU/Heap Profile文件，但对JVM性能影响非常大，不建议在线上服务器环境使用。</p><h2 id="命令工具参考"><a href="#命令工具参考" class="headerlink" title="命令工具参考"></a>命令工具参考</h2><h3 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h3><p>用于支持基本的程序创建和运行</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>appletviewer</td><td>在不使用Web浏览器的情况下运行和调试 Applet,JDK11中被移除</td></tr><tr><td>extcheck</td><td>检査JAR冲突的工具,从JDK9中被移除</td></tr><tr><td>jar</td><td>创建和管理JAR文件</td></tr><tr><td>java</td><td>Java运行工具,用于运行 Class文件或JAR文件</td></tr><tr><td>javac</td><td>用于Java编程语言的编译器</td></tr><tr><td>javadoc</td><td>Java的API文档生成器</td></tr><tr><td>javah</td><td>C语言头文件和Stub函数生成器,用于编写JNI方法</td></tr><tr><td>javap</td><td>Java字节码分析工具</td></tr><tr><td>jlink</td><td>将Module和它的依赖打包成一个运行时镜像文件</td></tr><tr><td>jdb</td><td>基于JPDA协议的调试器,以类似于GDB的方式进行调试Java代码</td></tr><tr><td>jdeps</td><td>Java类依赖性分析器</td></tr><tr><td>ideprscan</td><td>用于搜索JAR包中使用了“ deprecated”的类,从JDK9开始提供</td></tr></tbody></table><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>用于程序签名、设置安全测试</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>keytool</td><td>管理密钥库和证书。主要用于获取或缓存 Kerberos协议的票据授权票据。允许用户査看本地凭据缓存和密钥表中的条目(用于 Kerberos协议)</td></tr><tr><td>jarsigner</td><td>生成并验证JAR签名</td></tr><tr><td>policytool</td><td>管理策略文件的GUI工具,用于管理用户策略文件(java. policy),在JDK10中被移除</td></tr></tbody></table><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>用于创建本地语言文件</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>native2ascii</td><td>本地编码到ASCⅡ编码的转换器( Native-to-ASCII Converter),用于“任意受支持的字符编码和与之对应的“ASC编码和 Unicode转义”之间的相互转换</td></tr></tbody></table><h3 id="远程方法调用"><a href="#远程方法调用" class="headerlink" title="远程方法调用"></a>远程方法调用</h3><p>用于跨Web或网络的服务交互</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>rmic</td><td>Java RMI编译器,为使用JRMP或IIOP协议的远程对象生成Stub、 Skeleton和Tie类,也用于生成 OMG IDL</td></tr><tr><td>rmiregistry</td><td>远程对象注册表服务,用于在当前主机的指定端口上创建并启动一个远程对象注册表</td></tr><tr><td>rmid</td><td>启动激活系统守护进程,允许在虚拟机中注册或激活对象</td></tr><tr><td>serialver</td><td>生成并返回指定类的序列化版本ID</td></tr></tbody></table><h3 id="Java-IDL与RMI-IOP"><a href="#Java-IDL与RMI-IOP" class="headerlink" title="Java IDL与RMI-IOP"></a>Java IDL与RMI-IOP</h3><p>在JDK11中结束了十余年的 CORBA支持,这些工具不再提供</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>tnameserv</td><td>提供对命名服务的访问IDL转Java编译器(IDL-to- -Java Compiler),生成映射 OMG IDL接口的Java源文件,并启用以Java编程语言编写的使用 CORBA功能的应用程序的Java源文件。IDL意即接口定义语言(Interface Definition Language)</td></tr><tr><td>idlj</td><td>对象请求代理守护进程( Object Request Broker Daemon),提供从客户端查找和调用 CORBA 环境服务端上的持久化对象的功能。使用ORBD代替瞬态命名服务tnameserv。ORBD包括瞬态orb 命名服务和持久命名服务。ORBD工具集成了服务器管理器、互操作命名服务和引导名称服务器的功能。当客户端想进行服务器时定位、注册和激活功能时,可以与 servertool一起使用</td></tr><tr><td>servertool</td><td>为应用程序注册、注销、启动和关闭服务器提供易用的接口</td></tr></tbody></table><h3 id="部署工具"><a href="#部署工具" class="headerlink" title="部署工具"></a>部署工具</h3><p>用于程序打包、发布和部署</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>javapackager</td><td>打包、签名Java和 Javafx应用程序,在JDK11中被移除</td></tr><tr><td>pack200</td><td>使用 Java GZIP压缩器将JAR文件转换为压缩的Pack200文件。压缩的压缩文件是高度压缩的JAR,可以直接部署,节省带宽并减少下载时间</td></tr><tr><td>unpack200</td><td>将Pack200生成的打包文件解压提取为JAR文件</td></tr></tbody></table><h3 id="Java-Web-Start"><a href="#Java-Web-Start" class="headerlink" title="Java Web Start"></a>Java Web Start</h3><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>javaws</td><td>启动 Java Web Start并设置各种选项的工具。在JDK11中被移除</td></tr></tbody></table><h3 id="性能监控和故障处理"><a href="#性能监控和故障处理" class="headerlink" title="性能监控和故障处理"></a>性能监控和故障处理</h3><p>用于监控分析Java虚拟机运行信息,排查问题</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool,显示指定系统内所有的 Hotspot虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool,用于收集 Hotspot虚拟机各方面的运行数据</td></tr><tr><td>jstad</td><td>JVM Statistics Monitoring Tool Daemon, jstat的守护程序,启动一个RMI服务器应用程序, statd 用于监视测试的 Hotspot虚拟机的创建和终止,并提供一个界面,允许远程监控工具附加到在本地系统上运行的虚拟机。在JDK9中集成到了 JHSDB中</td></tr><tr><td>jinfo</td><td>Configuration Info for Java,显示虚拟机配置信息。在JDK9中集成到了 JHSDB中</td></tr><tr><td>jmap</td><td>Memory Map for Java,生成虚拟机的内存转储快照( headup文件)。在JDK9中集成到了JHSDB中</td></tr><tr><td>jhat</td><td>JVMHeapAnalysisTool,用于分析堆转储快照,它会建立一个HTTP/WEB服务器,让用户可以在浏览器上査看分析结果。在JDK9中被 JHSDB代替</td></tr><tr><td>jstack</td><td>stack Stack Trace for Java,显示虚拟机的线程快照。在JDK9中集成到了 JHSDB中</td></tr><tr><td>jhsdb</td><td>Java Hotspot Debugger,一个基于 Serviceability Agent的 Hotspot进程调试器,从JDK9开始提供</td></tr><tr><td>jsadebugd</td><td>Java Serviceability Agent Debug Daemon,适用于Java的可维护性代理调试守护程序,主要用于附加到指定的Java进程、核心文件,或充当一个调试服务器</td></tr><tr><td>jcmd</td><td>JVM Command,虚拟机诊断命令工具,将诊断命令请求发送到正在运行的Java虚拟机。从JDK7开始提供</td></tr><tr><td>jconsole</td><td>Java Console,用于监控Java虚拟机的使用JMX规范的图形工具。它可以监控本地和远程jconsole Java虚拟机,还可以监控和管理应用程序</td></tr><tr><td>jmc</td><td>Java Mission Control,包含用于监控和管理Java应用程序的工具,而不会引入与这些工具相Jmc 关联的性能开销。开发者可以使用jme命令来创建JMC工具,从JDK7 Update40开始集成到Oraclejdk中</td></tr><tr><td>jvisualvm</td><td>Java Visualvm,一种图形化工具,可在Java虚拟机中运行时提供有关基于Java技术的应用程序(Java应用程序)的详细信息。 Java Visualvm提供内存和CPU分析、堆转储分析、内存泄漏检测、 Mbean访问和垃圾收集。从JDK6 Update7开始提供;从JDK9开始不再打包入JDK 中,但仍保持更新发展,可以独立下载</td></tr></tbody></table><h3 id="Web-Service工具"><a href="#Web-Service工具" class="headerlink" title="Web Service工具"></a>Web Service工具</h3><p>与CORBA一起在JDK11中被移除</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>schemagen</td><td>用于XML绑定的 Schema生成器,用于生成 XML Schema文件</td></tr><tr><td>wsgen</td><td>XML Web Service2.0的 Java API,生成用于JAX- WS Web Service的JAX-WS便携式产物</td></tr><tr><td>wsimport</td><td>XML Web Service2.0的 Java API,主要用于根据服务端发布的WSDL文件生成客户端</td></tr><tr><td>xjc</td><td>主要用于根据 XML Schema文件生成对应的Java类</td></tr></tbody></table><h3 id="REPL和脚本工具"><a href="#REPL和脚本工具" class="headerlink" title="REPL和脚本工具"></a>REPL和脚本工具</h3><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jshell</td><td>基于Java的 Shell REPL(Read-Eval-Print Loop)交互工具</td></tr><tr><td>jjs</td><td>对 Nashorn引擎的调用入口。 Nashorn是基于Java实现的一个轻量级高性能 Javascript运行环境</td></tr><tr><td>jrunscript</td><td>Java命令行脚本外売工具( Command Line Script Shell),主要用于解释执行Javascript、 Groovy、 Ruby等脚本语言</td></tr></tbody></table><h1 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h1><h2 id="JHSDB"><a href="#JHSDB" class="headerlink" title="JHSDB"></a>JHSDB</h2><p>JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱,它们不仅整合了上面的所有基础工具所能提供的专项功能,而且由于有着“后发优势”,能够做得往往比之前的老工具们更好、更强大。</p><p>JHSDB虽然名义上是JDK 9中才正式提供,但之前已经以sa-jdi.jar包里面的HSDB(可视化工具)和CLHSDB(命令行工具)的形式存在了很长一段时间。它们两个都是JDK的正式成员,随着JDK一同发布,无须独立下载,使用也是完全免费的。准确来说是Linux和Solaris在OracleJDK 6就可以使用HSDB和CLHSDB了,Windows上要到Oracle-JDK 7才可以用。</p><p>JHSDB是一款基于服务性代理(Serviceability Agent,SA)实现的进程外调试工具。服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言(含少量JNI代码)实现的API集合。服务性代理以HotSpot内部的数据结构为参照物进行设计,把这些C++的数据抽象出Java模型对象,相当于HotSpot的C++代码的一个镜像。通过服务性代理的API,<strong>可以在一个独立的Java虚拟机的进程里分析其他HotSpot虚拟机的内部数据,或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节</strong>。服务性代理的工作原理跟Linux上的GDB或者Windows上的Windbg是相似的。</p><p>JCMD、JHSDB与原基础工具实现相同功能的简要对比：</p><table><thead><tr><th>基础工具</th><th>JCMD</th><th>JHSDB</th></tr></thead><tbody><tr><td>jps -lm</td><td>jcmd</td><td>N/A</td></tr><tr><td>jmap -dump <code>&lt;pid&gt;</code></td><td>jcmd <code>&lt;pid&gt;</code> GC.heap_dump</td><td>jhsdb jmap –binaryheap</td></tr><tr><td>jmap -histo <code>&lt;pid&gt;</code></td><td>jcmd <code>&lt;pid&gt;</code> GC.classhistogram</td><td>jhsdb jmap –histo</td></tr><tr><td>jstack <code>&lt;pid&gt;</code></td><td>jcmd <code>&lt;pid&gt;</code> Thread.print</td><td>jhsdb jstack –locks</td></tr><tr><td>jinto -sysprops <code>&lt;pid&gt;</code></td><td>jcmd <code>&lt;pid&gt;</code> VM.system_properties</td><td>jhsdb info –sysprops</td></tr><tr><td>jinfo -flags <code>&lt;pid&gt;</code></td><td>jcmd <code>&lt;pid&gt;</code> VM.flags</td><td>jhsdb jinfo –flags</td></tr></tbody></table><h3 id="实战示例"><a href="#实战示例" class="headerlink" title="实战示例"></a>实战示例</h3><p>通过实验来回答一个简单问题:staticObj、instanceObj、localObj这三个变量本身(而不是它们所指向的对象)存放在哪里。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * -Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops * * @author: honphan.john * @date: 2020/9/20 10:55 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JHSDB_TestCase</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token keyword">static</span> ObjectHolder staticObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectHolder instanceObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ObjectHolder localObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里设一个断点</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ObjectHolder</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JHSDB_TestCase<span class="token punctuation">.</span>Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先,我们要确保这三个变量已经在内存中分配好,然后将程序暂停下来,以便有空隙进行实验,这只要把断点设置在代码中加粗的打印语句上,然后在调试模式下运行程序即可。由于JHSDB本身对压缩指针的支持存在很多缺陷,建议用64位系统实验时禁用压缩指针,另外为了后续操作时可以加快在内存中搜索对象的速度,也建议限制一下Java堆的大小：<code>-Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops</code>。</p><p>程序执行后通过jps查询到测试程序的进程ID,具体如下:</p><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon jvm % jps    6644 Launcher6645 JHSDB_TestCase6647 Jps1119 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动JHSDB(本次试验基于Java8，在${JAVA_HOME}/bin下还没有JHSDB命令行工具，JDK9及之后使用<code>jhsdb hsdb --pid &lt;pid&gt;</code>)</p><pre class="line-numbers language-shell"><code class="language-shell">sudo java -cp ,:/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB 6645<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105516.png" alt="image-20200920114157856"></p><p>下面直接在堆中查找创建的三个对象</p><p>首先点击菜单中的<code>Tools-&gt;Heap Parameters</code>, 因为运行参数中指定了使用的是Serial收集器,图中我们看到了典型的Serial的分代内存布局,Heap Parameters窗口中清楚列出了新生代的Eden、S1、S2和老年代的容量(单位为字节)以及它们的虚拟内存地址起止范围。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105517.png" alt="image-20200920114430925"></p><p>开Windows-&gt;Console窗口,使用scanoops命令在Java堆的新生代(从Eden起始地址到To Survivor结束地址)范围内查找ObjectHolder的实例,结果如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105518.png" alt="image-20200920114738658"></p><p>果然找出了三个实例的地址,而且它们的地址都落到了Eden的范围之内,算是顺带验证了一般情况下新对象在Eden中创建的分配规则。接下来要根据堆中对象实例地址找出引用它们的指针,原本JHSDB的Tools菜单中有Compute Reverse Ptrs来完成这个功能，但是低版本的貌似都有问题，改为在console面板使用命令行替代(所有图形化操作都可以在console使用命令行替代，输入<code>help</code>获取帮助信息)。</p><p>在下图上半部分可以看到使用<code>revptrs</code>命令找到了一个引用了第一个对象”0x000000010f465e70”的对象地址”0x000000010f454270”，它存储的是一个<code>Class</code>对象<strong>（一个”.class”文件会生成一个Java<code>Class</code>对象，一些静态成员会称为<code>Class</code>对象的成员，这些信息在JDK7之前在方法区/永久代，JDK7及之后和字符串常量池一起移到了堆/老年代）</strong>。</p><p>下半部分使用Tools-&gt;Inspector功能根据找到的对象内存地址检查存放的对象。Inspector为我们展示了对象头和指向对象元数据的指针,里面包括了Java类型的名字、继承关系、实现接口关系,字段信息、方法信息、运行时常量池的指针、内嵌的虚方法表(vtable)以及接口方法表(itable)等。</p><p>可以看到这个对象有一个成员正是<code>staticObj</code>存储的内容就是”0x000000010f465e70”。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105519.png" alt="image-20200920115225042"></p><p>接着我们查找第二个对象被谁引用了。如下图可以看到是一个在内存地址为”0x000000010f465e80”的<code>JHSDB_TestCase$Test</code>对象的一个<code>instanceObj</code>存储了该对象的地址”0x000000010f465e98”。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105520.png" alt="image-20200920115931689"></p><p>尝试寻找最后一个对象的时候得到一个空指针，可能该命令还不支持栈上查找：</p><pre class="line-numbers language-shell"><code class="language-shell">hsdb> revptrs 0x000000010f465ea8nullnull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在Java Thread窗口选中main线程后点击Stack Memory按钮查看该线程的栈内存。可以直接在栈上找到了对该最后一个对象<code>localObj</code>的引用：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105521.png" alt="image-20200920120439531"></p><h2 id="JConsole-Java-Monitoring-and-Management-Console"><a href="#JConsole-Java-Monitoring-and-Management-Console" class="headerlink" title="JConsole(Java Monitoring and Management Console)"></a>JConsole(Java Monitoring and Management Console)</h2><p>JConsole是一款基于JMX(Java Management Extensions)的可视化监视、管理工具。它的主要功能是通过JMX的MBean(Managed Bean)对系统进行信息收集和参数动态调整。JMX是一种开放性的技术,不仅可以用在虚拟机本身的管理上,还可以运行于虚拟机之上的软件中,典型的如中间件大多也基于JMX来实现管理与监控。虚拟机对JMX MBean的访问也是完全开放的,可以使用代码调用API、支持JMX协议的管理控制台,或者其他符合JMX规范的软件进行访问。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>如果是从命令行启动，使 JDK 在 PATH 上，运行 <code>jconsole</code> 即可。<br>如果从 GUI shell 启动，找到 JDK 安装路径，打开 bin 文件夹，双击 jconsole 。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul><li>jconsole启动后会自动搜索出本机运行的所有虚拟机进程,而不需要用户自己使用jps来查询。双击选择其中一个进程便可进入主界面开始监控。</li><li>JMX支持跨服务器的管理,也可以使用下面的“远程进程”功能来连接远程服务器,对远程虚拟机进行监控<ul><li>通过<code>jconsole host:port</code>命令</li><li>也可以在已经打开的JConsole界面操作：连接-&gt;新建连接-&gt;选择远程进程-&gt;输入远程主机IP和端口号- &gt;点击“连接”</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105522.png" alt="image-20200920155644799"></p><h3 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h3><p>进入视图后包括这六个标签:</p><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview:"></a>Overview:</h4><p>Displays overview information about the Java VM and monitored values.</p><h4 id="Memory-显示内存使用信息"><a href="#Memory-显示内存使用信息" class="headerlink" title="Memory: 显示内存使用信息"></a>Memory: 显示内存使用信息</h4><p>“内存”页签的作用相当于可视化的jstat命令,用于监视被收集器管理的虚拟机内存(被收集器直接管理的Java堆和被间接管理的方法区)的变化趋势。包括Eden、Survivor、Ternuring、Metaspace等等维度的内存监控。</p><h4 id="Threads-显示线程使用信息"><a href="#Threads-显示线程使用信息" class="headerlink" title="Threads: 显示线程使用信息"></a>Threads: 显示线程使用信息</h4><p>“线程”页签的功能就相当于可视化的jstack命令了,遇到线程停顿的时候可以使用这个页签的功能进行分析。如线程长时间停顿的主要原因有等待外部资源(数据库连接、网络资源、设备资源等)、死循环、锁等待等。</p><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">.</span>jconsole<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/20 15:55 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 线程死循环演示     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createBusyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 第19行</span>                <span class="token punctuation">{</span>                    <span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"testBusyThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 线程锁等待演示     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createLockThread</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"testLockThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">createBusyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">createLockThread</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="主线程等待输入"><a href="#主线程等待输入" class="headerlink" title="主线程等待输入"></a>主线程等待输入</h5><p>程序运行后,首先在“线程”页签中选择main线程。堆栈追踪显示BufferedReader的<code>readBytes()</code>方法正在等待<code>System.in</code>的键盘输入,这时候线程为Runnable状态,Runnable状态的线程仍会被分配运行时间,但<code>readBytes()</code>方法检查到流没有更新就会立刻归还执行令牌给操作系统,这种等待只消耗很小的处理器资源：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105523.png" alt="image-20200920160644113"></p><h5 id="死循环线程"><a href="#死循环线程" class="headerlink" title="死循环线程"></a>死循环线程</h5><p>接着监控<code>testBusyThread</code>线程。<code>testBusyThread</code>线程一直在执行空循环,从堆栈追踪中看到一直在MonitoringTest.java代码的41行停留,19行的代码为while(true)。这时候线程为Runnable 状态,而且没有归还线程执行令牌的动作,所以会在空循环耗尽操作系统分配给它的执行时间,直到线程切换为止,这种等待会消耗大量的处理器资源。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105524.png" alt="image-20200920161217055"></p><h5 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a>等待线程</h5><p><code>testLockThread</code>线程在等待lock对象的notify()或notifyAll()方法的出现,线程这时候处于WAITING状态,在重新唤醒前不会被分配执行时间。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105525.png" alt="image-20200920161417066"></p><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>下面是一段会产生死锁的代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">.</span>jconsole<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/20 16:16 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLock</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 线程死锁等待演示     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynAddRunalbe</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">SynAddRunalbe</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SynAddRunalbe</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SynAddRunalbe</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用jconsole点击”检测死锁”即可显示死锁的线程，可以看到现在的线程是”Blocked”状态，和”WAITING”状态，它们是不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105526.png" alt="image-20200920161811620"></p><h4 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h4><p>显示类装载信息</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105527.png" alt="image-20200920162217671"></p><h4 id="VM-Summary"><a href="#VM-Summary" class="headerlink" title="VM Summary"></a>VM Summary</h4><p>显示java VM信息</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105528.png" alt="image-20200920162241281"></p><h4 id="MBeans-显示-MBeans"><a href="#MBeans-显示-MBeans" class="headerlink" title="MBeans: 显示 MBeans"></a>MBeans: 显示 MBeans</h4><p>JMX监控指标。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105529.png" alt="image-20200920162439313"></p><h2 id="VisualVM-All-in-One-Java-Troubleshooting-Tool"><a href="#VisualVM-All-in-One-Java-Troubleshooting-Tool" class="headerlink" title="VisualVM(All-in-One Java Troubleshooting Tool)"></a>VisualVM(All-in-One Java Troubleshooting Tool)</h2><p>VisualVM是功能最强大的运行监视和故障处理程序之一, 曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。Oracle曾在VisualVM的软件说明中写上了“All-in-One”的字样,预示着它除了常规的运行监视、故障处理外,还将提供其他方面的能力,譬如性能分析(Profiling)。VisualVM的性能分析功能比起JProfiler、YourKit等专业且收费的Profiling工具都不遑多让。而且相比这些第三方工具,VisualVM还有一个很大的优点:不需要被监视的程序基于特殊Agent去运行,因此它的通用性很强,对应用程序实际性能的影响也较小,使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>VisualVM基于NetBeans平台开发工具,所以一开始它就具备了通过插件扩展功能的能力,有了插件扩展支持,VisualVM可以做到: </p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息</strong>(jps、jinfo)。</li><li><strong>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息</strong>(jstat、jstack)。</li><li><strong>dump以及加载分析堆转储快照(jmap、jhat)</strong>。</li><li><strong>方法级的程序运行性能分析,找出被调用最多、运行时间最长的方法</strong>。</li><li><strong>离线程序快照:收集程序的运行时配置、线程dump、内存dump等信息建立一个快照,可以将快照发送开发者处进行Bug反馈</strong>。</li><li><strong>查看JFR文件(JMC)</strong></li><li>其他插件带来的无限可能性。</li></ul><p>VisualVM自带插件安装系统，位置在”Tools-&gt;Plugin”，但是最近发现它的插件中心好像无法访问了，可以在<a href="https://github.com/oracle/visualvm/releases" target="_blank" rel="noopener">这个地址</a>进行VisualVM以及它的插件的下载，然后手动安装，插件为”.nbm”文件，每个版本不一定携带插件，如果最新版本没有找到插件列表就一直往下一个版本找。</p><h3 id="其中一些功能说明"><a href="#其中一些功能说明" class="headerlink" title="其中一些功能说明"></a>其中一些功能说明</h3><h4 id="分析程序性能"><a href="#分析程序性能" class="headerlink" title="分析程序性能"></a>分析程序性能</h4><p>在Profiler页签中,VisualVM提供了程序运行期间方法级的处理器执行时间分析以及内存分析。<strong>做Profiling分析肯定会对程序运行性能有比较大的影响,所以一般不在生产环境使用这项功能,或者改用JMC来完成,JMC的Profiling能力更强,对应用的影响非常轻微</strong>。</p><p>要开始性能分析,先选择“CPU”和“内存”按钮中的一个,然后切换到应用程序中对程序进行操作,VisualVM会记录这段时间中应用程序执行过的所有方法。如果是进行处理器执行时间分析,将会统计每个方法的执行次数、执行耗时;如果是内存分析,则会统计每个方法关联的对象数以及这些对象所占的空间。等要分析的操作执行结束后,点击“停止”按钮结束监控过程。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105530.png" alt="image-20200920173128281"></p><h4 id="BTrace插件动态日志跟踪"><a href="#BTrace插件动态日志跟踪" class="headerlink" title="BTrace插件动态日志跟踪"></a>BTrace插件动态日志跟踪</h4><p>BTrace是一个很神奇的VisualVM插件,它本身也是一个可运行的独立程序。BTrace的作用是在不中断目标程序运行的前提下,通过HotSpot虚拟机的Instrument功能动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义:如当程序出现问题时,排查错误的一些必要信息时(譬如方法参数、返回值等),在开发时并没有打印到日志之中以至于不得不停掉服务时,都可以通过调试增量来加入日志代码以解决问题。可惜在尝试安装VisualVM插件的时候发现好像不支持了。</p><p>不过BTrace同时也是一个独立运行的软件，这是<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">官方Github</a>。</p><p>BTrace能够实现动态修改程序行为,是因为它是基于Java虚拟机的Instrument开发的。Instrument是Java虚拟机工具接口(Java Virtual Machine Tool Interface,JVMTI)的重要组件,提供了一套代理(Agent)机制,使得第三方工具程序可以以代理的方式访问和修改Java虚拟机内部的数据。<strong>阿里巴巴开源的诊断工具Arthas也通过Instrument实现了与BTrace类似的功能</strong>。</p><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><h4 id="配置JMX"><a href="#配置JMX" class="headerlink" title="配置JMX"></a>配置JMX</h4><p>tomcat参数</p><pre class="line-numbers language-shell"><code class="language-shell">CATALINA_OPTS="-xms800m -xmx800m -xmn350m -XX: Survivorratio=8 -XX: + HeapDumpOnOutOfMemoryError -Dcom.sun.management.jmxremote=true  -Djava.rmi.server.hostname=192.168.1.105 -Dcom.Sun.Management.jmxremote.port=6666 -Dcom.sun.management.jmxremote.ssl=false  -Dcom.Sun.Managementote.ssl=false -Dcom.Sun.management.jmxremote.authenticate=false"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置jstatd"><a href="#配置jstatd" class="headerlink" title="配置jstatd"></a>配置jstatd</h4><ol><li>自定义一个 <code>statd.policy</code> 文件，添加  </li></ol><pre><code>grant codebase &quot;jrt:/jdk.jstatd&quot; {    permission java.security.Allpermission;};grant codebase &quot;jrt:/jdk.Internal.jvmstat&quot; {     permission java.security.Allpermission;}</code></pre><ol start="2"><li>然后在 <code>JDK_HOME/bin</code>下面运行<code>jstatd</code>，例如：</li></ol><pre class="line-numbers language-shell"><code class="language-shell">./jstatd -J-Djava.rmi.hostname=192.168.1.102 -J-Djava.security.policy="上面配置的policy文件路径" -p 1099 &<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="客户端VisualVM连接"><a href="#客户端VisualVM连接" class="headerlink" title="客户端VisualVM连接"></a>客户端VisualVM连接</h4><p>然后在VisualVM分别连接即可</p><h2 id="JMC-Java-Mission-Control"><a href="#JMC-Java-Mission-Control" class="headerlink" title="JMC(Java Mission Control)"></a>JMC(Java Mission Control)</h2><p>除了大家熟知的面向通用计算(General Purpose Computing)可免费使用的Java SE外,Oracle公司还开辟过带商业技术支持的Oracle Java SE Support和面向独立软件供应商(ISV)的Oracle Java SE Advanced &amp; Suite产品线。</p><p>除去带有7×24小时的技术支持以及可以为企业专门定制安装包这些非技术类的增强服务外, Oracle Java SE Advanced &amp; Suite与普通Oracle Java SE在功能上的主要差别是前者包含了一系列的监控、管理工具,譬如用于企业JRE定制管理的AMC(Java Advanced Management Console)控制台、JUT(Java Usage Tracker)跟踪系统,用于持续收集数据的JFR(Java Flight Recorder)飞行记录仪和用于监控Java虚拟机的JMC(Java Mission Control)。这些功能全部都是需要商业授权才能在生产环境中使用,但根据Oracle Binary Code协议,在个人开发环境中,允许免费使用JMC和JFR,本节笔者将简要介绍它们的原理和使用。</p><h3 id="JFR-Java-Flight-Recorder"><a href="#JFR-Java-Flight-Recorder" class="headerlink" title="JFR(Java Flight Recorder)"></a>JFR(Java Flight Recorder)</h3><p>JFR是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜集框架,与其他的监控工具(如JProfiling)相比,Oracle特别强调它“可持续在线”(Always-On)的特性。JFR在生产环境中对吞吐量的影响一般不会高于1%(甚至号称是Zero Performance Overhead),而且JFR监控过程的开始、停止都是完全可动态的,即不需要重启应用。JFR的监控对应用也是完全透明的,即不需要对应用程序的源码做任何修改,或者基于特定的代理来运行。</p><p>JMC最初是BEA公司的产品,因此并没有像VisualVM那样一开始就基于自家的Net-Beans平台来开发,而是选择了由IBM捐赠的Eclipse RCP作为基础框架,现在的JMC不仅可以下载到<a href="https://www.oracle.com/java/technologies/javase/products-jmc7-downloads.html" target="_blank" rel="noopener">独立程序</a>,更常见的是作为Eclipse的插件来使用。JMC与虚拟机之间同样采取JMX协议进行通信,JMC一方面作为JMX控制台,显示来自虚拟机MBean提供的数据;另一方面作为JFR的分析工具,展示来自JFR的数据。</p><h3 id="启动JMC并连接JVM"><a href="#启动JMC并连接JVM" class="headerlink" title="启动JMC并连接JVM"></a>启动JMC并连接JVM</h3><ul><li><p>本地JVM</p><p>打开JMC后在左侧的“JVM浏览器”面板中自动显示了通过JDP协议(Java Discovery Protocol)找到的本机正在运行的HotSpot虚拟机进程<img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105531.png" alt="image-20200920180627703"></p></li><li><p>远程JVM</p><ul><li><p>如果需要监控其他远程服务器上的虚拟机,可在“文件-&gt;连接”菜单中创建远程连接。然后根据引导输入远程连接信息，通常包括host、port、authenticatin等信息。</p></li><li><p>另外需要远程服务器的JVM启动时增加参数：</p><pre class="line-numbers language-shell"><code class="language-shell">-Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=192.168.31.4 -XX:+UnlockCommercialFeatures -XX:+FlightRecorder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="使用飞行记录仪"><a href="#使用飞行记录仪" class="headerlink" title="使用飞行记录仪"></a>使用飞行记录仪</h3><p>双击“飞行记录器”,将会出现“启动飞行记录”窗口。</p><p>在启动飞行记录时,可以进行记录时间、垃圾收集器、编译器、方法采样、线程记录、异常记录、网络和文件I/O、事件记录等选项和频率设定。点击“完成”按钮后马上就会开始记录,记录时间结束以后会生成飞行记录报告：</p><p>飞行记录报告里包含以下几类信息: </p><ul><li>一般信息:关于虚拟机、操作系统和记录的一般信息。</li><li>内存:关于内存管理和垃圾收集的信息。</li><li>代码:关于方法、异常错误、编译和类加载的信息。</li><li>线程:关于应用程序中线程和锁的信息。</li><li>I/O:关于文件和套接字输入、输出的信息。</li><li>系统:关于正在运行Java虚拟机的系统、进程和环境变量的信息。</li><li>事件:关于记录中的事件类型的信息,可以根据线程或堆栈跟踪,按照日志或图形的格式查看。</li></ul><p>JFR的基本工作逻辑是开启一系列事件的录制动作,当某个事件发生时,这个事件的所有上下文数据将会以循环日志的形式被保存至内存或者指定的某个文件当中,循环日志相当于数据流被保留在一个环形缓存中,所以只有最近发生的事件的数据才是可用的。JMC从虚拟机内存或者文件中读取并展示这些事件数据,并通过这些数据进行性能分析。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218105532.png" alt="image-20200920181646036"></p><p>即使不考虑对被测试程序性能影响方面的优势,JFR提供的数据质量通常也要比其他工具通过代理形式采样获得或者从MBean中取得的数据高得多。以垃圾搜集为例,HotSpot的MBean中一般有各个分代大小、收集次数、时间、占用率等数据(根据收集器不同有所差别),这些都属于“结果”类的信息,而JFR中还可以看到内存中这段时间分配了哪些对象、哪些在TLAB中(或外部)分配、分配速率和压力大小如何、分配归属的线程、收集时对象分代晋升的情况等,这些就是属于“过程”类的信息, 对排查问题的价值是难以估量的。</p><h3 id="使用命令行启动飞行记录仪"><a href="#使用命令行启动飞行记录仪" class="headerlink" title="使用命令行启动飞行记录仪"></a>使用命令行启动飞行记录仪</h3><p>解锁JDK的商业特性：</p><pre class="line-numbers language-shell"><code class="language-shell">jcmd 1152 VM.unlock_commercial_features<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用命令行启动JFR</p><pre class="line-numbers language-shell"><code class="language-shell">jcmd 41250 JFR.start delay=10s duration=1m filename=/Users/cc/Desktop/log.jfr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存下来的JFR文件除了JMC可以打开，VisualVm也可以打开。</p><h1 id="HotSpot虚拟机插件及工具"><a href="#HotSpot虚拟机插件及工具" class="headerlink" title="HotSpot虚拟机插件及工具"></a>HotSpot虚拟机插件及工具</h1><p>一些HotSpot研发过程中编写的插件和工具，这些工具大多数都在JDK源码(存放在HotSpot源码<code>hotspot/src/share/tools</code>目录下)中包含：</p><ul><li>Ideal Graph Visualizer:用于可视化展示C2即时编译器是如何将字节码转化为理想图,然后转化为机器码的。</li><li>Client Compiler Visualizer:用于查看C1即时编译器生成高级中间表示(HIR),转换成低级中间表示(LIR)和做物理寄存器分配的过程(源码其实从未进入过HotSpot的代码仓库)。</li><li>MakeDeps:帮助处理HotSpot的编译依赖的工具。</li><li>Project Creator:帮忙生成Visual Studio的.project文件的工具。</li><li>LogCompilation:将<code>-XX:+LogCompilation</code>输出的日志整理成更容易阅读的格式的工具。</li><li>HSDIS:即时编译器的反汇编插件(OpenJDK源码中的位置：hotspot/src/share/tools/hsdis/)。</li></ul><h2 id="HSDIS"><a href="#HSDIS" class="headerlink" title="HSDIS"></a>HSDIS</h2><p>HSDIS是一个被官方推荐的HotSpot虚拟机即时编译代码的反汇编插件,它包含在HotSpot虚拟机的源码当中[2],在OpenJDK的网站[3]也可以找到单独的源码下载,但并没有提供编译后的程序。</p><p>HSDIS插件的作用是让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出,同时还会自动产生大量非常有价值的注释,这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。</p><ul><li>可以根据自己的操作系统和处理器型号,从网上直接搜索（<a href="http://hllvm.group.iteye.com" target="_blank" rel="noopener">HLLVM圈子有编译好的</a>）、下载编译好的插件,直接放到<code>JDK_HOME/jre/bin/server</code>目录(JDK 9以下)或<code>JDK_HOME/lib/amd64/server</code>(JDK 9或以上)中即可使用。</li><li>或者自己用源码编译一遍(网上能找到各种操作系统下的编译教程)。</li></ul><p>另外还有一点需要注意,如果读者使用的是SlowDebug或者FastDebug版的HotSpot,那可以直接通过<code>-XX:+PrintAssembly</code>指令使用的插件;如果读者使用的是Product版的HotSpot,则还要额外加入一个<code>-XX:+UnlockDiagnosticVMOptions</code>参数才可以工作。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 参数： * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly //打印编译器的汇编 * -Xcomp  //使用编译器模式 * -XX:+TraceClassLoading -XX:+LogCompilation  * -XX:LogFile=./logfile.log    //将日志输出到一个文件  * -XX:CompileCommand=dontinline,*Bar.sum -XX:CompileCommand=compileonly,*Bar.sum   //不进行方法内联 *  * @author: honphan.john * @date: 2020/9/19 08:34 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中测试代码比较简单,肉眼直接看日志中的汇编输出是可行的,但在正式环境中<code>-XX:+PrintAssembly</code>的日志输出量巨大,且难以和代码对应起来,这就必须使用工具来辅助了。</p><h3 id="JITWatch"><a href="#JITWatch" class="headerlink" title="JITWatch"></a><a href="https://github.com/AdoptOpenJDK/jitwatch" target="_blank" rel="noopener">JITWatch</a></h3><p>JITWatch是HSDIS经常搭配使用的可视化的编译日志分析工具,为便于在JITWatch中读取。下载JITWatch后即可导入输出的汇编日志，即可进行Java源码、字节码、汇编的对比查看。</p><p># </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/18/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/15-la-ji-hui-shou-qi/"/>
      <url>/2020/09/18/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/15-la-ji-hui-shou-qi/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h1><p>垃圾收集器没有在规范中进行过多的规定,可以由不同的厂商、不同版本的JVM来实现。由于JDK的版本处于高速迭代过程中,因此Java发展至今已经衍生了众多的GC版本。</p><p>从不同角度分析垃圾收集器,可以将GC分为不同的类型。</p><h2 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h2><h3 id="按垃圾回收器的线程数分"><a href="#按垃圾回收器的线程数分" class="headerlink" title="按垃圾回收器的线程数分"></a>按垃圾回收器的线程数分</h3><p>可以分为串行垃圾回收器(单线程处理)和并行垃圾回收器(多线程处理)</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120632.png" alt="image-20200918100326513"></p><ul><li><p>串行回收指的是在同一时间段内只有一个CPU用于执行垃圾回收操作,此时工作线程被暂停,直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合,串行回收器的性能表现可以超过并行回收器和并发回收器。所以,串行回收默认被应用在客户端的 client模式下的JVM中</li><li>在并发能力比较强的CPU上,并行回收器产生的停顿时间要短于串行回收器。</li></ul></li><li><p>和串行回收相反,并行收集可以运用多个CPU同时执行垃圾回收,因此提升了应用的吞吐量。</p></li></ul><blockquote><p>不过这里仅仅是根据回收器的工作线程是并行还是串行的维度来进行分类, 并没有针对是否采用独占式,使用了“stop-the-world”机制维度进行分类。</p></blockquote><h3 id="按照工作模式分"><a href="#按照工作模式分" class="headerlink" title="按照工作模式分"></a>按照工作模式分</h3><p>可以分为并发式(与应用线程)垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作,以尽可能减少应用程序的停顿时间。独占式垃圾回收器(Stop The World)一旦运行,就停止应用程序中的所有用户线程,直到垃圾回收过程完全结束。<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120640.png" alt="image-20200918100948865"></p><h3 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h3><p>可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后,对存活对象进行压缩整理,消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><h3 id="按工作的内存区间分"><a href="#按工作的内存区间分" class="headerlink" title="按工作的内存区间分"></a>按工作的内存区间分</h3><p>又可分为年轻代垃圾回收器和老年代垃圾回收器。</p><h1 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h1><ul><li>暂停时间:执行垃圾收集时,程序的工作线程被暂停的时间。</li><li>吞吐量:运行用户代码的时间占总运行时间的比例<ul><li>(总运行时间:程序的运行时间+内存回收的时间)</li></ul></li><li>内存占用:垃圾回收工作内存占Java堆区的内存大小。</li><li>垃圾收集开销:<u><em>吞吐量</em></u>的补数,垃圾收集所用时间与总运行时间的比例。</li><li>收集频率:相对于应用程序的执行收集操作发生的频率。</li><li>快速:一个对象从诞生到被回收所经历的时间。</li></ul><p><strong>暂停时间</strong>、<strong>吞吐量</strong>和<strong>内存占用</strong>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。这三项里,暂停时间的重要性日益凸显。因为随着硬件发展,内存占用多些越来越能容忍,硬件性能的提升也有助于降低收集器运行时对应用程序的影响,即提高了吞吐量。而内的扩大,对延迟反而带来负面效果。<br>简单来说,主要抓住两点:</p><ul><li>吞吐量</li><li>暂停时间</li></ul><h2 id="吞吐量-throughPUT"><a href="#吞吐量-throughPUT" class="headerlink" title="吞吐量(throughPUT)"></a>吞吐量(throughPUT)</h2><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值,即：</p><pre><code>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。(例如：虚拟机总共运行了100分钟,其中垃圾收集花掉1分钟,那吞吐量就是99%)</code></pre><p>高吞吐量的应用程序有更长的时间基准(即不以单次的响应时长为基准，而是以某单位内总响应时长为基准)，快速响应是不必考虑的，应用程序能容忍较高的暂停时间。</p><p>吞吐量优先,<strong>意味着在单位(基准)时间内,STW的时间之和</strong>最短:0.2+0.2=0.4<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120647.png" alt="image-20200918102140066"></p><h2 id="暂停时间-pause-time"><a href="#暂停时间-pause-time" class="headerlink" title="暂停时间(pause time)"></a>暂停时间(pause time)</h2><p>“暂停时间”是指用户线程被全部暂停以让垃圾回收工作线程执行的期间。例如,GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先,意味着尽可能让单次STW的时间最短:0.1+0.1+0.1+0.1+0.1=0.5<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120653.png" alt="image-20200918102825249"></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上,吞吐量越高程序运行越快。</p></li><li><p>低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型,有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此,具有低的较大暂停时间是非常重要的,特别是对于一个交互式应用程序。</p></li></ul><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标(矛盾)。</p><ul><li>因为如果选择以吞吐量优先,那么必然需要降低内存回收的执行频率,但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的,如果选择以低延迟优先为原则,那么为了降低每次执行内存回收时的暂停时间,也只能频繁地执行内存回收,但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计(或使用)GC算法时,我们必须确定我们的目标:一个GC算法只可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间),或<br>尝试找到一个二者的折衷。</p><p>现在标准: <strong>在最大吞吐量优先的情况下,降低停顿时间</strong>。</p><h1 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h1><p>有了虚拟机,就一定需要收集垃圾的机制这就是Garbage Collection,对应的产品我们称为 Garbage Collector。</p><ul><li>1999年随JDK1.3.1一起来的是串行方式的Serial GC,它是第一款 ParNew垃圾收集器是 Serial收集器的多线程版本</li><li>2002年2月26日, ParalleGC和 Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li><li><strong>Parallel GC在JDK6之后成为HotSpot默认GC</strong></li><li>2012年,在JDK1.7u4版本中,G1可用。</li><li>2017年,<strong>JDK9中G1变成默认的垃圾收集器</strong>,以替代CMS。</li><li>2018年3月,JDK10中G1垃圾回收器的并行完整垃圾回收,实现并行性来改善最坏情况下的延迟。</li><li>2018年9月,JDK11发布。引入 Epsilon垃圾回收器,又被称为”No-op(无操作)”回收器。同时,引入ZGC:可伸缩的低延迟垃圾回收器(Experimental)</li><li>2019年3月,JDK12发布增强G1,自动返回未用堆内存给操作系统。同时,引入Shenandoah GC:低停顿时间的GC(Experimental)</li><li>2019年9月,JDK13发布。增强ZGC,自动返回未用堆内存给操作系统。</li><li>2020年3月,JDK14发布。删除CMS垃圾回收器。扩展ZGC在 macos和Windows上的应用</li></ul><h3 id="7款经典的垃圾回收器的工作线程数"><a href="#7款经典的垃圾回收器的工作线程数" class="headerlink" title="7款经典的垃圾回收器的工作线程数"></a>7款经典的垃圾回收器的工作线程数</h3><ul><li>串行回收器：Serial、Serial Old<ul><li>STW+只有一个垃圾回收线程工作</li></ul></li><li>并行回收器：ParNew、Parallel Scavenge、Parallel Old<ul><li>STW+垃圾回收工作线程并行工作</li></ul></li><li>并发回收器：CMS、G1<ul><li>与用户线程并行执行</li></ul></li></ul><blockquote><p> <a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf" target="_blank" rel="noopener">HotSpot虚拟机内存管理白皮书</a></p></blockquote><h4 id="图示并行、并发、分区"><a href="#图示并行、并发、分区" class="headerlink" title="图示并行、并发、分区"></a>图示并行、并发、分区</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120702.png" alt="image-20200918104428044"></p><h3 id="7款经典收集器与垃圾分代"><a href="#7款经典收集器与垃圾分代" class="headerlink" title="7款经典收集器与垃圾分代"></a>7款经典收集器与垃圾分代</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120712.png" alt="image-20200918104836599"></p><ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge</li><li>老年代收集器：Serial Old、Parallel Old、CMS</li><li>整堆收集器：G1</li></ul><h3 id="垃圾回收器组合"><a href="#垃圾回收器组合" class="headerlink" title="垃圾回收器组合"></a>垃圾回收器组合</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120720.png" alt="image-20200918105011842"></p><ol><li><p>两个收集器间有连线,表明它们可以搭配使用:</p><p>Serial/Serial Old、 Serial/CMS、 ParNew/Serial Old、 ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</p></li><li><p><strong>其中 Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</strong></p></li><li><p>(红色虚线)由于维护和兼容性测试的成本,在JDK8时将 Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP173),并在JDK9中完全取消了这些组合的支持(JEP214),即: 移除。</p></li><li><p>(绿色虚线)JDK14中:弃用 Parallel Scavenge和Serial Old组合(JEP366)</p></li><li><p>(青色虚线)JDK14中:删除CMS垃圾回收器(JEP363)</p></li></ol><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为什么要有很多收集器,一个不够吗?因为ava的使用场景很多,移动端,服务器等。所以就需要针对不同的场景,提供不同的垃圾收集器,提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较,但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在,更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h3 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h3><ul><li><p><code>-XX:+/-PrintCommandLineFlags</code>：程序运行打印命令行相关参数（包含使用的垃圾收集器）</p></li><li><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收参数 进程ID</code></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120727.png" alt="image-20200918110614096"></p></li></ul><h1 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h1><p>Seria收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。Serial收集器作为HotSpot中 <strong>client模式</strong> 下的默认新生代垃圾收集器。</p><p>Serial收集器采用<strong>复制算法、串行回收和”Stop-The-World”机制</strong>的方式执行内存回收。</p><p>除了年轻代之外, Serial收集器还提供用于执行老年代垃圾收集的 Serial Old收集器。 Serial Old收集器同样也采用了<strong>串行回收和”Stop the World”机制</strong>,只不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p><ul><li>Serial Old是运行在client模式下默认的老年代的垃圾回收器</li><li>Serial Old在Server模式下主要有两个用途:<ol><li>与新生代的 Parallel Scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120733.png" alt="image-20200918111327599"></p><p>这个收集器是一个单线程的收集器,但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作,更重要的是在它进行垃圾收集时,必须暂停其他所有的工作线程,直到它收集结束(Stop The World)。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>简单而高效(与其他收集器的单线程比),对于限定单个CPU的环境来说, Serial 收集器由于没有线程交互的开销,专心做垃圾收集自然可以获得最高的单线程收集效率。运行在client模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中,可用内存一般不大(几十MB至一两百MB),可以在较短时间内完成垃圾收集(几十ms至一百多ms),只要不频繁发生,使用串行回收器是可以接受的。</p><h2 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h2><p>在 HotSpot虚拟机中,使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。表示新生代用Serial GC,且老年代用 Serial Old GC（<strong>没有专门指定使用Serial Old GC的选项</strong>）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在已经不用串行了，而且在限定单核cpu才可以用，现在都不是单核的了。对于交互较强的应用而言，这种垃圾收集器是不能接收的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</p><h1 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h1><p>如果说 SerialGC是年轻代中的单线程垃圾收集器,那么 ParNew收集器则是 Serial 收集器的多线程版本。</p><ul><li>Par是Parallel的缩写</li><li><strong>New:只能处理的是新生代</strong></li></ul><p>ParNew收集器除了采用并行回收的方式执行内存回收外,两款垃圾收集器之间几乎没有任何区别。 ParNew收集器在年轻代中同样也是采用复制算法、”Stop-The-World”机制。</p><p>ParNew是很多JVM运行 Server在模式下新生代的默认垃圾收集器。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120741.png" alt="image-20200918112511566"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式（默认情况使用Serial Old，可以指定使用CMS）节省资源(Switch Context)。</li></ul><h2 id="优势对比"><a href="#优势对比" class="headerlink" title="优势对比"></a>优势对比</h2><p>由于 ParNew收集器是基于并行回收,那么是否可以断定 ParNew收集器的回收效率在任何场景下都会比 Serial 收集器更高效?</p><ul><li>ParNew收集器运行在多CPU的环境下,由于可以充分利用多CPU、多核心等物理硬件资源优势,可以更快速地完成垃圾收集,提升程序的吞吐量。</li><li>但是在单个CPU的环境下, ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串 行回收,但是由于CPU不需要频繁地做任务切换,因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>除Serial外,目前只有 ParNew GC能与CMS收集器配合工作</p><h2 id="使用参数-1"><a href="#使用参数-1" class="headerlink" title="使用参数"></a>使用参数</h2><ul><li><p>在程序中，开发人员可以通过选项<code>-XX:+UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</p><ul><li><p>即如果已经指定了老年代收集器如CMS，则使用CMS，如果没有就默认使用Serial Old。</p><p>因为在一开始只有Seiral收集器，它分为Serial新生代和Serial Old老年代两部分，后面发展出现了ParNew可以替代Serial的部分，但是老年代还是只能用Serial Old，再到后面出现了CMS，此时可以指定老年代为CMS。</p></li></ul></li><li><p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数量相同的线程数。</p></li></ul><h1 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h1><p>Hotspot的年轻代中除了拥有ParNew收集器是基于并行回收的以外,Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop The World”机制。那么 Parallel 收集器的出现是否多此一举?</p><ul><li>和 ParNew收集器不同, Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>(Throughput),它也被称为吞吐量优先的垃<br>圾收集器。</li><li><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别</li></ul><p>高吞吐量则可以高效率地利用CPU时间,尽快完成程序的运算任务,主要适合在后台运算而<strong>不需要太多交互</strong>的任务。因此,常见在服务器环境中使用。例如,那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器, 用来代替老年代的 Serial Old收集器。Parallel Old收集器采用了<strong>标记-压缩算法</strong>,但同样也是基于并行回收和”Stop-The-World”机制。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120749.png" alt="image-20200918115632298"></p><h1 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h1><p>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><h1 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h1><ul><li><code>-XX:+UseParallelGC</code>手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</li><li><code>-XX:+UseParallelOldGC</code>手动指定老年代都是使用并行回收收集器。<ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数,默认开启一个,另一个也会被开启。(互相激活)</li><li><strong>如果在设置其中一个参数的时候同时设置一个其他的收集器会报错。</strong></li></ul></li><li><code>-XX: ParallelGCThreads=&lt;N&gt;</code>设置年轻代并行收集器的线程数。一般地,最好与CPU数量相等,以避免过多的线程数影响垃圾收集性能。<ul><li>在默认情况下,当CPU数量小于8个,<code>ParallelGCThreads</code>的值等于CPU数量。</li><li>当CPU数量大于8个, ParallelGCThreads的值等于 <code>3+[5*CPU_COUNT]/8]</code>。</li></ul></li><li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。<ul><li>为了尽可能地把停顿时间控制在<code>MaxGCPauseMillis</code>以内,收集器在工作时会调整Java堆大小或者其他一些参数。</li><li>对于用户来讲,停顿时间越短体验越好；但是在服务器端,我们注重高并发,整体的吞吐量。所以服务器端适合 Parallel,进行控制。</li><li>该参数使用需谨慎。</li></ul></li><li><code>-XX:GCTimeRatio=&lt;N&gt;</code>垃圾收集时间占总时间的比例<code>(=1/(N+1))</code>。用于衡量吞吐量的大小。<ul><li>取值范围(0,100)。默认值99,也就是垃圾回收时间不超过1%。</li><li>与前一个<code>-XX: MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长, Radio参数就容易超过设定的比例。</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code>设置 Parallel Scavenge收集器具有自适应调节策略<ul><li>在这种模式下,年轻代的大小、Eden和 Survivor的比例、晋升老年代的对象年龄等参数会被自动调整,以达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合,可以直接使用这种自适应的方式, 仅指定虚拟机的最大堆<code>-Xmx</code>、目标的吞吐量(<code>GCTimeRatio</code>)和停顿时间(<code>MaxGCPauseMillis</code>),让虚拟机自己完成调优工作。</li></ul></li></ul><h1 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h1><p>在JDK1.5时期, HotSpot推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器:CMS(Concurrent-Mark-Sweep)收集器,这款收集器是 HotSpot虚拟机中第一款真正意义上的并发收集器,它第一次实现了<strong>让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短(低延迟)就越适合与用户交互的程序,良好的响应速度能提升用户体验。</p><ul><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上,这类应用尤其重视服务的响应速度,希望系统停顿时间最短,以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li><li>CMS的垃圾收集算法采用标记-清除算法,并且也会”Stop-The-World”。</li></ul><p>不幸的是,CMS作为老年代的收集器,却无法与JDK1.4.0中已经存在的新生代收集器 Parallel Scavenge配合工作,所以在JDK1.5中使用CMS来收集老年代的时候,新生代只能选择 ParNew或者Serial收集器中的一个。</p><p>在G1出现之前,CMS使用还是非常广泛的。一直到今天,仍然有很多系统使用 CMS GC。</p><h2 id="CMS工作阶段"><a href="#CMS工作阶段" class="headerlink" title="CMS工作阶段"></a>CMS工作阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120757.png" alt="image-20200918141846706"></p><p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段,即<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong>。</p><ul><li>初始标记(Initial-Mark)阶段:在这个阶段中,程序中所有的工作线程都将会因为<strong>“Stop-The-Word”</strong>机制而出现短暂的暂停,这个阶段的主要任务仅仅只是标记出 GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小,所以这里的速度非常快。</li><li>并发标记(Concurrent-Mark)阶段:从 GC Roots的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行。</li><li>重新标记( Remark)阶段:由于在并发标记阶段中,程序的工作线程会和垃圾收集线程同时运行或者交叉运行,因此为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段再次<strong>STW</strong>，本次停顿时间通常会比初始标记阶段稍长一些,但也远比并发标记阶段的时间短。</li><li>并发清除(Concurrent-Sweep)阶段:此阶段清理删除掉标记阶段判断的已经死亡的对象,释放内存空间。<strong>由于不需要移动存活对象</strong>,所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管CMS收集器采用的是并发回收(非独占式),但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-The-World”机制暂停程序中的工作线程,不过暂停时间并不会太长,因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-The-World”,只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作,所以整体的回收是低停顿的。</p><p>另外,由于在垃圾收集阶段用户线程没有中断,所以在CMS回收过程中,<strong>还应该确保应用程序用户线程有足够的内存可用</strong>。因此,CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集,<strong>而是当堆内存使用率达到某一阈值时,便开始进行回收</strong>,以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要,就会出现一次<strong>“Concurrent Mode Failure”</strong>失败,这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集,这样停顿时间就很长了。</p><h2 id="CMS的标记清除算法"><a href="#CMS的标记清除算法" class="headerlink" title="CMS的标记清除算法"></a>CMS的标记清除算法</h2><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除</strong>算法,这意味着每次执行完内存回收后,由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块,不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时,将无法使用指针碰撞(Bump the Pointer)技术,而只能够选择空闲列表(Free List)执行内存分配。<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120804.png" alt="image-20200918142904676"></p><h3 id="为什么不用标记整理算法"><a href="#为什么不用标记整理算法" class="headerlink" title="为什么不用标记整理算法"></a>为什么不用标记整理算法</h3><p>因为CMS追求短延迟(STW时间)，而在内存整理期间，是要移动对象的内存位置的，此时引用了这些对象的其它对象就要对引用进行修改，这个阶段必须要STW，不然会数据错乱。</p><h2 id="CMS的优点"><a href="#CMS的优点" class="headerlink" title="CMS的优点:"></a>CMS的优点:</h2><ul><li>并发收集</li><li>低延迟</li></ul><h2 id="CMS的弊端"><a href="#CMS的弊端" class="headerlink" title="CMS的弊端:"></a>CMS的弊端:</h2><ol><li>会产生内存碎片,导致并发清除后,用户线程可用的空间不足。在无法分配大对象的情况下,不得不提前触发Full GC</li><li>CMS收集器对CPU资源非常敏感。在并发阶段,它虽然不会导致用户停顿,但是会因为占用了一部分线程而导致应用程序变慢,总吞吐量会降低。</li><li>可能出现“Concurrent Mode Failure”失败而导致另一次Fu11 GC的产生。</li><li>CMS收集器无法处理浮动垃圾。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的,那么在并发标记阶段如果产生新的垃圾对象,CMS将无法对这些垃圾对象进行标记,最终会导致这些新产生的垃圾对象没有被及时回收,从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ol><h2 id="使用参数-2"><a href="#使用参数-2" class="headerlink" title="使用参数"></a>使用参数</h2><ul><li><p><code>-XX:+UseConcMarkSweepGC</code>手动指定使用CMS收集器执行内存回收任务。</p><ul><li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>开。即: ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。</li></ul></li><li><p><code>-XX:CMSInitiatingOccupanyFraction=&lt;N&gt;</code>设置堆内存使用率的阈值,一旦达到该阈值,便开始进行回收。</p><ul><li>JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时,会执行一次CMS回收。JDK6及以上版本默认值为92%<ul><li>如果内存增长缓慢,则可以设置一个稍大的值,大的阈值可以有效降低CMS的触发频率,减少老年代回收的次数可以较为明显地改善应用程序性能。</li><li>反之,如果应用程序内存使用率增长很快,则应该降低这个阈值,以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li></ul></li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code><strong>用于指定在执行完Full GC后对内存空间进行压缩整理</strong>,以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行,所带来的问题就是停顿时间变得更长了。</p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction=&lt;N&gt;</code>设置在<strong>执行多少次Fu1lGC后对内存空间进行压缩整理</strong>。</p></li><li><p><code>-XX: ParallelCMSThreads=&lt;N&gt;</code>设置CMS的线程数量。</p><ul><li>CMS默认启动的线程数是(ParallelGCThreads+3)/4, 是年轻代并行收集器的线程数。当CPU资源比较紧张时,受到CMS收集器线程的影响,应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h1 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h1><p>既然我们已经有了前面几个强大的GC,为什么还要发布 Garbage First(G1) GC?</p><p>原因就在于应用程序所应对的业务越来越庞大、复杂,用户越来越多,没有GC就不能保证应用程序正常进行,而经常造成STW的GC又跟不上实际的需求,所以才会不断地尝试对GC进行优化。G1(Garbage-First)垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器,是当今收集器技术发展的最前沿成果之一。</p><p>与此同时,为了适应现在不断扩大的内存和不断增加的处理器数量,<strong>进一步降低暂停时间(pause time),同时兼顾良好的吞吐量</strong>。官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量,所以才担当起“全功能收集器”的重任与期望。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>为什么名字叫做 Garbage First(G1)呢?</p><p>因为G1是一个并行回收器,它把堆内存分割为很多不相关的区域(Region)(物理上不连续的)。使用不同的 Region来表示Eden、幸存者0区,幸存者1区,老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的 Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间(Region),所以我们给G1一个名字:垃圾优先(Garbage First)。</p><h3 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h3><p>G1(Garbage-First)是一款面向服务端应用的垃圾收集器,主要针对配备多核CPU及大容量内存的机器,以极高概率满足GC停顿时间的同时,还兼具高吞吐量的性能特征。</p><p>在JDK1.7版本正式启用,移除了 Experimental 的标识,是JDK9以后的默认垃圾回收器,取代了CMS回收器以及 Parallel+ Parallel old组合。被 Oracle官方称为“全功能的垃圾收集器”。与此同时,CMS已经在JDK9中被标记为废弃(deprecated)。</p><p>在JDK8中G1还不是默认的垃圾回收器,需要使用<code>-XX:+UseG1GC</code>来启用。</p><h2 id="G1回收器的特点-优势"><a href="#G1回收器的特点-优势" class="headerlink" title="G1回收器的特点(优势)"></a>G1回收器的特点(优势)</h2><p>与其他GC收集器相比,G1使用了全新的分区算法,其特点如下所示:</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul><li>并行性:G1在回收期间,可以有多个GC线程同时工作,有效利用多核计算能力。此时用户线程STW</li><li>并发性:G1拥有与应用程序交替执行的能力,部分工作可以和应用程序同时执行,  因此,一般来说,不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><ul><li>从分代上看,G1依然属于分代型垃圾回收器,它会区分年轻代和老年代,年轻代依然有Eden区 Survivor和区。但从堆的结构上看,它不要求整个Eden区、年轻代或者老年代都是连续的,也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域(Region),这些区域中包含了逻辑上的年轻代和老年代。和之前的各类回收器不同,它同时兼顾年轻代和老年代。对比其他回收器,或者工作在年轻代,或者工作在老年代。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120815.png" alt="image-20200918150258888"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120822.png" alt="image-20200918150309556"></p><h3 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h3><ul><li>CMS:“标记-清除”算法、内存碎片若干次GC后进行一次碎片整理</li><li>G1将内存划分为一个个的。内存的回收是以 region作为基本单位的。Region之间是复制算法,但整体上实际可看作是标记-压缩(Mark-Compact)算法,两种算法都可以避免内存碎片。这种特性有利于程序长时间运行,分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候,G1的优势更加明显。</li></ul><h3 id="可预测的停顿时间模型-即-软实时soft-real-time"><a href="#可预测的停顿时间模型-即-软实时soft-real-time" class="headerlink" title="可预测的停顿时间模型(即:软实时soft real-time)"></a>可预测的停顿时间模型(即:软实时soft real-time)</h3><p>这是G1相对于CMS的另一大优势,G1除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li><p>由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制。</p></li><li><p>G1跟踪各个 Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的 Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p></li><li><p>相比于CMS GC,G1未必能做到CMS在最好情况下的延时停顿,但是最差情况要好很多。</p></li></ul><h2 id="对比CMS"><a href="#对比CMS" class="headerlink" title="对比CMS"></a>对比CMS</h2><p>相较于CMS,G1还不具备全方位、压倒性优势。比如在用户程序运行过程中,G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。</p><p>从经验上来说,<strong>在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势</strong>。平衡点在6-8GB之间。</p><h2 id="使用参数-3"><a href="#使用参数-3" class="headerlink" title="使用参数"></a>使用参数</h2><ul><li><code>-XX:+UseG1GC</code>手动指定使用G1收集器执行内存回收任务。</li><li><code>-XX:G1HeapRegionSize=&lt;N&gt;</code>设置每个 Region的大小。值是2的幂,范围是1MB到32MB之间,目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>设置期望达到的最大GC停顿时间指标(JVM会尽力实现,但不保证达到)。默认值是200ms</li><li><code>-XX:ParallelGCThread=&lt;N&gt;</code>设置STW工作线程数的值。最多设置为8</li><li><code>-XX:ConcGCThreads=&lt;n&gt;</code>设置并发标记的线程数。将N设置为并行垃圾回收线程数(<code>ParallelGCThreads</code>)的1/4左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent=&lt;N&gt;</code>设置触发并发GC周期的Java堆占用率阈值。超过此值,就触发GC。默认值是45</li></ul><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><p>G1的设计原则就是简化VM性能调优,开发人员只需要简单的三步即可完成调优:</p><ul><li>第一步:开启G1垃圾收集器</li><li>第二步:设置堆的最大内存</li><li>第三步:设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式: YoungGC、 Mixed GC和Full GC,在不同的条件下被触发。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>面向服务端应用,针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)</li><li>最主要的应用是需要低GC延迟,并具有大堆的应用程序提供解决方案<ul><li>如:在堆大小约6GB或更大时,可预测的暂停时间可以低于0.5秒;(G1通过每次只清理一部分而不是全部的 Region的增量式清理来保证每次GC停顿时间不会过长)。</li></ul></li><li>用来替换掉JDK1.5中的CMS收集器;在下面的情况时,使用G1可能比CMS好:<ol><li>超过50%的Java堆被活动数据占用;</li><li>对象分配频率或年代提升频率变化很大;</li><li>GC停顿时间过长(长于0.5至1秒)。</li></ol></li><li>HotSpot垃圾收集器里,除了G1以外,其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作,而G1 GC可以采用应用线程承担后台运行的GC工作,即当JVM的GC线程处理速度慢时,系统会调用应用程序线程帮助加速垃圾回收过程。</li></ul><h2 id="分区-Region-化整为零"><a href="#分区-Region-化整为零" class="headerlink" title="分区 Region:化整为零"></a>分区 Region:化整为零</h2><p>使用G1收集器时,它将整个Java堆划分成约2048个大小相同的独立 Region块,每个Region块大小根据堆空间的实际大小而定,整体被控制在1MB到32MB之间,且为2的N次幂,即1MB,2MB,4MB,8MB,16MB,32MB可以通过<code>-XX:G1HeapRegionSize=&lt;N&gt;</code>设定。所有的 Region大小相同,且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念,但新生代和老年代不再是物理隔离的了,它们都是一部分 Region(不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。 </p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120831.png" alt="image-20200918152658094"></p><p>一个region有可能属于Eden, Survivor或者old/Tenured内存区域。但是一个 region只可能属于一个角色。图中的E表示该 region属于Eden内存区域,S表示属于 Survivor内存区域,O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域,叫做 Humongous内存区域,如图中的H块。主要用于存储大对象,如果超过1.5个region,就放到H。</p><h3 id="设置H的原因？？？？？？"><a href="#设置H的原因？？？？？？" class="headerlink" title="设置H的原因？？？？？？"></a>设置H的原因？？？？？？</h3><p>对于堆中的大对象,默认直接会被分配到老年代,但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题,G1划分 Humongous了一个区,它用来专门存放大对象。如果一个H区装不下一个大对象,那么G1会寻找连续的H区来存储。为了能找到连续的H区,有时候不得不启动FullGC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><h3 id="指针碰撞与TLAB"><a href="#指针碰撞与TLAB" class="headerlink" title="指针碰撞与TLAB"></a>指针碰撞与TLAB</h3><ul><li>每个region中使用指针碰撞进行内存分配。</li><li>可能存在TLAB区域</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120837.png" alt="image-20200918153043508"></p><h2 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h2><p>G1 GC的垃圾回收过程主要包括如下三个环节:</p><ul><li>年轻代GC(Young GC)</li><li>老年代并发标记过程(Concurrent Marking)</li><li>混合回收(Mixed GC)</li><li>(如果需要,单线程、独占式、高强度的Fu11 GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制,即强力回收。)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120844.png" alt="image-20200918153421896"></p><h3 id="大体步骤"><a href="#大体步骤" class="headerlink" title="大体步骤"></a>大体步骤</h3><ol><li><p>应用程序分配内存,当年轻代的Eden区用尽时开始年轻代回收过程;G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期,G1 GC暂停所有应用程序线程,启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor区间或者老年区间,也有可能是两个区间都会涉及。</p></li><li><p>当堆内存使用达到一定值(默认45%)时,开始老年代并发标记过程。</p></li><li><p>标记完成马上开始混合回收过程。对于一个混合回收期,G1 GC从老年区间移动存活对象到空闲区间,这些空闲区间也就成为了老年代的一部分。和年轻代不同,老年代的G1回收器和其他GC不同,G1的老年代回收器不需要整个老年代被回收,一次只需要扫描/回收一小部分老年代的 Region就可以了。同时,这个老年代 Region是和年轻代一起被回收的。</p><p>举个例子:一个Web服务器,Java进程最大堆内存为4G,每分钟响应1500个请求,每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收,每31个小时整个堆的使用率会达到45%,会开始老年代并发标记过程,标记完成后开始四到五次的混合回收。</p></li></ol><h3 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h3><ul><li><p>一个对象被不同区域引用的问题：</p><p>一个Region不可能是孤立的,一个Region中的对象可能被其他任意中对象引用,判断对象存活时,是否需要扫描整个Java堆才能保证准确？在其他的分代收集器,也存在这样的问题(而G1更突出)回收新生代也不得不同时扫描老年代?这样的话会降低Minor GC的效率。</p></li><li><p>解决方法:</p><ol><li><p>无论G1还是其他分代收集器,JVM都是使用Remembered Set来避免全局扫描:每个Region都有一个对应的Remembered Set。</p></li><li><p>每次Reference类型数据写操作时,都会产生一个 Write Barrier(写屏障)暂时中断操作</p></li><li><p>然后检查将要写入的引用指向的对象是否和该 Reference类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象);</p></li><li><p>如果不同,通过CardTable把相关引用信息记录到引用指向对象的所在 Region对应的 Remembered Set中（<strong>即记录引用了本Region的数据的引用地址</strong>）;</p></li><li><p>当进行垃圾收集时,在GC根节点的枚举范围加入 Remembered Set，就可以保证不进行全局扫描,也不会有遗漏。</p></li></ol></li><li><p>R Set示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120851.png" alt="image-20200918154406803"></p></li></ul><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="1-gt-YoungGC"><a href="#1-gt-YoungGC" class="headerlink" title="1&gt;YoungGC"></a>1&gt;YoungGC</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p>JVM启动时,G1先准备好Eden区,程序在运行过程中不断创建对象到Eden区,当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程。年轻代垃圾回收只会回收Eden区和 Survivor区。YGC时,首先G1停止应用程序的执行(Stop-The-World),G1创建回收集( Collection Set),回收集是指需要被回收的内存分段的集合,年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><h6 id="回收前"><a href="#回收前" class="headerlink" title="回收前"></a>回收前</h6><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120858.png" alt="image-20200918155156083"></p><h6 id="回收后"><a href="#回收后" class="headerlink" title="回收后"></a>回收后</h6><ol><li><p>坐标为(0,2)、(3,1)、(3,2)、(3,6)的1个Survior from区和3个Eden区region被分析到回收价值大，并经过计算可以将三个区域的数据压缩到(0,1)region（它们的数据没满）。</p></li><li><p>坐标为(0,6)、(1,5)、(1,6)的1个Survior from区和2个Eden区region被分析到回收价值大，并经过计算可以将三个区域的数据压缩到(2,3)region（它们的数据没满）。</p></li><li><p>而(1,5)的Survior from区数据被判定需要晋升为老年代，然后被复制到了(3,5)</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120905.png" alt="image-20200918155209036"></p><h5 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述"></a>详细描述</h5><h6 id="第一阶段-扫描根"><a href="#第一阶段-扫描根" class="headerlink" title="第一阶段,扫描根"></a>第一阶段,扫描根</h6><p>GC Roots连同 Rset 记录的外部引用作为扫描存活对象的入口。</p><h6 id="第二阶段-更新RSet"><a href="#第二阶段-更新RSet" class="headerlink" title="第二阶段,更新RSet"></a>第二阶段,更新RSet</h6><p>处理dirty card queue[^1]中的card,更新 Rset.此阶段完成后,Rset可以准确的反映老年代对所在的内存分段中对象的引用。</p><p>那为什么不在引用赋值语句处直接更新RSet呢?是为了性能的需要,RSet的处理需要线程同步开销会很大,使用队列性能会好很多</p><h6 id="第三阶段-处理RSet"><a href="#第三阶段-处理RSet" class="headerlink" title="第三阶段,处理RSet"></a>第三阶段,处理RSet</h6><p>识别被老年代对象指向的Eden中的对象,这些被指向的Eden中的对象被认为是存活的对象。</p><h6 id="第四阶段-复制对象"><a href="#第四阶段-复制对象" class="headerlink" title="第四阶段,复制对象"></a>第四阶段,复制对象</h6><p>此阶段,对象树被遍历,Eden区内存段中存活的对象会被复制到 Survivor区中空的内存分段, Survivor区内存段中存活的对象如果年龄未达阈值,年龄会加1,达到阀值会被会被复制到Old区中空的内存分段。如果 Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间。</p><h6 id="第五阶段-处理引用"><a href="#第五阶段-处理引用" class="headerlink" title="第五阶段,处理引用"></a>第五阶段,处理引用</h6><p>处理Soft,Weak,Phantom,Final,JNI Weak等引用。最终Eden空间的数据为空,GC停止工作,而目标内存中的对象都是连续存储的,没有碎片,所以复制过程可以达到内存整理的效果,减少碎片。</p><p>[^1]: 应用程序的引用赋值语句 object field= object，JVM会在之前和之后执行特殊的错左以在dirty card queue中入队一个保存了对象引用信息的card在年轻代回收的时候,G1会对 Dirty Card Queue 中所有的card进行处理,更新RSet,保证RSet实时准确的反映引用关系</p><h4 id="2-gt-并发标记过程"><a href="#2-gt-并发标记过程" class="headerlink" title="2&gt;并发标记过程"></a>2&gt;并发标记过程</h4><h5 id="1-初始标记阶段"><a href="#1-初始标记阶段" class="headerlink" title="1)初始标记阶段:"></a>1)初始标记阶段:</h5><p>标记从根节点直接可达的对象。这个阶段是STW的,并且会触发一次年轻代GC。</p><h5 id="2-根区域扫描-Root-Region-Scanning"><a href="#2-根区域扫描-Root-Region-Scanning" class="headerlink" title="2)根区域扫描(Root Region Scanning)"></a>2)根区域扫描(Root Region Scanning)</h5><p>G1 GC扫描Survivor区直接可达的老年代区域对象,并标记被引用的对象。这一过程必须在 Young GC之前完成。</p><h5 id="3-并发标记-Concurrent-Marking"><a href="#3-并发标记-Concurrent-Marking" class="headerlink" title="3)并发标记(Concurrent Marking)"></a>3)并发标记(Concurrent Marking)</h5><p>在整个堆中进行并发标记(和应用程序并发执行),此过程可能被 Young GC中断。<strong>在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。</strong>同时,并发标记过程中,会计算每个区域的对象活性(区域中存活对象的比例)。</p><h5 id="4-再次标记-Remark"><a href="#4-再次标记-Remark" class="headerlink" title="4)再次标记(Remark)"></a>4)再次标记(Remark)</h5><p>由于应用程序持续进行,需要修正上一次的标记结果，STW。G1中采用了比CMS更快的初始快照算法: snapshot-at-the-beginning(SATB)。</p><h5 id="5-独占清理-cleanup-STW"><a href="#5-独占清理-cleanup-STW" class="headerlink" title="5)独占清理(cleanup,STW)"></a>5)独占清理(cleanup,STW)</h5><p>计算各个区域的存活对象和GC回收比例,并进行排序, 识别可以混合回收的区域。为下阶段做铺垫。STW。这个阶段并不会实际上去做垃圾的收集。</p><h5 id="6-并发清理阶段"><a href="#6-并发清理阶段" class="headerlink" title="6)并发清理阶段"></a>6)并发清理阶段</h5><p>识别并清理完全空闲的区域。</p><h4 id="3-gt-混合回收"><a href="#3-gt-混合回收" class="headerlink" title="3&gt;混合回收"></a>3&gt;混合回收</h4><p>当越来越多的对象晋升到老年代Old Region时,为了避免堆内存被耗尽,虚拟机会触发一个混合的垃圾收集器,即 Mixed GC,该算法并不是一个Old GC,除了回收<strong>整个</strong>Young Region,还会回收<strong>一部分</strong>的Old Region。这里需要注意:是一部分老年代,而不是全部老年代。可以选择哪些Old Region进行收集,从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC并不是Full GC。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120913.png" alt="image-20200918162819176"></p><ul><li><p>并发标记结束以后,老年代中百分百为垃圾的内存分段被回收了,部分为垃圾的内存分段被计算了出来。默认情况下,这些老年代的内存分段会分8次(可以通过<code>-XX:G1MixedGCCountTarget=&lt;N&gt;</code>设置)被回收。</p></li><li><p>混合回收的回收集(collection Set)包括八分之一的老年代内存分段,Eden区内存分段, Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样,只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p></li><li><p>由于老年代中的内存分段默认分8次回收,G1会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的</strong>,越会被先回收。并且有一个阈值会决定内存分段是否被回收, <code>-XX:G1MixedGCLiveThresholdPercent=&lt;N&gt;</code>, 默认为65%,意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低,意味着存活的对象占比高,在复制的时候会花费更多的时间。</p></li><li><p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code> ,默认值为10%, 意思是允许整个堆内存中有10%的空间被浪费,意味着如果发现可以回收的垃圾占堆内存的比例低于10%,则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p></li></ul><h4 id="4-gt-Full-GC"><a href="#4-gt-Full-GC" class="headerlink" title="4&gt;Full GC"></a>4&gt;Full GC</h4><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作,G1会停止应用程序的执行(Stop-The-World),使用单线程的内存回收算法进行垃圾回收,性能会非常差,应用程序停顿时间会很长。</p><p>要避免FullGC的发生,一旦发生需要进行调整。什么时候会发生Full GC呢?比如堆内存太小,当G1在复制存活对象的时候没有空的内存分段可用,则会回退到Full GC,这种情况可以通过增大内存解决。导致G1 Full GC的原因可能有两个:</p><ol><li>Evacuation的时候没有足够的to-space来存放晋升的对象。</li><li>并发处理过程完成之前空间耗尽。</li></ol><h2 id="关于G1回收阶段的STW"><a href="#关于G1回收阶段的STW" class="headerlink" title="关于G1回收阶段的STW"></a>关于G1回收阶段的STW</h2><p>从 oracle官方透露出来的信息可获知,回收阶段(Evacuation)其实本也有想过设计成与用户程序一起并发执行,但这件事情做起来比较复<br>杂,考虑到G1只是回Region收一部分,停顿时间是用户可控制的,所以并不迫切去实现,而选择把这个特性放到了G1之后出现的低延迟垃圾<br>收集器(即ZGC)中。另外,还考虑到G1不是仅仅面向低延迟,停顿用户线程能够最大幅度提高垃圾收集效率,为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h2 id="G1优化建议"><a href="#G1优化建议" class="headerlink" title="G1优化建议"></a>G1优化建议</h2><ul><li><p>年轻代大小</p><p>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标</p></li><li><p>暂停时间目标不要太过严苛</p><p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间。评估G1 GC的吞吐量时,暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销,而这些会直接影响到吞吐量。</p></li></ul><h1 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h1><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，要根据具体的情况选用不同的垃圾收集器。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120921.png" alt="image-20200918164309707"></p><h2 id="GC发展阶段"><a href="#GC发展阶段" class="headerlink" title="GC发展阶段"></a>GC发展阶段</h2><p>Serial-&gt;Parallel-&gt;CMS-&gt;G1-&gt;ZGC。</p><p>除了一个面向高吞吐量一个面向低延迟的目标不一致外,技术上的原因是Parallel Scavenge收集器及后面提到的G1收集器等都没有使用HotSpot中原本设计的垃圾收集器的分代框架,而选择另外独立实现。Serial、ParNew收集器则共用了这部分的框架代码,详细可参考: <a href="https://blogs.oracle.com/jonthecollector/our_collectors" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/our_collectors</a>。</p><h3 id="废弃的回收器"><a href="#废弃的回收器" class="headerlink" title="废弃的回收器"></a>废弃的回收器</h3><ul><li>JDK9新特性:CMS被标记为 Deprecate(JEP291)<ul><li>如果对JDK9及以上版本的 HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话,用户会收到一个警告信息,提示CMS未来将会被废弃。</li></ul></li><li>JDK14新特性:删除CMS圾回收器(JEP363)<ul><li>移除了CMS垃圾收集器,如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话,JVM不会报错,只是给出一个warning信息,但是不会exit。VM会自动回退以默认GC方式启动JVM<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120930.png" alt="image-20200918145000481"></li></ul></li></ul><h2 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器?"></a>怎么选择垃圾回收器?</h2><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择选择合适的垃圾收集器可以让VM的性能有一个很大的提升。<br>怎么选择垃圾收集器?</p><ol><li>优先调整堆的大小让VM自适应完成。</li><li>如果内存小于100M,使用串行收集器</li><li>如果是单核、单机程序, 并且没有停顿时间的要求,串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒, 选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间,需快速响应(比如延迟不能超过1秒,如互联网应用),使用并发收集器。官方推荐G1,性能高。现在互联网的项目,基本都是使用G1。</li></ol><h2 id="垃圾收集器搭配总结"><a href="#垃圾收集器搭配总结" class="headerlink" title="垃圾收集器搭配总结"></a>垃圾收集器搭配总结</h2><ol><li><p>设置UseSerialGC的语义就是指定串行垃圾回收器，会指定新生代收集为Serial，老年代收集为Serial Old。</p></li><li><p>设置UseParNewGC的语义就是设置新生代收集为ParNew，如果老年代没有被指定就使用Serial Old（ParNew只能搭配CMS和Serial Old使用，设置其他的会报错）。</p></li><li><p>只启用UseParrelGC或者只启用UseParrelOldGC或者两者都启用的时候，其语义都是设置新生代老年代GC为Parallel(Scavenge)的。</p><p>启用UseParrelGC以及关闭UseParrelOldGC(<code>-XX:-UseParralOldGC</code>)的语义是新生代GC为Parallel的，老年代GC为Serial Old。</p><p>剩下的其它搭配都会报错。</p></li><li><p>上面描述到Serial和ParNew的默认老年代回收器是Serial Old，另外可以显示配置使用CMS(<code>-XX:+UseConcMarkSweepGC</code>)。</p></li><li><p>使用<code>-XX:+UseConcMarkSweepGC</code>选项激活CMS后的默认新生代收集器是ParNew收集器(不是Serial)，可以使用<code>-XX:+/-UseParNewGC</code>选项来强制指定或者禁用它。</p></li><li><p>另外Serial Old是CMS的一个backup。</p></li><li><p>G1是整堆收集器，只能显示启用它自己。</p></li><li><p>JDK6开始到JDK8默认的垃圾收集器是Parallel组合；JDK9为G1。</p></li></ol><h1 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h1><h2 id="内存分配与垃圾回收的参数"><a href="#内存分配与垃圾回收的参数" class="headerlink" title="内存分配与垃圾回收的参数"></a>内存分配与垃圾回收的参数</h2><h3 id="JDK9之前"><a href="#JDK9之前" class="headerlink" title="JDK9之前"></a>JDK9之前</h3><ol><li><p><code>-XX:+PrintGC</code>    # 输出GC日志。类似 -verbose:gc</p><p>输出信息<img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120939.png" alt="image-20200918171108035"></p><p>解析</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120942.png" alt="image-20200918171120084"></p></li><li><p><code>-XX:+PrintGCDetails</code>    # 输出GC的详细日志</p><p>输出信息</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120957.png" alt="image-20200918171453022"></p><p>解析</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120948.png" alt="image-20200918171517595"></p></li><li><p><code>-XX:+PrintGCTimeStamps</code>    # 在输出GC日志的时候，增加输出时间戳(从JVM启动依赖经历了多长时间)</p><p>输出信息</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121007.png" alt="image-20200918171820638"></p></li><li><p><code>-XX:+PrintGCDateStamps</code>    # 在输出GC日志的时候，增加输出GC的时间戳(以日期的形式,如2013-05-04T21:53:59.234+0800)</p><p>输出信息</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121015.png" alt="image-20200918171808838"></p></li><li><p><code>-XX:+PrintHeapAtGC</code>    # 在进行GC的前后打印出堆的信息</p></li><li><p><code>-X1oggc:../1ogs/gc.1og</code>    # 日志文件的输出路径</p></li></ol><h3 id="JDK9及之后"><a href="#JDK9及之后" class="headerlink" title="JDK9及之后"></a>JDK9及之后</h3><p>HotSpot所有功能的日志都收归到了“-Xlog”参数上,这个参数的能力也相应被极大拓展了:</p><pre class="line-numbers language-shell"><code class="language-shell">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令行中最关键的参数是选择器(Selector),它由标签(Tag)和日志级别(Level)共同组成。<br>标签可理解为虚拟机中某个功能模块的名字,它告诉日志框架用户希望得到虚拟机哪些功能的日志输出。垃圾收集器的标签名称为“gc”,由此可见,垃圾收集器日志只是HotSpot众多功能日志的其中一项,支持的功能模块标签名如下所示:</p><pre class="line-numbers language-shell"><code class="language-shell">add,age,alloc,annotation,aot,arguments,attach,barrier,biasedlocking,blocks,bot,breakpoint,bytecode......<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>日志级别从低到高,共有Trace,Debug,Info,Warning,Error,Off六种级别,日志级别决定了输出信息的详细程度,默认级别为Info,HotSpot的日志规则与Log4j、SLF4j这类Java日志框架大体上是一致的。另外,还可以使用修饰器(Decorator)来要求每行日志输出都附加上额外的内容,支持附加在日志行上的信息包括: </p><ul><li>time:当前日期和时间。</li><li>uptime:虚拟机启动到现在经过的时间,以秒为单位。</li><li>timemillis:当前时间的毫秒数,相当于System.currentTimeMillis()的输出。</li><li>uptimemillis:虚拟机启动到现在经过的毫秒数。</li><li>timenanos:当前时间的纳秒数,相当于System.nanoTime()的输出。</li><li>uptimenanos:虚拟机启动到现在经过的纳秒数。</li><li>pid:进程ID。</li><li>tid:线程ID。</li><li>level:日志级别。</li></ul><p>tags:日志输出的标签集。<br>如果不指定,默认值是uptime、level、tags这三个,此时日志输出类似于以下形式:</p><pre class="line-numbers language-shell"><code class="language-shell">[3.080s][info][gc,cpu] GC(5) User=0.03s Sys=0.00s Real=0.01s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="GC日志中的时间"><a href="#GC日志中的时间" class="headerlink" title="GC日志中的时间"></a>GC日志中的时间</h3><ul><li>user:进程执行用户态代码所耗费的处理器时间。</li><li>sys:进程执行核心态代码所耗费的处理器时间。</li><li>real:执行动作从开始到结束耗费的时钟时间。</li></ul><p>请注意,前面两个是处理器时间,而最后一个是时钟时间,它们的区别是处理器时间代表的是线程占用处理器一个核心的耗时计数,而时钟时间就是现实世界中的时间计数。</p><p>如果是单核单线程的场景下,这两者可以认为是等价的,但如果是多核环境下,同一个时钟时间内有多少处理器核心正在工作,就会有多少倍的处理器时间被消耗和记录下来（即 user = coreNum <em> userTimePerCore、sys = coreNum </em> sysTimePerCore ）。</p><p>在垃圾收集调优时,我们主要依据real时间为目标来优化程序,因为最终用户只关心发出请求到得到响应所花费的时间,也就是响应速度,而不太关心程序到底使用了多少个线程或者处理器来完成任务。</p><h3 id="一些JDK9前后的例子"><a href="#一些JDK9前后的例子" class="headerlink" title="一些JDK9前后的例子"></a>一些JDK9前后的例子</h3><h4 id="例1：打印GC基本信息"><a href="#例1：打印GC基本信息" class="headerlink" title="例1：打印GC基本信息"></a>例1：打印GC基本信息</h4><p>在JDK 9之前使用<code>-XX:+PrintGC</code>,JDK 9后使用<code>-Xlog:gc</code></p><h4 id="例2：打印详细GC信息"><a href="#例2：打印详细GC信息" class="headerlink" title="例2：打印详细GC信息"></a>例2：打印详细GC信息</h4><p>在JDK 9之前使用<code>-XX:+PrintGCDetails</code>,在JDK 9之后使用<code>-Xlog:gc*</code>, 用通配符<code>*</code>将GC标签下所有细分过程都打印出来,如果把日志级别调整到Debug或者Trace(基于版面篇幅考虑,例子中并没有),还将获得更多细节信息</p><h4 id="例3：打印GC前后的堆、方法区容量"><a href="#例3：打印GC前后的堆、方法区容量" class="headerlink" title="例3：打印GC前后的堆、方法区容量"></a>例3：打印GC前后的堆、方法区容量</h4><p>在JDK 9之前使用<code>-XX:+PrintHeapAtGC</code>,JDK 9之后使用<code>-Xlog:gc+heap=debug</code></p><h4 id="例4：查看GC过程中用户线程并发时间以及停顿的时间"><a href="#例4：查看GC过程中用户线程并发时间以及停顿的时间" class="headerlink" title="例4：查看GC过程中用户线程并发时间以及停顿的时间"></a>例4：查看GC过程中用户线程并发时间以及停顿的时间</h4><p>在JDK 9之前使用<code>-XX:+PrintGCApplicationConcurrentTime</code>以及<code>-XX:+PrintGCApplicationStoppedTime</code>, JDK 9之后使用<code>-Xlog:safepoint</code></p><h4 id="例5：查看收集器Ergonomics机制"><a href="#例5：查看收集器Ergonomics机制" class="headerlink" title="例5：查看收集器Ergonomics机制"></a>例5：查看收集器Ergonomics机制</h4><p>即自动设置堆空间各分代区域大小、收集目标等内容。从Parallel收集器开始支持自动调节的相关信息。在JDK 9之前使用<code>-XX:+PrintAdaptiveSizePolicy</code>,JDK 9之后使用<code>-Xlog:gc+ergo*=trace</code></p><h4 id="例6：查看熬过收集后剩余对象的年龄分布信息"><a href="#例6：查看熬过收集后剩余对象的年龄分布信息" class="headerlink" title="例6：查看熬过收集后剩余对象的年龄分布信息"></a>例6：查看熬过收集后剩余对象的年龄分布信息</h4><p>在JDK 9前使用<code>-XX:+PrintTenuringDistribution</code>, JDK 9之后使用<code>-Xlog:gc+age=trace</code></p><h3 id="JDK9中废弃的日志参数及替换列表"><a href="#JDK9中废弃的日志参数及替换列表" class="headerlink" title="JDK9中废弃的日志参数及替换列表"></a>JDK9中废弃的日志参数及替换列表</h3><p><a href="file:///Users/zhonghongpeng/笔记/jvm/尚硅谷/附录.md" target="_blank" rel="noopener">参考</a></p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h4 id="GC日志打印组成"><a href="#GC日志打印组成" class="headerlink" title="GC日志打印组成"></a>GC日志打印组成</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121025.png" alt="image-20200918172138361"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121033.png" alt="image-20200918172208169"></p><h4 id="堆空间输出组成"><a href="#堆空间输出组成" class="headerlink" title="堆空间输出组成"></a>堆空间输出组成</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121039.png" alt="image-20200918172252516"></p><h4 id="Minor-GC日志组成"><a href="#Minor-GC日志组成" class="headerlink" title="Minor GC日志组成"></a>Minor GC日志组成</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121049.png" alt="image-20200918172424412"></p><h4 id="Full-GC日志组成"><a href="#Full-GC日志组成" class="headerlink" title="Full GC日志组成"></a>Full GC日志组成</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121056.png" alt="image-20200918172534060"></p><h2 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h2><p>可以配合<code>-X1oggc</code>输出日志然后用一些工具去分析这些GC日志。</p><p>常用的日志分析工具有：<a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener">GCViewer</a>、<a href="https://gceasy.io/" target="_blank" rel="noopener">GCEasy</a>、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</p><h1 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h1><p>GC仍然处于飞速发展之中,目前的默认选项G1 GC在不断的进行改进,很多我们原来认为的缺点,例如串行的Full GC、 Card Table扫描的低效等,都已经被大幅改进, 例如, JDK10以后, Full GC已经是并行运行,在很多场景下,其表现还略优于 Parallel GC的并行Full GC实现。</p><p>即使是 Serial GC,虽然比较古老,但是简单的设计和实现未必就是过时的,它本身的开销,不管是GC相关数据结构的开销,还是线程的开销,都是非常小的,所以随着云计算的兴起,在 Serverless等新的应用场景下, Serial GC找到了新的舞台。</p><p>比较不幸的是 CMS GC,因为其算法的理论缺陷等原因,虽然现在还有非常大的用户群体,但在JDK9中已经被标记为废弃,并在JDK14版本中移除。</p><h2 id="JDK11新特性"><a href="#JDK11新特性" class="headerlink" title="JDK11新特性"></a>JDK11新特性</h2><ul><li><p><a href="http://openjdk.java.net/jeps/318" target="_blank" rel="noopener">JEP318</a></p><p>Epsilon：A No-Op Garbage Collector(Epsilon 垃圾回收器，”No-Op”无操作回收器)</p></li><li><p>JEP333</p><p>ZGC(JDK11)：A Scalable Low-Latency Garbage Collector(Experimental)（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121103.png" alt="image-20200918174255760"></p><h2 id="Open-JDK12：Shenandoah"><a href="#Open-JDK12：Shenandoah" class="headerlink" title="Open JDK12：Shenandoah"></a>Open JDK12：Shenandoah</h2><p>Open JDK12的Shenandoah GC：低停顿时间的GC(实验性)。<br>Shenandoah,无疑是众多GC中最孤独的一个。是第一款不由 Oracle公司团队领导开发的 HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称 OpenJDK和 OracleJDK没有区别的Oracle公司仍拒绝在Oracle JDK12中支持 Shenandoah。</p><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目 PauselessGC 的实现,旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给 OpenJDK.</p><p>Red Hat研发团队对外宣称, <strong>Shenandoah垃圾回收器的暂停时间与堆大小无关</strong>,这意味着无论将堆设置为200MB还是200GB,99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><h3 id="Shenandoah开发团队在实际应用中的测试数据"><a href="#Shenandoah开发团队在实际应用中的测试数据" class="headerlink" title="Shenandoah开发团队在实际应用中的测试数据"></a>Shenandoah开发团队在实际应用中的测试数据</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121112.png" alt="image-20200918175024741"></p><p>这是 RedHat在2016年发表的论文数据,测试内容是使用ES对200GB的维基百科数据进行索引。从结果看:</p><ul><li>停顿时间比其他几款收集器确实有了质的飞跃,但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降,总运行时间是所有测试收集器里最长的。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h3><ul><li>Shenandoah GC的弱项:高运行负担下的吞吐量下降。</li><li>Shenandoah GC的强项:低延迟时间。</li></ul><p>Shenandoah GC的工作过程大致分为九个阶段，参考<a href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&seid=12339069673726242866" target="_blank" rel="noopener">JDK12新特性</a>。</p><h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning/" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/gctuning/</a> </p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121119.png" alt="image-20200918175746290"></p><ul><li><p>ZGC与 Shenandoah目标高度相似,在尽可能对吞吐量影响不大的前提下, 实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p></li><li><p>《深入理解Java虚拟机》一书中这样定义ZGC：</p><p>ZGC收集器是一款基于 Region内存布局的,(暂时)不设分代的,使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记压缩算法的,以低延迟为首要目标的一款垃圾收集器。</p></li><li><p>ZGC的工作过程可以分为4个阶段:并发标记-并发预备重分配并发重分配并发重映射等。</p></li><li><p>ZGC几乎在所有地方并发执行的,除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上,这部分的实际时间是非常少的。</p></li></ul><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121127.png" alt="image-20200918175941331"></p><h4 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121135.png" alt="image-20200918180107249"></p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用”令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><h3 id="ZGC的JDK14新特性"><a href="#ZGC的JDK14新特性" class="headerlink" title="ZGC的JDK14新特性"></a>ZGC的JDK14新特性</h3><ul><li>JEP364:ZGC应用 macos在上</li><li>JEP365:ZGC应用 Windows在上</li></ul><p>JDK14之前,ZGC仅 Linux才支持。尽管许多使用ZGC的用户都使用类Linux的环境,但在 Windows和 macos上,人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此,ZGC特性被移植到了 Windows和 macos上。</p><p>现在mac或Windows上也能使用ZGC了,示例如下:</p><ul><li><p><code>-XX:+UnlockExperimentalVMOption</code></p></li><li><p><code>-XX:+UseZGC</code></p></li></ul><h2 id="其他垃圾回收器"><a href="#其他垃圾回收器" class="headerlink" title="其他垃圾回收器"></a>其他垃圾回收器</h2><h3 id="AliGC"><a href="#AliGC" class="headerlink" title="AliGC"></a>AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218121142.png" alt="image-20200918180601848"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当然,其他厂商也提供了各种独具一格的GC实现, 例如比较有名的低延迟GC, <a href="https://www.infoq.com/articles/azul_gc_in_detail" target="_blank" rel="noopener">Zing</a>,</p><h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><p><a href="https://www.infoq.cn/article/3WyReTKqrHIvtw4frmr3" target="_blank" rel="noopener">infoq：一文看懂 JVM 内存布局及 GC 原理</a></p><p><a href="https://juejin.im/post/6844903953004494856#heading-6" target="_blank" rel="noopener">掘金：老大难的GC原理及调优，这下全说清楚了</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/18/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/14-gc-guan-jian-gai-nian-bu-chong/"/>
      <url>/2020/09/18/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/14-gc-guan-jian-gai-nian-bu-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a><code>System.gc()</code>的理解</h1><p>在默认情况下,通过 <code>System.gc()</code>者 <code>Runtime.getRuntime().gc()</code>的调用,<strong>会显式触发Full GC</strong>,同时对老年代和新生代进行回收,尝试释放被丢弃对象占用的内存。然而<code>System.gc()</code>调用附带一个免责声明,无法保证对垃圾收集器的调用。</p><p>JVM实现者可以通过<code>System.gc()</code>调用来决定JVM的GC行为。而一般情况下,垃圾回收应该是自动进行的,无须手动触发,否则就太过于麻烦了。在一些特殊情况下,如我们正在编写一个性能基准,我们可以在运行之间调用<code>System.gc()</code>。</p><p><code>System.runFinalization()</code>方法会强制调用所有进入F-Queue的对象的<code>finalize()</code>方法(只有重写了该方法才会进入该Queue)。</p><h1 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h1><h2 id="内存溢出-OOM"><a href="#内存溢出-OOM" class="headerlink" title="内存溢出(OOM)"></a>内存溢出(OOM)</h2><p>内存溢出相对于内存泄漏来说,尽管更容易被理解,但是同样的,内存溢出也是引发程序崩溃的罪魁祸首之一。由于GC一直在发展,所有一般情况下除非应用程序占用的内存增长速度非常快,造成垃圾回收已经跟不上内存消耗的速度,否则不太容易出现OOM的情况。</p><p>大多数情况下,GC会进行各种年龄段的垃圾回收,实在不行了就放大招,来一次独占式的Full GC操作,这时候会回收大量的内存,供应用程序继续使用。</p><p>javadoc中对OutOfMemoryError的解释是,没有空闲内存,并且垃圾收集器也无法提供更多内存。</p><h3 id="一般原因"><a href="#一般原因" class="headerlink" title="一般原因"></a>一般原因</h3><p>首先说没有空闲内存的情况:说明Java虚拟机的堆内存不够。原因有二:</p><ol><li><p>Java虚拟机的堆内存设置过小。</p><p>比如:可能存在内存泄漏问题;也很有可能就是堆的大小不合理,比如我们要处理比较可观的数据量,但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code>、<code>-Xmx</code>来调整</p></li><li><p>代码中创建了大量大对象,并且长时间不能被垃圾收集器收集(存在被引用)</p><p>对于老版本的 Oracle JDK,因为永久代的大小是有限的,并且JVM对永久代垃圾回收(如,常量池回收、卸载不再需要的类型)非常不积极,所以当我们不断添加新类型的时候,永久代出现OutOfMemoryError也非常多见,尤其是在运行时存在大量动态类型生成的场合;类似 intern字符串缓存占用太多空间,也会导致OOM问题。对应的异常信息,会标记出来和永久代相关:<code>java.lang.OutofMemoryError: PermGen space</code>。</p><p>随着元数据区的引入,方法区内存已经不再那么窘迫,所以相应的OOM有所改观,出现OOM,异常信息则变成了:<code>java.lang.OutOfMemoryError: Metaspace</code>。直接内存不足,也会导致OOM。</p></li></ol><blockquote><p>这里面隐含着一层意思是,在抛出 OutOfMemoryError之前,通常垃圾收集器会被触发,尽其所能去清理出空间。</p><ul><li>例如:在引用机制分析中,涉及到JVM会去尝试回收软引用指向的对象等。</li><li>在<code>java.nio.Bits#reserveMemory()</code>方法中,我们能清楚的看到, <code>System.gc()</code>会被调用,以清理空间。</li></ul><p>自然,也不是在任何情况下垃圾收集器都会被触发的。</p><ul><li>比如,我们去分配一个超大对象,类似一个超大数组超过堆的最大值,JVM可以判断出垃圾收集并不能解决这个问题,所以直接抛出 OutOfMemoryError</li></ul></blockquote><h2 id="内存泄露-Memory-Leak"><a href="#内存泄露-Memory-Leak" class="headerlink" title="内存泄露(Memory Leak)"></a>内存泄露(Memory Leak)</h2><p>也称作“存储渗漏”。严格来说,只有对象不会再被程序用到了,但是GC又不能回收他们的情况,才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致OOM,也可以叫做宽泛意义上的“内存泄漏”。</p><p>尽管内存泄漏并不会立刻引起程序崩溃,但是一旦发生内存泄漏,程序中的可用内存就会被逐步蚕食,直至耗尽所有内存,最终出现 OutOfMemory，导致程序崩溃。</p><p>注意,这里的存储空间并不是指物理内存,而是指虚拟内存大小,这个虚拟内存大小取决于磁盘交换区设定的大小。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例:"></a>举例:</h3><p>1、单例模式<br>单例的生命周期和应用程序是一样长的,所以单例程序中,如果持有对外部对象的引用的话,那么这个外部对象是不能被回收的,则会导致内存泄漏的产生。<br>2、一些 close提供的资源未关闭导致内存泄漏<br>数据库连接(<code>dataSourse#getConnection()</code>),网络连接(socket)和io连接必须手动close,否则是不能被回收的。</p><h1 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h1><p>Stop-The-World,简称STW,指的是GC事件发生过程中,会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停,没有任何响应,有点像卡死的感觉,这个停顿称为STW。</p><ul><li>可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化,则分析结果的准确性无法保证</li></ul></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复,频繁中断会让用户感觉像是网速不快造成电影卡带一样,所以我们需要减少STW的发生。</p><p>目前为止，STW事件和采用哪款GC无关,所有的GC都有这个事件。哪怕是G1也不能完全避免Stop-The-World情况发生,只能说垃圾回收器越来越优秀,回收效率越来越高,尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下,把用户正常的工作线程全部停掉。</p><p>开发中不要用 <code>System.gc();</code>会导致Stop-The-World的发生。</p><h1 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h1><h2 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发(Concurrent)"></a>并发(Concurrent)</h2><p>在操作系统中,是指一个时间段中有几个程序都处于已启动运行到运行完毕之间,且这几个程序都是在同一个处理器上运行。并发不是真正意义上的“同时进行”,只是CPU把一个时间段划分成几个时间片段(时间区间),然后在这几个时间区间之间来回切换,由于CPU处理的速度非常快,只要时间间隔处理得当,即可让用户感觉是多个应用程序同时在进行。<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120535.png" alt="image-20200918084337086"></p><h2 id="并行-Parallel"><a href="#并行-Parallel" class="headerlink" title="并行(Parallel)"></a>并行(Parallel)</h2><p>当系统有一个以上CPU时,当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,两个线程互不抢占CPU资源,可以同时进行,我们称之为并行(Parallel)。</p><p>其实决定并行的因素不是CPU的数量,而是CPU的核心数量,比如一个CPU多个核也可以并行。适合科学计算,后台处理等弱交互场景</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120541.png" alt="image-20200918084645787"></p><h2 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h2><p>并发和并行,在谈论垃圾收集器的上下文语境中,它们可以解释如下:</p><ul><li><p>并行(Parallel):指多条垃圾收集线程并行工作,但此时用户线程仍处于等待状态。</p><ul><li>如ParNew、 Parallel Scavenge、 Parallel Old;</li></ul></li><li><p>串行(Serial)</p><ul><li><p>相较于并行的概念,单线程执行。</p></li><li><p>如果内存不够,则程序暂停,启动JVM垃圾回收器进行垃圾回收。回收完,再启动程序的线程。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120545.png" alt="image-20200918084912731"></p></li></ul></li><li><p>并行(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行的,可能会交替执行),垃圾回收线程在执行时不会停顿用户程序的运行。</p><ul><li>用户程序在继续运行,而垃圾收集程序线程运行于另一个CPU上</li><li>如:CMS、G1</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120551.png" alt="image-20200918085237660"></p></li></ul><h1 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h1><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>程序执行时并非在所有地方都能停顿下来开始GC,只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点(Safepoint)”。</p><p>Safe Point的选择很重要,如果太少可能导致GC等待的时间太长,如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂,通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择一些执行时间较长的指令作为 Safe Point,如方法调用、循环跳转和异常跳转等。因为：</p><ul><li>当需要发生GC的时候，通常是因为内存紧张了，这时候我们是希望可以尽快进入GC的</li><li>但是GC的时候有个关键点就是如何在GC的过程识别出哪些内存空间是一个对象</li><li>而Hotspot使用的是准确式GC，使用一个OopMap的结构记录引用对象的位置，在用户字节码的间隙插入记录OopMap的代码</li><li>所以我们在GC的时候需要保证所有用户线程中的对象的引用都被记录到OopMap中了才能进行，那么以尽快进入GC的理想条件当然是在每一次发生对象赋值的时候都插入一行记录OopMap的代码</li><li>但是这样对内存和CPU的额外消耗会很大，所以综合起来考虑在一些”执行周期可能会很长的指令”之前插入记录OopMap的代码就可以得到一个权衡。</li></ul><h3 id="循环跳转的安全点优化"><a href="#循环跳转的安全点优化" class="headerlink" title="循环跳转的安全点优化"></a>循环跳转的安全点优化</h3><p>为了避免安全点过多带来过重的负担,对循环还有一项优化措施,认为循环次数较少的话,执行时间应该也不会太长,所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环(Counted Loop),相对应地,使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环(Uncounted Loop),将会被放置安全点。通常情况下这个优化措施是可行的,但循环执行的时间不单单是由其次数决定,如果循环体单次执行就特别慢,那即使是可数循环也可能会耗费很多的时间。</p><p>使用<code>-XX:+UseCountedLoopSafepoints</code>可以强制在可数循环跳转前放置安全点，但是JDK8中有bug。</p><h3 id="实现用户线程在安全点挂起"><a href="#实现用户线程在安全点挂起" class="headerlink" title="实现用户线程在安全点挂起"></a>实现用户线程在安全点挂起</h3><p>如何在GC发生时,检查所有线程都跑到最近的安全点停顿下来呢?</p><ul><li><p>抢先式中断:(目前没有虚拟机采用了)</p><p>首先中断所有线程。如果还有线程不在安全点,就恢复线程,让线程跑到安全点。</p></li><li><p>主动式中断:<br>设置一个中断标志,各个线程运行到Safe Point的时候主动轮询这个标志,如果中断标志为真,就会产生一个自陷信号，当前线程会被操作系统中断然后在JVM为该信号预先注册的异常处理器中挂起</p></li></ul><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>Safepoint机制保证了程序执行时,在不太长的时间内就会遇到可进入GC的 Safepoint。但是,程序“不执行”的时候呢?例如线程处于 Sleep状态或 Blocked状态,这时候线程无法响应JVM的中断请求,“走”到安全点去中断挂起,VM也不太可能等待线程被唤醒。对于这种情况,就需要安全区域(Safe Region)来解决。</p><p><strong>安全区域是指在一段代码片段中,对象的引用关系不会发生变化,在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把 Safe Region看做是被扩展了的 Safepoint。</p><h3 id="实际执行时"><a href="#实际执行时" class="headerlink" title="实际执行时:"></a>实际执行时:</h3><ol><li>当线程运行到 Safe Region的代码时,首先标识已经进入了 Safe Reion,如果这段时间内发生GC,JVM会忽略 Safe Region 标识为状态的线程;</li><li>当线程即将离开 Safe Region时,会检查JVM是否已经完成GC,如果完成了,则继续运行,否则线程必须等待直到收到可以安全离开 Safe Region的信号为止。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>在JDK1.2版之后,Java对引用的概念进行了扩充,将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种,这4种引用强度依次逐渐减弱。</p><p>除强引用外,其他3种引用均可以在<code>java.lang.ref</code>包中找到它们的身影。如下图,显示了这3种引用类型对应的类,开发人员可以在应用程序中直接使用它们:</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120602.png" alt="image-20200918090609957"></p><p><code>Reference</code>子类中只有终结器引用是包内可见的,其他3种引用类型均为 <code>public</code>,可以在应用程序中直接使用</p><ul><li>强引用(StrongReference):最传统的“引用”的定义,是指在程序代码之中普遍存在的引用赋值,即类似<code>Object obj= Object()</code>这种引用关系。无论任何情况下,只要强引用关系还存在,垃圾收集器就永远不会回收掉被引用的对象</li><li>软引用(SoftReference):在系统将要发生内存溢出之前,将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存,才会抛出内存溢出异常。</li><li>弱引用(WeakReference):被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时,无论内存空间是否足够,都会回收掉被弱引用关联的对象。</li><li>虚引用(PhantomReference):一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>在Java程序中,最常见的引用类型是强引用(普通系统99%以上都是强引用),也就是我们最常见的普通对象引用,也是默认的引用类型。当在Java语言中使用new操作符创建一个新的对象,并将其赋值给一个变量的时候,这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的,垃圾收集器就永远不会回收掉被引用的对象。对于一个普通的对象,如果没有其他的引用关系,只要超过了引用的作用域或者显式地将相应(强)引用赋值为nu1,就是可以当做垃圾被收集了,当然具体回收时机还是要看垃圾收集策略。</p><p>相对的,软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的,在一定条件下,都是可以被回收的。所以,强引用是造成Java内存泄漏的主要原因之一。</p><h3 id="强引用例子"><a href="#强引用例子" class="headerlink" title="强引用例子"></a>强引用例子</h3><pre class="line-numbers language-java"><code class="language-java">StringBuffer str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>局部变量str指向 <code>StringBuffer</code>实例所在堆空间,通过str可以操作该实例,那么str就 <code>StringBuffer</code>是实例的强引用<br>对应内存结构:<br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120611.png" alt="image-20200918091626405"></p><p>此时，如果再运行一个赋值语句：</p><pre class="line-numbers language-java"><code class="language-java">StringBuffer str1 <span class="token operator">=</span> str<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对应内存结构：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120616.png" alt="image-20200918091712769"></p><p>本例中的两个引用,都是强引用,强引用具备以下特点:</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收虚拟机宁愿抛出OOM,也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是用来描述一些还有用,但非必需的对象。只被软引用关联着的对象<strong>在系统将要发生内存溢出异常前</strong>,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存,才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的缓存比如:高速缓存就有用到软引用。如果还有空闲内存,就可以暂时保留缓存,当内存不足时清理掉,这样就保证了使用缓存的同时,不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候,会清理软引用,并可选地把引用存放到一个引用队列(Reference Queue)。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在JDK1.2之后提供了<code>java.lang.ref.SoftReference</code>类来实现软引用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//第一种</span>Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明强引用</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//弱引用</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//销毁强引用，此时该对象只剩一个弱引用</span><span class="token comment" spellcheck="true">//第二种：直接是软引用</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//弱引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用也是用来描述那些非必需对象,被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<strong>在系统GC时,只要发现弱引用,不管系统堆空间使用是否充足</strong>,都会回收掉只被弱引用关联的对象。</p><p>但是,由于垃圾回收器的线程通常优先级很低,因此,并不一定能很快地发现持有弱引用的对象。在这种情况下,弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样,在构造弱引用时,也可以指定一个引用队列,当弱引用对象被回收时,就会加入指定的引用队列,通过这个队列可以跟踪对象的回收情况。</p><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做,当系统内存不足时,这些缓存数据会被回收,不会导致内存溢出。而当内存资源充足时,这些缓存数据又可以存在相当长的时间,从而起到加速系统的作用。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>在JDK 1.2版之后提供了<code>java.lang.ref.WeakReference</code>类来实现弱引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//第一种</span>Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明强引用</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//软引用</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//销毁强引用，此时该对象只剩一个软引用</span><span class="token comment" spellcheck="true">//第二种：直接是软引用</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//软引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>弱引用对象与软引用对象的最大不同就在于,当GC在进行回收时,需要通过算法检查是否回收软引用对象,而对于弱引用对象,GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><h2 id="虚引用-对象回收跟踪"><a href="#虚引用-对象回收跟踪" class="headerlink" title="虚引用(对象回收跟踪)"></a>虚引用(对象回收跟踪)</h2><p>也称为“幽灵引用”或者“幻影引用”,是所有引用类型中最弱的一个。一个对象是否有虚引用的存在,完全不会决定对象的生命周期。如果一个对象仅持有虚引用,那么它和没有引用几乎是一样的,随时都可能被垃圾回收器回收。</p><p>它不能单独使用,也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时,总是nu11。</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如:能在这个对象被收集器回收时收到一个系统通知。</p><h3 id="使用和例子"><a href="#使用和例子" class="headerlink" title="使用和例子"></a>使用和例子</h3><p>虚引用必须和引用队列<code>java.lang.ref.ReferenceQueue</code>一起使用，<strong>虚引用在创建时必须提供一个引用队列作为参数</strong>(只有一个两参构造器)。当垃圾回收器准备回收一个对象时,如果发现它还有虚引用,<strong>就会在回收对象后,将这个虚引用加入引用队列</strong>,以通知应用程序对象的回收情况。</p><p>由于虚引用可以跟踪对象的回收时间,因此,也可以将一些资源释放操作放置在虚引用中执行和记录。</p><p>在JDK1.2版之后提供了 <code>PhantomReference</code>类来实现虚引用。</p><pre class="line-numbers language-java"><code class="language-java">Object obj<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ReferenceQueue phantomQueue <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> phantomQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个详细例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> PhantomReferenceTest obj<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> ReferenceQueue<span class="token operator">&lt;</span>PhantomReferenceTest<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Runnable check <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            PhantomReference<span class="token operator">&lt;</span>PhantomReferenceTest<span class="token operator">></span> phantomRef <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                phantomRef <span class="token operator">=</span><span class="token punctuation">(</span>PhantomReference<span class="token operator">&lt;</span>PhantomReferenceTest<span class="token operator">></span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>phantomRef <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追踪垃圾回收过程：PhantomReferenceTest实例被GC了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了finalize()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>check<span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReferenceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PhantomReference<span class="token operator">&lt;</span>PhantomReferenceTest<span class="token operator">></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"无法获取虚引用中的对象："</span> <span class="token operator">+</span> phantomRef<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//强引用去除</span>        obj <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第一次GC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj 是 null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj 可用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二次GC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj <span class="token operator">=</span> null<span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj 是 null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"obj 可用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//无法获取虚引用中的对象：null</span><span class="token comment" spellcheck="true">//第一次GC</span><span class="token comment" spellcheck="true">//调用了finalize()</span><span class="token comment" spellcheck="true">//obj 可用</span><span class="token comment" spellcheck="true">//第二次GC</span><span class="token comment" spellcheck="true">//obj 是 null</span><span class="token comment" spellcheck="true">//追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>参考上面的虚引用中<code>ReferenceQueue</code>引用队列的使用，对于虚引用来说，必须指定一个引用队列，而弱引用和软引用则会有两个构造函数，一个是仅接收一个强引用、另一个是接收一个强引用和引用队列，所以引用队列对于所有非强引用都是可用的，只是虚引用被强制必须使用。</p><h2 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h2><p>它用以实现对象的 <code>finalize()</code>方法,也可以称为终结器引用。无需手动编码,其内部配合引用队列使用<strong>(使用权限为<code>default</code>，包外不可使用)</strong>。在GC时,终结器引用入队。由 Finalizer线程通过终结器引用找到被引用对象并调用它的 <code>finalize()</code>方法,第二次GC时才能回收被引用对象。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/13-gc-gai-shu-ji-suan-fa-si-xiang/"/>
      <url>/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/13-gc-gai-shu-ji-suan-fa-si-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾收集,不是Java语言的伴生产物。早在1960年,第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。<br>关于垃圾收集有三个经典问题:</p><ul><li>哪些内存需要回收?</li><li>什么时候回收?</li><li>如何回收?</li></ul><p>垃圾收集机制是Java的招牌能力,极大地提高了开发效率。如今,垃圾收集几乎成为现代语言的标配,即使经过如此长时间的发展,Java的垃<br>圾收集机制仍然在不断的演进中,不同大小的设备、不同特征的应用场景,对垃圾收集提出了新的挑战。</p><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>什么是垃圾( Garbage)呢?</p><p>“垃圾是指在运行程序中没有任何指针指向的对象,这个对象就是需要被回收的垃圾”。如果不及时对内存中的垃圾进行清理,那么,这些垃圾对象所占的内存空间会一直保留到应用程序结束,被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><p>对于高级语言来说,一个基本认知是如果不进行垃圾回收,内存迟早都会被消耗完因为不断地分配内存空间而不进行回收就好像不停地生产生活垃圾而从来不打扫一样。<br>除了释放没用的对象,垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端,以便JVM将整理出的足够大的内存分配给新的对象。<br>随着应用程序所应付的业务越来越庞大、复杂,用户越来越多,没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求,所以才会不断地尝试对GC进行优化。</p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>在早期的C/C++时代,垃圾回收基本上是手工进行的。开发人员可以使用<code>new</code>关键字进行内存申请,并使用 <code>delete</code>关键字进行内存释放。比如以下代码:</p><pre class="line-numbers language-c++"><code class="language-c++">MibBridgepBridge= new cmBaseGroupBridge();//如果注册失败,使用Delete释放该对象所占内存区域if(pBridge->Register()!= NO ERROR)    delete pBridge;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式可以灵活控制内存释放的时间,但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收,那么就会产生内存泄漏,垃圾对象永远无法被清除,随着系统运行时间的不断增长,垃圾对象所耗内存可能持续上升,直到出现内存溢出并造成应用程序崩溃。</p><p>在有了垃圾回收机制后,上述代码块极有可能变成这样:</p><pre class="line-numbers language-c++"><code class="language-c++">MibBridgepBridge= new cmBaseGroupBridge();pBridge->Register(kDestroy);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在,除了Java以外 C#、 Python、Ruby等语言都使用了自动垃圾回收的思想,也是未来发展趋势。可以说这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p><h2 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h2><p>自动内存管理,无需开发人员手动参与内存的分配与回收,这样降低内存泄漏和内存溢出的风险</p><ul><li>没有垃圾回收器,java也会和cpp一样,各种悬垂指针,野指针,泄露问题让你头疼不已。</li></ul><p>自动内存管理机制,将程序员从繁重的内存管理中释放出来,可以更专心地专注于业务开发。</p><blockquote><p>[oracle官网关于垃圾回收的介绍](<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc</a>. html)</p></blockquote><p>对于Java开发人员而言,自动内存管理就像是一个黑匣子,如果过度依赖于“自动”,那么这将会是一场灾难,最严重的就会弱化ava开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时,了解JVM的自动内存分配和内存回收原理就显得非常重要,只有在真正了解JVM是如何管理内存后,我们才能够在遇见 OutofMemoryError时,快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时,当垃圾收集成为系统达到更高并发量的瓶颈时,我们就必须对这些“自动化”的技术实施必要的监控和调节。</p><h3 id="GC作用区域"><a href="#GC作用区域" class="headerlink" title="GC作用区域"></a>GC作用区域</h3><p>下面漏了直接内存，直接内存也会GC。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120312.png" alt="image-20200917195635270"></p><p>垃圾回收器可以对年轻代回收,也可以对老年代回收,甚至是全堆和方法区的回收。</p><p>其中,Java堆是垃圾收集器的工作重点。<br>从次数上讲:</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不动Perm区</li></ul><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="垃圾标记阶段-对象存活判断"><a href="#垃圾标记阶段-对象存活判断" class="headerlink" title="垃圾标记阶段:对象存活判断"></a>垃圾标记阶段:对象存活判断</h2><p>在堆里存放着几乎所有的Java对象实例,在GC执行垃圾回收之前,首先需要区分出内存中哪些是存活对象,哪些是已经死亡的对象。只有被标记为己经死亡的对象,GC才会在执行垃圾回收时,释放掉其所占用的内存空间,因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说,当一个对象已经不再被任何的存活对象继续引用时,就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式:<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h3 id="标记阶段：引用记数算法"><a href="#标记阶段：引用记数算法" class="headerlink" title="标记阶段：引用记数算法"></a>标记阶段：引用记数算法</h3><p>引用计数算法(Reference Counting)比较简单,对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加1;当引用失效时,引用计数器就减1。只要对象A的引用计数器的值为0即表示对象A不可能再被使用,可进行回收。</p><ul><li><p>优点:实现简单,垃圾对象便于辨识;判定效率高,回收没有延迟性。</p></li><li><p>缺点:</p><ul><li><p>它需要单独的字段存储计数器,这样的做法增加了存储空间的开销。</p></li><li><p>每次赋值都需要更新计数器,伴随着加法和减法操作,这增加了时间开销。</p></li><li><p>引用计数器有一个严重的问题,即无法处理循环引用的情况。这是一条致命缺陷,导致在Java的垃圾回收器中没有使用这类算法。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120323.png" alt="image-20200917200717565"></p></li></ul></li></ul><p>引用计数算法,是很多语言的资源回收选择,例如因人工智能而更加火热的 Python,它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的,业界有大规模实践中仅保留引用计数机制,以提高吞吐量的尝试。</p><p>Java并没有选择引用计数,是因为其存在一个基本的难题,也就是很难处理循环引用关系。</p><p>Python如何解决循环引用?</p><ul><li>手动解除:很好理解,就是在合适的时机,解除引用关系。</li><li>使用弱引用weakref, weakref是Python提供的标准库,旨在解决循环引用。 编译器/解释器本身在对成员变量赋值引用类型数据之前检查是否发生循环引用，是的话将当前引用包装为弱引用，弱引用不会增加计数。</li></ul><h3 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h3><p>可达性分析算法又称根搜索算法、追踪性垃圾收集。相对于引用计数算法而言,可达性分析算法不仅同样具备实现简单和执行高效等特点,更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题,防止内存泄漏的发生。</p><p>相较于引用计数算法,这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集(Tracing Garbage<br> Collection)。</p><p>所谓”GC Roots”根集合就是一组必须活跃的引用</p><p>基本思路:</p><ul><li>可达性分析算法是以根对象集合(GC Roots)为起始点,按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后,内存中的存活对象都会被根对象集合直接或间接连接着,搜索所走过的路径称为引用链(Reference Chain)。<ul><li>如果目标对象没有任何引用链相连,则是不可达的,就意味着该对象己经死亡,可以标记为垃圾对象。</li><li>在可达性分析算法中,只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120330.png" alt="image-20200917202219017"></p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在Java语言中, GC Roots包括几类元素:</p><ul><li>虚拟机栈中引用的对象<ul><li>比如:各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI(通常说的本地方法)引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如:Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如:字符串常量池(StringTable)里的引用</li></ul></li><li>所有被同步锁 synchronized持有的对象</li><li>Java虚拟机内部的引用。</li><li>基本数据类型对应的Class对象,一些常驻的异常对象(如: NullPointerException、 OutofMemoryError),系统类加载器。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的 GC Roots集合以外,根据用户所选用的垃圾收集器以及当前回收的内存区域不同,还可以有其他对象“临时性”地加入,共同构成完整 GC Roots集合。比如:分代收集和局部回收(Partial GC)。如果只针对Java堆中的某一块区域进行垃圾回收(比如:典型的只针对新生代),必须考虑到内存区域是虚拟机自己的实现细节,更不是孤立封闭的,这个区域的对象完全有可能被其他区域的对象所引用,这时候就需要一并将关联的区域对象也加入 GC Roots集合中去考虑,才能保证可达性分析的准确性。</p><p>如果要使用可达性分析算法来判断内存是否可回收,那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无去保证。这点也是导致GC进行时必须Stop The World的一个重要原因。即使是号称(几乎)不会发生停顿的CMS收集器中,枚举根节点时也是必须要停顿的。</p><h4 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h4><p>MAT是 Memory Analyzer的简称,它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。<br>MAT是基 Eclipse于开发的,是一款免费的性能分析工具。可以在 <a href="http://www.eclipse.org/mat/" target="_blank" rel="noopener">http://www.eclipse.org/mat/</a> 下载并使用MAT。</p><h5 id="1-gt-获取堆dump文件"><a href="#1-gt-获取堆dump文件" class="headerlink" title="1&gt;获取堆dump文件"></a>1&gt;获取堆dump文件</h5><h6 id="方式1：命令行使用jmap"><a href="#方式1：命令行使用jmap" class="headerlink" title="方式1：命令行使用jmap"></a>方式1：命令行使用jmap</h6><p>先用jps查看进程id，然后使用jmap dump出。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120339.png" alt="image-20200917210552170"></p><h6 id="方式2-使用JVisualVM导出"><a href="#方式2-使用JVisualVM导出" class="headerlink" title="方式2:使用JVisualVM导出"></a>方式2:使用JVisualVM导出</h6><p>捕获的 heap dump文件是一个临时文件,关闭 JVisualVM后自动删除,若要保留,需要将其另存为文件。可通过以下方法捕获 heap dump：</p><ul><li>在左侧“Application(应用程序)子窗口中右击相应的应用程序,选择Heap Dump(堆Dump)。</li><li>在Monitor(监视)子标签页中点击 Heap Dump(堆Dump)按钮。</li></ul><p>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时,heap dump在左侧的Application(应用程序)栏中对应一个含有时间戳的节点。右击这个节点选择 save as(另存为)即可将heap dump保存到本地（.hprof文件）。</p><h5 id="2-gt-使用MAT打开dump文件"><a href="#2-gt-使用MAT打开dump文件" class="headerlink" title="2&gt;使用MAT打开dump文件"></a>2&gt;使用MAT打开dump文件</h5><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120343.png" alt="image-20200917212350256"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120357.png" alt="image-20200917212505143"></p><h6 id="Eclipse-GC-Roots统计维度"><a href="#Eclipse-GC-Roots统计维度" class="headerlink" title="Eclipse GC Roots统计维度"></a><a href="https://help.eclipse.org/2020-03/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html" target="_blank" rel="noopener">Eclipse GC Roots统计维度</a></h6><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120408.png" alt="image-20200917211456832"></p><h5 id="3-gt-使用JProfiler监控或者分析dump文件"><a href="#3-gt-使用JProfiler监控或者分析dump文件" class="headerlink" title="3&gt;使用JProfiler监控或者分析dump文件"></a>3&gt;使用<a href="https://www.ej-technologies.com/download/jprofiler/files" target="_blank" rel="noopener">JProfiler</a>监控或者分析dump文件</h5><p>下载JProfiler，并安装IDE插件，以JProfiler插件启动程序，如下即可查看当前程序中<code>GCRootsTest</code>类型对象的GC Root引用链。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120420.png" alt="image-20200917214342359"><br><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120428.png" alt="image-20200917214540189"></p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象,即:垃圾回收此对象之前,总会先调用这个对象的 <code>finalize()</code>方法。<br><code>finalize()</code>方法允许在子类中被重写,用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作,比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用某个对象的 <code>finalize()</code>方法,应该交给垃圾回收机制调用。理由包括下面三点:</p><ul><li>在<code>finalize()</code>时可能会导致对象复活。</li><li><code>finalize()</code>方法的执行时间是没有保障的,它完全由GC线程决定极端情况下,若不发生GC,则 finalize()方法将没有执行机会？？？？？？？？？？？？？？</li><li>一个糟糕的<code>finalize()</code>会严重影响GC的性能。</li></ul><p>从功能上来说, <code>finalize()</code>方法与C++中的析构函数比较相似,但是Java采用的是基于垃圾回收器的自动内存管理机制,所以 <code>finalize()</code>方法在本质上不同于C++中的析构函数。<br>由于<code>finalize()</code>方法的存在,虚拟机中的对象一般处于三种可能的状态。</p><h3 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h3><p>如果从所有的根节点都无法访问到某个对象,说明对象己经不再使用了。一般来说,此对象需要被回收。但事实上,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己,如果这样,那么对它的回收就是不合理的,为此,定义虚拟机中的对象可能的三种状态。如下:</p><ul><li>可触及的:从根节点开始,可以到达这个对象。</li><li>可复活的:对象的所有引用都被释放,但是对象有可能在 <code>finalize()</code>中复活。</li><li>不可触及的:对象的 <code>finalize()</code>被调用,并且没有复活,那么就会进入不可触及状态。不可触及的对象不可能被复活,因为 <code>finalize()</code>只会被调用一次。</li></ul><p>以上3种状态中,是由于 <code>finalize()</code>方法的存在,进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="对象判断回收过程"><a href="#对象判断回收过程" class="headerlink" title="对象判断回收过程"></a>对象判断回收过程</h3><p>判定一个对象objA是否可回收,至少要经历两次标记过程（？？？？下面说的没有重写finalize不就只经过一次标记吗？？另外，标记不是说标记可达对象吗）:</p><ol><li>如果对象objA到 GC Roots没有引用链,则进行第一次标记。</li><li>进行筛选,判断此对象是否有必要执行<code>finalize()</code>方法<ol><li>如果对象objA没有 <code>finalize()</code>重写方法,或者<code>finalize()</code>方法已经被虚拟机调用过,则虚拟机视为“没有必要执行”,objA被判定为不可触及的。</li><li>如果对象objA重写 <code>finalize()</code>了方法,且还未执行过,那么objA会被插入到<code>F-Queue</code>队列中,由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其<code>finalize()</code>方法执行。</li><li><code>finalize()</code>方法是对象逃脱死亡的最后机会,稍后GC会对<code>F-Queue</code>队列中的对象进行第二次标记。如果obj在 <code>finalize()</code>方法中与引用链上的任何一个对象建立了联系,那么在第二次标记时,objA会被移出“即将回收”集合。之后,对象会再次出现没有引用存在的情况。在这个情况下, <code>finalize()</code>方法不会被再次调用,对象会直接变成不可触及的状态,也就是说,一个对象的<code>finalize()</code>方法只会被调用一次。</li></ol></li></ol><h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后,GC接下来的任务就是执行垃圾回收,释放掉无用对象所占用的内存空间,以便有足够的可用内存空间为新对象分配内存。<br>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法(Mark-Sweep)、复制算法( Copying)、标记压缩算法(Mark-Compact)。</p><h3 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h3><p>标记-清除算法(Mark- -Sweep)是一种非常基础和常见的垃圾收集算法,该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><p>执行过程:<br>当堆中的有效内存空间(available memory)被耗尽的时候,就会停止整个程序(也被称为 stop the world),然后进行两项工作,第一项则是标记,第二项则是清除。</p><ul><li>标记: Collector从引用根节点开始遍历,标记所有被引用的对象。一般是在对象的 Header中记录为可达对象。</li><li>清除: Collector对堆内存从头到尾进行线性的遍历,如果发现某个对象在其 Header中<strong>没有标记</strong>为可达对象,则将其回收。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120441.png" alt="image-20200917215522806"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>效率不算高</p></li><li><p>在进行GC的时候,需要停止整个应用程序,导致用户体验差？？？这个应该也是看具体收集器实现吧</p></li><li><p>这种方式清理出来的空闲内存是不连续的,产生内存碎片。需要维护一个空闲列表</p><blockquote><p>注意:何为清除?<br>这里所谓的清除并不是真的置空,而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时,判断垃圾的位置空间是否够,如果够,就存放。</p></blockquote></li></ul><h3 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文,《使用双存储区的Lisp语言垃圾收集器》(CA LISP Garbage Collector Algorithm Using Serial Secondary Storage)。M.L.Minsky在该论文中描述的算法被人们称为复制( Copying)算法,它被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想:"></a>核心思想:</h4><p>将活着的内存空间分为两块,每次只使用其中一块,在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中,之后清除正在使用的内存块中的所有对象,交换两个内存的角色,最后完成垃圾回收。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120450.png" alt="image-20200917220440894"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>没有标记和清除过程,实现简单,运行高效</li><li>复制过去以后保证空间的连续性,不会出现“碎片”问题</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>此算法的缺点也是很明显的,就是需要两倍的内存空间</li><li>对于G1这种分拆 region成为大量的C,复制而不是移动,意味着GC需要维护 region之间对象引用关系,不管是内存占用或者时间开销也不小</li></ul><h4 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h4><ul><li>如果系统中的经历标记后剩余的垃圾对象还是很多，此时就需要复制很多对象，复制算法就不会太理想。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120458.png" alt="image-20200917221336302"></p><h3 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h3><p>又称标记-整理算法。</p><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生,但是在老年代,更常见的情况是大部分对象都是存活对象。如果依然使用复制算法,由于存活对象较多,复制的成本也将很高。因此,基于老年代垃圾回收的特性,需要使用其他的算法。<br>标记-清除算法的确可以应用在老年代中,但是该算法不仅执行效率低下,而且在执行完内存回收后还会产生内存碎片,所以JVM的设计者需要在此基础之上进行改进。标记压缩(Mark- Compact)算法由此诞生。<br>1970年前后, G.L.Steele、C.J.Chene和D.S.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中,人们都使用了标记-压缩算法或其改进版本。</p><h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><ul><li>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象；</li><li>第二阶段将所有的存活对象压缩到内存的一段，按顺序排放；</li><li>之后，清理边界外所有的空间。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120506.png" alt="image-20200917222128968"></p><h4 id="和复制算法区别"><a href="#和复制算法区别" class="headerlink" title="和复制算法区别"></a>和复制算法区别</h4><p>和复制算法的区别就是复制算法预留了一半”待复制”内存空间是不能使用的，在进行对象移动的时候，移动的目标是固定的，可预知的；而标记-整理算法则没有预留空间，它是在标记的过程中动态算出要移动的对象及对象要去的目标位置(而且要考虑性能)，所以相对更复杂。</p><h4 id="和标记-清除算法区别"><a href="#和标记-清除算法区别" class="headerlink" title="和标记-清除算法区别"></a>和标记-清除算法区别</h4><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后,再进行一次内存碎片整理,因此,也可以把它称为标记-清除-压缩(mark-Sweep-<br> Compact)算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法,标记压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><p>可以看到,标记的存活对象将会被整理,按照内存地址依次排列,而未被标记的内存会被清理掉。如此一来,当我们需要给新对象分配内存时,JVM只需要持有一个内存的起始地址即可,这比维护一个空闲列表显然少了许多开销。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h4><ul><li>消除了标记-清除算法当中,内存区域分散的缺点,我们需要给新对象分配内存时,JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中,内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h4><ul><li>从效率上来说,标记-整理算法要低于复制算法。</li><li>移动对象的同时,如果对象被其他对象引用,则还需要调整引用的地址。</li><li>移动过程中,需要全程暂停用户应用程序。即:STW？？？？？？应该是看具体的垃圾收集器吧</li></ul><h3 id="三种算法对比"><a href="#三种算法对比" class="headerlink" title="三种算法对比"></a>三种算法对比</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120513.png" alt="image-20200917222914385"></p><p>效率上来说,复制算法是当之无愧的老大但是却浪费了太多内存?????????凭什么标记清除比复制慢，你还多一个复制的过程呢？</p><p>而为了尽量兼顾上面提到的三个指标,标记整理算法相对来说更平滑一些,但是效率上不尽如人意,它比复制算法多了一个标记的阶段,比标记-清除多了一个整理内存的阶段。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中,并没有一种算法可以完全替代其他算法,它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法,是基于这样一个事实不同的对象的生命周期是不一样的。因此,不同生命周期的对象可以采取不同的收集方式,以便提高回收效率。一般是把Java堆分为新生代和老年代,这样就可以根据各个年代的特点使用不同的回收算法,以提高垃圾回收的效率。</p><p>在Java程序运行的过程中,会产生大量的对象,其中有些对象是与业务信息相关,比如Http请求中的 , httpsession对象、线程、soocket连接,这类对象跟业务直接挂钩,因此生命周期比较长。但是还有一些对象,主要是程序运行过程中生成的临时变量,这些对象生命周期会比较短,比如: String对象,由于其不变类的特性,系统会产生大量的这些对象,有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都是采用分代收集(Generational Collecting)算法执行垃圾回收的。在 HotSpot中,基于分代的概念,GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li><p>年轻代(Young Gen)</p><p>年轻代特点:区域相对老年代较小,对象生命周期短、存活率低,回收频繁。</p><p>这种情况复制算法的回收整理,速度是最快的。复制算法的效率只和当前存活对象大小有关,因此很适用于年轻代的回收。而复制算法内存利用率不高的问题,通过hotspot survivor中的两个的设计得到缓解</p></li><li><p>老年代(Tenured Gen)</p><p>老年代特点:区域较大,对象生命周期长、存活率高,回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象,复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul><p>以 HotSpot中的CMS回收器为例,CMS是基于Mark-Sweep实现的对于对象的回收效率很高。而对于碎片问题,CMS采用基于Mark-Compact算法的 Serial Old回收器作为补偿措施:当内存回收不佳(碎片导致的 Concurrent Mode Failure时),将采用 Serial Old执行Full GC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>上述现有的算法,在垃圾回收过程中,应用软件将处于一种 Stop The World的状态????????????????????在 Stop The World状态下应用程序所有的线程都会挂起,暂停一切正常的工作,等待垃圾回收的完成。如果垃圾回收时间过长,应用程序会被挂起很久,将严重影响用户体验或者系统的稳定性。为了解决这个问题,即对实时垃圾收集算法的研究直接导致了增量收集(Incremental Collecting)算法的诞生。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>如果一次性将所有的垃圾进行处理,需要造成系统长时间的停顿,那么就可以让垃圾收集线程和应用程序线程交替执行。每次,垃圾收集线程只收集一小片区域的内存空间,接着切换到应用程序线程。依次反复,直到垃圾收集完成。</p><p>总的来说,增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理,允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><p>使用这种方式,由于在垃圾回收过程中,间断性地还执行了应用程序代码, 所以能减少系统的停顿时间(低时延)。但是,因为线程切换和上下文转换的消耗,会使得垃圾回收的总体成本上升,造成系统吞吐量的下降。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>一般来说,在相同条件下,堆空间越大一次GC时所需要的时间就越长,有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间,将一块大的内存区域分割成多个小块,根据目标的停顿时间,每次合理地回收若干个小区间,而不是整个堆空间,从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分,分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用,独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120523.png" alt="image-20200918080526405"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/10-stringtable/"/>
      <url>/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/10-stringtable/</url>
      
        <content type="html"><![CDATA[<h1 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h1><ul><li><p>String:字符串,使用一对<code>&quot;&quot;</code>引起来表示。<br>String sl1=”atguigu”;//字面量的定义方式<br>String s2= new String(“hello”);</p></li><li><p>String 被final声明,不可被继承</p></li><li><p>String实现了 Serializable接口:表示字符串是支持序列化的</p></li><li><p>实现了 Comparable接口:表示 String可以比较大小</p></li><li><p>String final在jdk8及以前内部定义了<code>char[] value</code>用于存储字符串数据。jdk9时改为<code>byte[]</code></p><p>变更原因：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115747.png" alt="image-20200917150221054"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115800.png" alt="image-20200917150355524"></p></li><li><p>String:代表不可变的字符序列。简称:不可变性。</p></li></ul><h2 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h2><ul><li><p>通过字面量的方式(区别于new)给一个字符串赋值,此时的字符串值声明在字符串常量池中，之后再使用<code>intern()</code>方法或者字面量赋值相同的字符串，会直接返回当前字符串分配到的地址引用。</p></li><li><p>当对已经赋值字符串引用的字符串变量重新赋值时,会新开辟一块空间存储新的字符串,然后将新的引用赋值到该字符串变量</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true。定义s1的时候"abc"字面量进入了常量池，定义s2的时候检查到常量池已存在该常量，直接获取其引用</span>s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false，"hello"字面量会在常量池另外开辟内存进行存储并重新赋值新引用到使s2，不会覆盖"abc"的空间</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//abc，没有被覆盖</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hello，新内存地址引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当对现有的字符串进行连接操作时,也需要重新分配内存进行存储连接后的新值,不能对变量已指向的常量池内存空间进行覆盖。</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>s1 <span class="token operator">+=</span> <span class="token string">"def"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false，还是会在常量池新开辟一块内存空间存储拼接后的"abcdef"</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//abc，没有被覆盖</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//abcdef，新内存地址引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>当调用String的<code>replace()</code>方法修改指定字符或字符串时,也需要重新分配内存进行存储连接后的新值,不能对变量已指向的常量池内存空间进行覆盖。</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false，还是会在常量池新开辟一块内存空间存储替换后得到的"mbc"</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//abc，没有被覆盖</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//mbc，新内存地址引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><p>字符串常量池中是不会存储相同内容的字符串的。</p><ul><li>String的 String Pool是一个固定大小的HashTable,默认值大小长度是1009。如果放进 String Pool的string非常多,就可能造成较多的Hash冲突,从而导致链表会很长,而链表长了后直接会造成的影响就是当调用<code>String.intern()</code>时性能会大幅下降。</li><li>使用<code>-XX: StringTableSize</code>可设置StringTable的长度</li><li>在jdk6中StringTable是固定的,就是1009的长度,所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求</li><li>在jdk7中, StringTable的长度默认值是60013,1009是可设置的最小值。</li></ul><p>使用<code>-XX:+PrintStringTableStatistics</code>可以在退出的时候打印StringTable的信息</p><h1 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h1><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存,都提供了一种常量池的概念。常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的, String类型的常量池比较特殊。它的主要使用方法有两种。</p><ul><li>直接使用双引号声明出来的 String对象会直接存储在常量池中。<ul><li>比如: String info=”atguigu.com”;</li></ul></li><li>如果不是用双引号声明的String对象可以使用 String提供的 <code>intern()</code>方法。</li></ul><h3 id="字符串常量池位置变化"><a href="#字符串常量池位置变化" class="headerlink" title="字符串常量池位置变化"></a>字符串常量池位置变化</h3><ol><li>Java6及以前字符串常量池存放在永久代。</li><li>Java7中 oracle的工程师对字符串池的逻辑做了很大的改变,即将字符串常量池的位置调整到Java堆内。<ul><li>所有的字符串都保存在堆(Heap)中,和其他普通对象一样,这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多,但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用 <code>String.intern()</code>。</li></ul></li><li>Java8元空间,字符串常量在堆。</li></ol><h4 id="为什么要变化？"><a href="#为什么要变化？" class="headerlink" title="为什么要变化？"></a>为什么要变化？</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115815.png" alt="image-20200917154123382"></p><h1 id="String例子说明"><a href="#String例子说明" class="headerlink" title="String例子说明"></a>String例子说明</h1><ol><li><p>运行下面代码，通过IDEA下方的memory窗口可以查看当前JVM内存对象情况，其中String对象在运行到第一个”10”之后String对象变为2331个，在之后就一直不变了。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115824.png" alt="image-20200917154527425"></p></li><li><p>以下方法运行过程的引用分析</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115832.png" alt="image-20200917155005412"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115840.png" alt="image-20200917155021370"></p><p>A string is created in line7. it goes in the String pool in the heap space and a reference is created in the foo() stack space for it.</p></li></ol><h1 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h1><p>前面提到被作用右值引用的字符串字面量都会进入到字符串常量值中，下面介绍当出现字符串拼接（使用”+”或者通过StringBuilder等工具类进行拼接得到的结果）的时候拼接得到的结果会不会出现在常量池中：</p><ol><li><p>字符串拼接结果直接进入常量池的情况：</p><ul><li><p>常量与常量的拼接结果在常量池, 原理是编译期优化（即编译期会完成字符串常量池初始化，将所有在编译期识别的字符串值在字符串常量池进行创建），这里的常量就是指<strong>字符串字面量（右值）以及使用final修饰的字符串变量（左值）</strong>。</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span> <span class="token operator">+</span> <span class="token string">"c"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前端编译直接合成"abc"</span>String s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>常量池中不会存在相同内容的常量。</p></li></ul></li><li><p>字符串拼接结果不进入常量池的情况：</p><ul><li><p>只要参与拼接的字符串中有一个是变量（即非上面描述的常量范围，这样的符号/symbol在编译期无法确定其值）,  字符串拼接将在运行时进行，此时拼接结果将会产生一个<code>String</code>对象放在堆中（不进入常量池）。变量拼接的原理是 StringBuilder</p><pre class="line-numbers language-java"><code class="language-java"> string s1 <span class="token operator">=</span><span class="token string">"javaEE"</span><span class="token punctuation">;</span> string s2 <span class="token operator">=</span><span class="token string">"hadoop"</span><span class="token punctuation">;</span> string s3 <span class="token operator">=</span><span class="token string">"javaEEhadoop"</span><span class="token punctuation">;</span> string s4 <span class="token operator">=</span><span class="token string">"javaEE"</span><span class="token operator">+</span> <span class="token string">"hadoop"</span><span class="token punctuation">;</span> string s5<span class="token operator">=</span>s1<span class="token operator">+</span><span class="token string">"hadoop"</span><span class="token punctuation">;</span> string s6<span class="token operator">=</span><span class="token string">"javaEE"</span><span class="token operator">+</span>s2<span class="token punctuation">;</span> string s7<span class="token operator">=</span>s1<span class="token operator">+</span>s2<span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span>s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s3 <span class="token operator">=</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s3 <span class="token operator">=</span>s7<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span>s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span>s7<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>s6<span class="token operator">==</span>s7<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span> string s8<span class="token operator">=</span>s6<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span>s8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果拼接的结果调用<code>intern()</code>方法,则主动将常量池中还没有的字符串对象放入池中,并返回此对象地址；如果已经存在，则返回已存在字符串地址。</p></li></ul></li></ol><h2 id="字符串拼接”-”解析"><a href="#字符串拼接”-”解析" class="headerlink" title="字符串拼接”+”解析"></a>字符串拼接”+”解析</h2><p>可以看到下面的字节码解析中字符串的拼接通过<code>StringBuilder</code>来实现的，在没有<code>StringBuilder</code>(5.0)之前都是使用<code>StringBuffer</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115847.png" alt="image-20200917161645127"></p><p><code>StringBuilder#toString()</code>方法的底层如下：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Create a copy, don't share the array</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到是直接<code>new</code>了一个String对象，注意这种方式与<code>new String(&quot;我是字符串&quot;)</code>是有区别的，前者对字符串常量池没有任何影响；后者会将”我是字符串”字面量放入常量池，然后返回分配到的内存地址赋值到变量(左值)中。即前者会在堆产生一个<code>String</code>对象，后者会在字符串常量池建立一个字符串常量。</p><h2 id="使用”-”和StringBuilder-append-拼接的效率"><a href="#使用”-”和StringBuilder-append-拼接的效率" class="headerlink" title="使用”+”和StringBuilder#append()拼接的效率"></a>使用”+”和<code>StringBuilder#append()</code>拼接的效率</h2><p>由上面可以得知每一个”+”都会编译为创建一个<code>StringBuilder</code>和<code>toString</code>new一个<code>String</code>对象，所以如果在一个循环次数很高的代码中使用”+”就会涉及常见对象的消耗以及内存占用(以及带来GC)的消耗。所以相较于我们手动使用<code>StringBuilder#append</code>来说，效率会差别非常大。</p><p>另外如果我们使用<code>StringBuilder</code>的时候，如果可以提前可以预知字符串长度则可以调用有参构造传入<code>capacity</code>创建指定长度的<code>Builder</code>，防止多次扩容。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final可以修饰一个左值为一个常量：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> <span class="token string">"javaEEhadoop"</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> <span class="token string">"javaEE"</span><span class="token punctuation">;</span>        String s3 <span class="token operator">=</span> s2 <span class="token operator">+</span> <span class="token string">"hoodp"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>        <span class="token keyword">final</span> String s4 <span class="token operator">=</span> <span class="token string">"javaEE"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//s4常量</span>        String s5 <span class="token operator">=</span> s4 <span class="token operator">+</span> <span class="token string">"hadoop"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h1><p><code>intern()</code>方法主动将常量池中还没有的字符串对象放入池中,并返回此对象地址；如果已经存在，则返回已存在字符串地址。。</p><p>如果不是用双引号声明的 string对象,可以使用 string提供的intern方法: intern方法会从字符串常量池中查询当前字符串是否存在,若不存在就会将当前字符串放入常量池中。</p><ul><li>比如: <code>String myInfo= new String(aStringVariable).intern()</code>;</li></ul><p>当且仅当两个字符串变量<code>equals</code>的时候它们调用<code>intern()</code>方法得到的结果是<code>=</code>的。因此,下列表达式的值必定是true:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token operator">+</span><span class="token string">"b"</span><span class="token operator">+</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"abc"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通俗点讲, Interned String就是确保字符串在内存里只有一份拷贝,这样可以节约内存空间,加快字符串操作任务的执行速度。注意,这个值会被存放在字符串内部池(String Intern Pool)。</p><h2 id="JDK6和JDK7变化例子"><a href="#JDK6和JDK7变化例子" class="headerlink" title="JDK6和JDK7变化例子"></a>JDK6和JDK7变化例子</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>求以下输出：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115857.png" alt="image-20200917164159401"></p><h4 id="intern-方法变化说明"><a href="#intern-方法变化说明" class="headerlink" title="intern()方法变化说明"></a><code>intern()</code>方法变化说明</h4><ul><li><p>JDK6及之前，<code>intern()</code>方法会在常量池中寻找该字符串常量是否存在，如果存在，则方法返回常量池中该地址；如果不存在，则在常量池中为该常量开辟空间存储后返回该新地址。</p><ul><li>第一个输出：false<ol><li>第一行”1”是一个字面量，编译期初始化进入字符串常量池，然后<code>new String(&quot;1&quot;)</code>会在堆中创建一个String对象，本地变量<code>s</code>存储的是该String对象的引用，而该String对象中保存了”1”字符串常量的引用</li><li><code>s.intern()</code>相当于没做任何事情，因为没有将返回结果进行赋值</li><li><code>String s2 = &quot;1&quot;</code>将”1”在字符串常量池地址返回该s2.</li><li>很自然s != s2.</li></ol></li><li>第二个输出：false<ol><li><code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;)</code>会在堆中创建两个String对象，分别保存了”1”的引用</li><li>此时<code>intern()</code>方法就有作用了，它会将<code>s3</code>指向的新拼接好的第三个保存在堆中的String对象中保存的字符串保存到字符串常量池。因为代码中没有任何地方定义了字面量”11”或者由常量拼接成的”11”，所以在调用<code>intern()</code>方法之前，它都是以String对象的一个字节成员字段保存在堆中的。但是即使是这样，依然没有将返回值覆盖到<code>s3</code></li><li>此时<code>String s4 = &quot;11&quot;</code>就会从常量池加载得到”11”，返回该引用到<code>s4</code></li><li>所以很自然，<code>s3</code>是一个堆中地址，<code>s4</code>是常量池地址，s3 != s4</li></ol></li></ul></li><li><p>JDK7及之后，<code>intern()</code>方法的语义发生了变化，它会在常量池中寻找该字符串常量是否存在，如果存在，则方法返回常量池中该地址；如果不存在，将不会在常量池中开辟新空间，而是直接将当前字符串地址插入到常量池表中。</p><p>即JDK6其实发生了字符串复制，而JDK7没有，因为在JDK7及之后，字符串常量池被移到了堆中(老年代)，在JDK6之前是在永久代的，所以在JDK7可以这样做。所以以下输出也产生了变化</p><ul><li>第一个输出：false<ol><li>这里其实没有变化，”1”已经存在常量池</li><li>结果一样</li></ol></li><li>第二个输出：true<ol><li>这里的变化就大了，在<code>s3.intern()</code>会将s3的引用直接更新到常量池表中</li><li>此时<code>String s4 = &quot;11&quot;;</code>将会得到<code>s3</code>的引用，故s3==s4</li></ol></li></ul></li></ul><blockquote><p>另外学到的是，我们可以从字节码角度对一些代码进行分析，以下是JDK8的字节码分析：<img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115908.png" alt="image-20200917165013913"><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115917.png" alt="image-20200917165217870"></p></blockquote><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><pre class="line-numbers language-java"><code class="language-java"># JDK7及之后String s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> <span class="token string">"11"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//常量"11"已经存在，所以"11" == s4 != s3</span>String s5 <span class="token operator">=</span> s3<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"11" == s5 </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span># JDK6及之前String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//发生了字符串复制，s2 == "ab" != s</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span># 无论是任何版本String ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"ab"编译期存在常量池，先从常量池加载该常量引用并利用它在池外创建一个String对象</span>ss<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String ss2 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ss <span class="token operator">==</span> ss2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="intern-的用处"><a href="#intern-的用处" class="headerlink" title="intern()的用处"></a>intern()的用处</h2><p>如果在需要动态生成大量字符串（非字面量）的情况下，推荐使用<code>intern()</code>方法可以大大降低堆的空间使用（复用常量池内存）。</p><h1 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h1><p>和堆无区别，本身就在堆中，由垃圾收集器决定如何回收。</p><h1 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h1><p>背景:对许多Java应用(有大的也有小的)做的测试得出以下结果:</p><ul><li>堆存活数据集合里面string对象占了25%</li><li>堆存活数据集合里面重复的string对象有13.5%</li><li>String对象的平均长度是45</li></ul><p>许多大规模的Java应用的瓶颈在于内存,测试表明,在这些类型的应用里面,Java堆中存活的数据集合差不多25%是String对象。更进一步,<br>这里面差不多一半 String对象是重复的,重复的意思是说:<br><code>stringl.equals(string2)=true</code><br>堆上存在重复的 String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的 String对象进行去重,这样就能避免浪费内存。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li>当垃圾收集器工作的时候,会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 String对象。</li><li>如果是,把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行,处理这个队列。处理队列的一个元素意味着从队列删除这个元素,然后尝试去重它引用的String对象。</li><li>使用一个hashtable来记录所有的被string对象使用的不重复的char数组。当去重的时候,会查这个hashtable,来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在, String对象会被调整引用那个数组,释放对原来的数组的引用,最终会被垃圾收集器回收掉。</li><li>如果查找失败,char数组会被 hasht插入到,这样以后的时候就可以共享这个数组了。</li></ol><h2 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h2><pre class="line-numbers language-shell"><code class="language-shell"># 开启G1 string去重,默认是不开启的,需要手动开启。-XX:+/-UseStringDeduplication# 打印详细的去重统计信息-XX:+/-PrintStringDeduplicationStatistics# 达到这个年龄的 string对象被认为是去重的候选对象-XX:StringDeduplicationAgeThreshold=<N><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/08-zhi-xing-yin-qing/"/>
      <url>/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/08-zhi-xing-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="一、编译原理"><a href="#一、编译原理" class="headerlink" title="一、编译原理"></a>一、编译原理</h1><p>如今,基于物理机、Java虚拟机,或者是非Java的其他高级语言虚拟机(HLLVM)的代码执行过程,大体上都会遵循这种符合现代经典编译原理的思路,在执行前先对程序源码进行词法分析和语法分析处理,把源码转化为抽象语法树(Abstract Syntax Tree,AST)。对于一门具体语言的实现来说, 词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎,形成一个完整意义的编译器去实现,这类代表是C/C++语言。也可以选择把其中一部分步骤(如生成抽象语法树之前的步骤)实现为一个半独立的编译器,这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中,如大多数的JavaScript执行引擎。</p><p>在Java语言中,Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树,再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的,而解释器在虚拟机的内部,所以Java程序的编译就是半独立的实现。</p><h1 id="二、执行引擎概述"><a href="#二、执行引擎概述" class="headerlink" title="二、执行引擎概述"></a>二、执行引擎概述</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115138.png" alt="image-20200917101306991"></p><p>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表、以及其他辅助信息。</p><p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><h2 id="执行引擎工作"><a href="#执行引擎工作" class="headerlink" title="执行引擎工作"></a>执行引擎工作</h2><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><h1 id="三、Java代码编译和执行过程"><a href="#三、Java代码编译和执行过程" class="headerlink" title="三、Java代码编译和执行过程"></a>三、Java代码编译和执行过程</h1><p>Java是半编译半解释型语言。JDK1.0时代，将Java语言定位为”解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115152.png" alt="image-20200917102446107"></p><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过以上步骤。</p><h2 id="前端编译"><a href="#前端编译" class="headerlink" title="前端编译"></a>前端编译</h2><p>Java代码编译由Java源码编译器(javac)来完成：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115203.png" alt="image-20200917102634953"></p><h2 id="后端编译"><a href="#后端编译" class="headerlink" title="后端编译"></a>后端编译</h2><p>Java字节码的执行是由JVM执行引擎来完成：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115212.png" alt="image-20200917102821293"></p><h1 id="四、机器码、指令、汇编语言"><a href="#四、机器码、指令、汇编语言" class="headerlink" title="四、机器码、指令、汇编语言"></a>四、机器码、指令、汇编语言</h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它编写程序，这就是机器语言。机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出错。用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编写的程序相比，执行速度最快。机器指令和CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>表达不同的操作行为和操作数的一条原子机器码即为一条指令，另外不同硬件平台都定义了一些指令助记标准，方便描述和阅读。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>不同的硬件平台，各自支持的指令是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的：</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>在汇编语言中，使用汇编助记符来替代机器指令的操作码，用地址符号(symbol)或标号(Label)代替指令或操作数的地址。相较于机器指令，汇编指令中的操作码都是字面量，操作数都是符号引用；而机器指令都是二进制位。</p><p>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><ul><li>由于计算机只认识指令码，所以用汇编语言写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115221.png" alt="image-20200917105832983"></p><h3 id="C-C-源程序执行过程"><a href="#C-C-源程序执行过程" class="headerlink" title="C/C++源程序执行过程"></a>C/C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编</p><ul><li>编译过程：读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换成功能等效的汇编代码。</li><li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115229.png" alt="image-20200917110116047"></p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能称为机器码。字节码主要为了实现特定软件运行和软件环境有关、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码的典型应用为Java bytecode</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115237.png" alt="image-20200917110450770"></p><h1 id="五、解释器"><a href="#五、解释器" class="headerlink" title="五、解释器"></a>五、解释器</h1><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容”翻译”为对应平台的本地机器指令执行。当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><p>在Java的发展历史中，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能。</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令。</li></ul></li></ul></li></ul><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫做即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译称为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h1 id="六、编译器"><a href="#六、编译器" class="headerlink" title="六、编译器"></a>六、编译器</h1><h2 id="6-1、Java中的编译"><a href="#6-1、Java中的编译" class="headerlink" title="6.1、Java中的编译"></a>6.1、Java中的编译</h2><p>Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指：</p><ul><li>一个前端编译器(其实叫“编译器的前端”更准确一些)把java文件转变成 class文件的过程</li><li>也可能是指虚拟机的后端运行期编译器(编译器， Just In Time Compiler)把字节码转变成机器码的过程</li><li>还可能是指使用静态提前编译器(AOT编译器, Ahead of Time Compiler)直接把.java文件编译成本地机器代码的过程</li></ul><blockquote><p>前端编译器：JDK的 Javac、 <a href="ttp://www.eclipse.org/jdt/" target="_blank" rel="noopener">Eclipse JDT</a>中的增量式编译器(ECJ)<br>JIT编译器:：HotSpot VM的C1、C2编译器、Graal编译器。<br>AOT编译器：GNU Compiler for the Java(<a href="http://gcc.gnu.org/java/" target="_blank" rel="noopener">GCJ</a>)、 <a href="https://en.wikipedia.org/wiki/Excelsior_JET" target="_blank" rel="noopener">Excelsior JET</a></p></blockquote><h3 id="Java中的JIT编译器"><a href="#Java中的JIT编译器" class="headerlink" title="Java中的JIT编译器"></a>Java中的JIT编译器</h3><p>HotSpot中内嵌有两个(或者三个)JIT编译器,分别为 Client Compiler 和 Server compiler ,但大多数情况下我们简称为C1编译器和C2编译器。第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。Graal编译器目前还处于实验状态。</p><p>开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器,如下所示:</p><ul><li><code>-client</code>：指定Java虚拟机 client运行在模式下,并使用C1编译器;</li><li>Client VM初始化堆空间会小一些，使用串行垃圾回收器。<ul><li>C1编译器会对字节码进行简单和可靠的优化,耗时短。以达到更快的编译速度。</li></ul></li><li><code>-server</code>：指定Java虚拟机 Server运行在模式下，并使用C2编译器。</li><li>Server VM的初始化堆空间会大一些，默认使用的是并行垃圾回收器。<ul><li>C2进行耗时较长的优化,以及激进优化。但优化的代码执行效率更高。</li></ul></li></ul><blockquote><p>如果不指定参数，JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM。</p><ol><li>32位操作系统<ul><li>如果是Windows系统,不论硬件配置如何,都默认使用Client类型的JVM。 </li><li>如果是其他操作系统上,机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server 模式,否则使用client模式</li></ul></li><li><strong>64位操作系统 只有Server类型,不支持Client类型。</strong></li></ol></blockquote><p>一般来讲，JIT编译出来的机器码性能比解释器高。C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</p><h2 id="6-2、前端编译"><a href="#6-2、前端编译" class="headerlink" title="6.2、前端编译"></a>6.2、前端编译</h2><p>Java中即时编译器在运行期的优化过程,支撑了程序执行效率的不断提升;而前端编译器在编译期的优化过程（新生的Java语法特性,都是靠前端编译器的“语法糖”）,则是支撑着程序员的编码效率和语言使用者的幸福感的提高。</p><p>Javac编译器不像HotSpot虚拟机那样使用C++语言(包含少量C语言)实现,它本身就是一个由Java语言编写的程序。</p><p>从Javac代码的总体结构来看,编译过程大致可以分为1个准备过程和3个处理过程,它们分别如下所示。</p><p>《Java虚拟机规范》中严格定义了Class文件格式的各种细节,可是对如何把Java源码编译为Class 文件却描述得相当宽松。规范里尽管有专门的一章名为“Compiling for the Java Virtual Machine”,但这章也仅仅是以举例的形式来介绍怎样的Java代码应该被转换为怎样的字节码,并没有使用编译原理中常用的描述工具(如文法、生成式等)来对Java源码编译过程加以约束。这是给了Java前端编译器较大的实现灵活性,但也导致Class文件编译过程在某种程度上是与具体的JDK或编译器实现相关的,譬如在一些极端情况下,可能会出现某些代码在Javac编译器可以编译,但是ECJ编译器就不可以编译的问题(反过来也有可能,后文中将会给出一些这样的例子)</p><p>从Javac代码的总体结构来看,编译过程大致可以分为1个准备过程和3个处理过程,它们分别如下所示。</p><ol><li>准备过程:初始化插入式注解处理器。</li><li>解析与填充符号表过程,包括: <ul><li>词法、语法分析。将源代码的字符流转变为标记集合,构造出抽象语法树。</li><li>填充符号表。产生符号地址和符号信息。</li></ul></li><li>插入式注解处理器的注解处理过程:插入式注解处理器的执行阶段</li><li>分析与字节码生成过程,包括: <ol><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态运行过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化成字节码。</li></ol></li></ol><p>上述前3个处理过程里,执行插入式注解时又可能会产生新的符号,如果有新的符号产生,就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号,从总体来看,三者之间的关系与交互顺序如图</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115247.png" alt="image-20200922165158822"></p><p>上述处理过程对应到代码中,Javac编译动作的入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类,上述3个过程的代码逻辑集中在这个类的<code>compile()</code>和<code>compile2()</code>方法里，其中主体代码如下图。下面步骤围绕这个图中方法展开描述</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115253.png" alt="image-20200922165505278"></p><h3 id="6-2-1、解析与填充符号表"><a href="#6-2-1、解析与填充符号表" class="headerlink" title="6.2.1、解析与填充符号表"></a>6.2.1、解析与填充符号表</h3><p>解析过程由parseFiles()方法来完成,解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p><h4 id="1-gt-词法、语法分析"><a href="#1-gt-词法、语法分析" class="headerlink" title="1&gt;词法、语法分析"></a>1&gt;词法、语法分析</h4><p>法分析是将源代码的字符流转变为标记(Token)集合的过程,单个字符是程序编写时的最小元素,但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记,如“int a=b+2”这句代码中就包含了6个标记,分别是int、a、=、b、+、2,虽然关键字int由3个字符构成,但是它只是一个独立的标记,不可以再拆分。在Javac的源码中,词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。<br>语法分析是根据标记序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,抽象语法树的每一个节点都代表着程序代码中的一个语法结构(Syntax Construct),例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p><p>下面是Eclipse AST View插件分析出来的某段代码的抽象语法树视图,</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115301.png" alt="image-20200922170218225"></p><p>在Javac的源码中,语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现,这个阶段产出的抽象语法树是以<code>com.sun.tools.javac.tree.JCTree</code> 类表示的。</p><p>经过词法和语法分析生成语法树以后,编译器就不会再对源码字符流进行操作了,后续的操作都建立在抽象语法树之上。</p><h4 id="2-gt-填充符号表"><a href="#2-gt-填充符号表" class="headerlink" title="2&gt;填充符号表"></a>2&gt;填充符号表</h4><p>完成了语法分析和词法分析之后,下一个阶段是对符号表进行填充的过程,也就是<code>enterTrees()</code>方法要做的事情。符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构,读者可以把它类比想象成哈希表中键值对的存储形式(实际上符号表不一定是哈希表实现,可以是有序符号表、树状符号表、栈结构符号表等各种形式)。符号表中所登记的信息在编译的不同阶段都要被用到。譬如在语义分析的过程中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的声明是否一致)和产生中间代码,在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的直接依据。</p><p>在Javac源代码中,填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现,该过程的产出物是一个待处理列表,其中包含了每一个编译单元的抽象语法树的顶级节点,以及<code>package-info.java</code>(如果存在的话)的顶级节点。</p><h3 id="6-2-2、注解处理器"><a href="#6-2-2、注解处理器" class="headerlink" title="6.2.2、注解处理器"></a>6.2.2、注解处理器</h3><p>JDK 5之后,Java语言提供了对注解(Annotations)的支持,注解在设计上原本是与普通的Java代码一样,都只会在程序运行期间发挥作用的。但在JDK 6中又提出并通过了JSR-269提案,该提案设计了一组被称为“插入式注解处理器”的标准API,可以提前至编译期对代码中的特定注解进行处理, 从而影响到前端编译器的工作过程。我们可以把插入式注解处理器看作是一组编译器的插件,当这些插件工作时,允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改,编译器将回到解析及填充符号表的过程重新处理,直到所有插入式注解处理器都没有再对语法树进行修改为止,每一次循环过程称为一个轮次(Round)。</p><p>有了编译器注解处理的标准API后,程序员的代码才有可能干涉编译器的行为,由于语法树中的任意元素,甚至包括代码注释都可以在插件中被访问到,所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意,程序员能使用插入式注解处理器来实现许多原本只能在编码中由人工完成的事情。譬如Java著名的编码效率工具Lombok,它可以通过注解来实现自动产生getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法,等等。</p><p>Javac源码中,插入式注解处理器的初始化过程是在<code>initPorcessAnnotations()</code>方法中完成的,而它的执行过程则是在<code>processAnnotations()</code>方法中完成。这个方法会判断是否还有新的注解处理器需要执行,如果有的话,通过<code>com.sun.tools.javac.processing.JavacProcessing-Environment</code>类的<code>doProcessing()</code>方法来生成一个新的<code>JavaCompiler</code>对象,对编译的后续步骤进行处理。</p><h3 id="6-2-3、语义分析与字节码生成"><a href="#6-2-3、语义分析与字节码生成" class="headerlink" title="6.2.3、语义分析与字节码生成"></a>6.2.3、语义分析与字节码生成</h3><p>经过语法分析之后,编译器获得了程序代码的抽象语法树表示,抽象语法树能够表示一个结构正确的源程序,但无法保证源程序的语义是符合逻辑的。而语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查,譬如进行类型检查、控制流检查、数据流检查,等等。</p><h4 id="1-gt-标注检查"><a href="#1-gt-标注检查" class="headerlink" title="1&gt;标注检查"></a>1&gt;标注检查</h4><p>Javac在编译过程中,语义分析过程可分为标注检查和数据及控制流分析两个步骤,分别由<code>attribute()</code>和<code>flow()</code>方法完成。</p><p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配,等等。在标注检查中,还会顺便进行一个称为常量折叠(Constant Folding)的代码优化,这是Javac编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。如果我们在Java代码中写下如下所示的变量定义</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则在抽象语法树上仍然能看到字面量“1”“2”和操作符“+”号,但是在经过常量折叠优化之后,它们将会被折叠为字面量“3”,这插入式表达式(InfixExpression)的值已经在语法树上标注出来了(ConstantExpressionValue:3)。由于编译期间进行了常量折叠,所以在代码里面定义“a=1+2”比起直接定义“a=3”来,并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量。<br>标注检查步骤在Javac源码中的实现类是<code>com.sun.tools.javac.comp.Attr</code>类和<code>com.sun.tools.javac.comp.Check</code>类。</p><h4 id="2-gt-数据及控制流分析"><a href="#2-gt-数据及控制流分析" class="headerlink" title="2&gt;数据及控制流分析"></a>2&gt;数据及控制流分析</h4><p>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的, 但校验范围会有所区别,有一些校验项只有在编译期或运行期才能进行。下面举一个关于final修饰符的数据及控制流分析的例子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方法一带有final修饰</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// do something </span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 方法二没有final修饰</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> var <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// do something </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这两个<code>foo()</code>方法中,一个方法的参数和局部变量定义使用了final修饰符,另外一个则没有,在代码编写时程序肯定会受到final修饰符的影响,不能再改变arg和var变量的值,但是如果观察这两段代码编译出来的字节码,会发现它们是没有任何一点区别的,每条指令,甚至每个字节都一模一样。局部变量与类的字段(实例变量、类变量)的存储是有显著差别的,局部变量在常量池中并没有CONSTANT_Fieldref_info的符号引用,自然就不可能存储有访问标志(access_flags)的信息,甚至可能连变量名称都不一定会被保留下来(这取决于编译时的编译器的参数选项),自然在Class文件中就不可能知道一个局部变量是不是被声明为final了。因此, 可以肯定地推断出把局部变量声明为final,对运行期是完全没有影响的,变量的不变性仅仅由Javac编译器在编译期间来保障,这就是一个只能在编译期而不能在运行期中检查的例子。在Javac的源码中, 数据及控制流分析的入口<code>flow()</code>方法,具体操作由<code>com.sun.tools.javac.comp.Flow</code>类来完成。</p><h4 id="3-gt-解语法糖"><a href="#3-gt-解语法糖" class="headerlink" title="3&gt;解语法糖"></a>3&gt;解语法糖</h4><p>语法糖(Syntactic Sugar),也称糖衣语法,是由英国计算机科学家Peter J.Landin发明的一种编程术语,指的是在计算机语言中添加的某种语法,这种语法对语言的编译结果和功能并没有实际影响, 但是却能更方便程序员使用该语言。通常来说使用语法糖能够减少代码量、增加程序的可读性,从而减少程序代码出错的机会。</p><p>Java在现代编程语言之中已经属于“低糖语言”(相对于C#及许多其他Java虚拟机语言来说),尤其是JDK 5之前的Java。“低糖”的语法让Java程序实现相同功能的代码量往往高于其他语言,通俗地说就是会显得比较“啰嗦”,这也是Java语言一直被质疑是否已经“落后”了的一个浮于表面的理由。</p><p>Java中最常见的语法糖包括了前面提到过的泛型(其他语言中泛型并不一定都是语法糖实现,如C#的泛型就是直接由CLR支持的)、变长参数、自动装箱拆箱,等等,Java虚拟机运行时并不直接支持这些语法,它们在编译阶段被还原回原始的基础语法结构,这个过程就称为解语法糖。在Javac的源码中,解语法糖的过程由<code>desugar()</code>方法触发,在<code>com.sun.tools.javac.comp.TransTypes</code>类和<code>com.sun.tools.javac.comp.Lower</code>类中完成。</p><h4 id="4-gt-字节码生成"><a href="#4-gt-字节码生成" class="headerlink" title="4&gt;字节码生成"></a>4&gt;字节码生成</h4><p>字节码生成是Javac编译过程的最后一个阶段,在Javac源码里面由<code>com.sun.tools.javac.jvm.Gen</code>类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码指令写到磁盘中,编译器还进行了少量的代码添加和转换工作。</p><p>例如前文多次登场的实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加到语法树之中的。请注意这里的实例构造器并不等同于默认构造函数,如果用户代码中没有提供任何构造函数,那编译器将会添加一个没有参数的、可访问性(public、protected、private或<code>&lt;package&gt;</code>)与当前类型一致的默认构造函数,这个工作在填充符号表阶段中就已经完成。<code>&lt;init&gt;()</code>和<code>&lt;clinit&gt;()</code>这两个构造器的产生实际上是一种代码收敛的过程,编译器会把语句块(对于实例构造器而言是“{}”块,对于类构造器而言是“static{}”块)、变量初始化(实例变量和类变量)、调用父类的实例构造器(仅仅是实例构造器,<code>&lt;clinit&gt;()</code>方法中无须调用父类的<code>&lt;clinit&gt;()</code>方法,Java虚拟机会自动保证父类构造器的正确执行,但在<code>&lt;clinit&gt;()</code>方法中经常会生成调用<code>java.lang.Object</code>的<code>&lt;init&gt;()</code>方法的代码)等操作收敛到<code>&lt;init&gt;()</code>和<code>&lt;clinit&gt;()</code>方法之中,并且保证无论源码中出现的顺序如何,都一定是按先执行父类的实例构造器,然后初始化变量,最后执行语句块的顺序进行,上面所述的动作由<code>Gen::normalizeDefs()</code>方法来实现。除了生成构造器以外,还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式,如把字符串的加操作替换为<code>StringBuffer</code>或<code>StringBuilder</code>(取决于目标代码的版本是否大于或等于JDK 5)的<code>append()</code>操作,等等。</p><p>完成了对语法树的遍历和调整之后,就会把填充了所有所需信息的符号表交到<code>com.sun.tools.javac.jvm.ClassWriter</code>类手上,由这个类的<code>writeClass()</code>方法输出字节码,生成最终的Class 文件,到此,整个编译过程宣告结束。</p><h3 id="6-2-4、Java语法糖的味道"><a href="#6-2-4、Java语法糖的味道" class="headerlink" title="6.2.4、Java语法糖的味道"></a>6.2.4、Java语法糖的味道</h3><h4 id="1-gt-泛型"><a href="#1-gt-泛型" class="headerlink" title="1&gt;泛型"></a>1&gt;泛型</h4><p>泛型的本质是参数化类型(Parameterized Type)或者参数化多态(Parametric Polymorphism)的应用,即可以将操作的数据类型指定为方法签名中的一种特殊参数,这种参数类型能够用在类、接口和方法的创建中,分别构成泛型类、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法,这极大地增强了编程语言的类型系统及抽象能力。</p><h5 id="Java与C-的泛型"><a href="#Java与C-的泛型" class="headerlink" title="Java与C#的泛型"></a>Java与C#的泛型</h5><p>Java选择的泛型实现方式叫作“类型擦除式泛型”(Type Erasure Generics),而C#选择的泛型实现方式是“具现化式泛型”(Reified Generics)。</p><ul><li>C#里面泛型无论在程序源码里面、编译后的中间语言表示(Intermediate Language,这时候泛型是一个占位符)里面,抑或是运行期的CLR里面都是切实存在的,<code>List&lt;int&gt;</code>与<code>List&lt;string&gt;</code>就是两个不同的类型,它们由系统在运行期生成,有着自己独立的虚方法表和类型数据。</li><li>而Java语言中的泛型则不同,它只在程序源码中存在,在编译后的字节码文件中,全部泛型都被替换为原来的裸类型(Raw Type)了,并且在相应的地方插入了强制转型代码,因此对于运行期的Java语言来说,<code>ArrayList&lt;int&gt;</code>与<code>ArrayList&lt;String&gt;</code>其实是同一个类型</li></ul><p>以下是C#支持而Java不支持的泛型用法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeErasureGenerics</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Object item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 不合法,无法对泛型进行实例判断</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    E newItem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 不合法,无法使用泛型创建对象</span>    E<span class="token punctuation">[</span><span class="token punctuation">]</span> itemArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不合法,无法使用泛型创建数组    </span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这些是Java泛型在编码阶段产生的不良影响,如果说这种使用层次上的差别还可以通过多写几行代码、方法中多加一两个类型参数来解决的话,性能上的差距则是难以用编码弥补的。C#2.0引入了泛型之后,带来的显著优势之一便是对比起Java在执行性能上的提高,因为在使用平台提供的容器类型(如<code>List&lt;T&gt;</code>,<code>Dictionary&lt;TKey,TV alue&gt;</code>)时,无须像Java里那样不厌其烦地拆箱和装箱,如果在Java中要避免这种损失,就必须构造一个与数据类型相关的容器类(譬如<code>IntFloatHashMap</code>这样的容器)。显然,这除了引入更多代码造成复杂度提高、复用性降低之外,更是丧失了泛型本身的存在价值。</p><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上,几乎是全面落后于C#的具现化式泛型,而它的唯一优势是在于实现这种泛型的影响范围上:擦除式泛型的实现几乎只需要在Javac编译器上做出改进即可,不需要改动字节码、不需要改动Java虚拟机,也保证了以前没有使用泛型的库可以直接运行在Java 5.0之上。但这种听起来节省工作量甚至可以说是有偷工减料嫌疑的优势就显得非常短视,真的能在当年Java实现泛型的利弊权衡中胜出吗?答案的确是它胜出了,但我们必须在那时的泛型历史背景中去考虑不同实现方式带来的代价。</p><h5 id="泛型的历史背景"><a href="#泛型的历史背景" class="headerlink" title="泛型的历史背景"></a>泛型的历史背景</h5><p>为了保证这些编译出来的Class文件可以在Java 5.0引入泛型之后继续运行,设计者面前大体上有两条路可以选择: </p><ol><li>需要泛型化的类型(主要是容器类型),以前有的就保持不变,然后平行地加一套泛型化版本的新类型。</li><li>直接把已有的类型泛型化,即让所有需要泛型化的已有类型都原地泛型化,不添加任何平行于已有类型的泛型版。</li></ol><p>在这个分叉路口,C#走了第一条路,添加了一组<code>System.Collections.Generic</code>的新容器,以前的<code>System.Collections</code>以及<code>System.Collections.Specialized</code>容器类型继续存在。C#的开发人员很快就接受了新的容器,倒也没出现过什么不适应的问题,唯一的不适大概是许多.NET自身的标准库已经把老容器类型当作方法的返回值或者参数使用,这些方法至今还保持着原来的老样子。</p><p>但如果相同的选择出现在Java中就很可能不会是相同的结果了,要知道当时.NET才问世两年,而Java已经有快十年的历史了,再加上各自流行程度的不同,两者遗留代码的规模根本不在同一个数量级上。而且更大的问题是Java并不是没有做过第一条路那样的技术决策,在JDK 1.2时,遗留代码规模尚小,Java就引入过新的集合类,并且保留了旧集合类不动。这导致了直到现在标准类库中还有<code>Vector</code>(老)和<code>ArrayList</code>(新)、有<code>Hashtable</code>(老)和<code>HashMap</code>(新)等两套容器代码并存,如果当时再摆弄出像<code>Vector</code>(老)、<code>ArrayList</code>(新)、<code>Vector</code><t>(老但有泛型)、<code>ArrayList</code><t>(新且有泛型)这样的容器集合,可能叫骂声会比今天听到的更响更大。</t></t></p><p>所以Java只能选择第二条路了。但第二条路也并不意味着一定只能使用类型擦除来实现,如果当时有足够的时间好好设计和实现,是完全有可能做出更好的泛型系统的,否则也不会有今天的V alhalla项目来还以前泛型偷懒留下的技术债了。</p><h5 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h5><p>由于Java选择了第二条路,直接把已有的类型泛型化。要让所有需要泛型化的已有类型,譬如ArrayList,原地泛型化后变成了<code>ArrayList&lt;T&gt;</code>,而且保证以前直接用<code>ArrayList</code>的代码在泛型新版本里必须还能继续用这同一个容器,这就必须让所有泛型化的实例类型,譬如<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;String&gt;</code>这些全部自动成为ArrayList的子类型才能可以,否则类型转换就是不安全的。由此就引出了“裸类型”(Raw Type)的概念,裸类型应被视为所有该类型泛型化实例的共同父类型(Super Type),只有这样,以下代码中的赋值才是被系统允许的从子类到父类的安全转型。</p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ilist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> slist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ArrayList list<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 裸类型</span>list <span class="token operator">=</span> ilist<span class="token punctuation">;</span> list <span class="token operator">=</span> slist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来的问题是该如何实现裸类型。这里又有了两种选择:</p><ul><li>一种是在运行期由Java虚拟机来自动地、真实地构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型,并且自动实现从<code>ArrayList&lt;Integer&gt;</code>派生自<code>ArrayList</code> 的继承关系来满足裸类型的定义;</li><li>另外一种是索性简单粗暴地直接在编译时把<code>ArrayList&lt;Integer&gt;</code>还原回<code>ArrayList</code>,只在元素访问、修改时自动插入一些强制类型转换和检查指令</li></ul><p>Java选择了第二种：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"how are you?"</span><span class="token punctuation">,</span> <span class="token string">"吃了没?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"how are you?"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码反编译后：</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"how are you?"</span><span class="token punctuation">,</span> <span class="token string">"吃了没?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"how are you?"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型擦除的缺点：</p><ul><li><p>使用擦除法实现泛型直接导致了对原始类型(Primitive Types)数据的支持又成了新的麻烦</p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ilist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ArrayList<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> llist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ArrayList list<span class="token punctuation">;</span> list <span class="token operator">=</span> ilist<span class="token punctuation">;</span> list <span class="token operator">=</span> llist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下,一旦把泛型信息擦除后,到要插入强制转型代码的地方就没办法往下做了,因为不支持<code>int</code>、<code>long</code>与<code>Object</code>之间的强制转型。当时Java给出的解决方案一如既往的简单粗暴:既然没法转换那就索性别支持原生类型的泛型了吧,你们都用<code>ArrayList&lt;Integer&gt;</code>、<code>ArrayList&lt;Long&gt;</code>,反正都做了自动的强制类型转换,遇到原生类型时把装箱、拆箱也自动做了得了。这个决定后面导致了无数构造包装类和装箱、拆箱的开销,成为Java泛型慢的重要原因,也成为今天Valhalla项目要重点解决的问题之一。</p></li><li><p>运行期无法取到泛型类型信息,会让一些代码变得相当啰嗦, 需要写更多的代码通过其它方式获取, 有的地方甚至无法获取。如以下代码,我们去写一个泛型版本的从List到数组的转换方法,由于不能从List中取得参数化类型T,所以不得不从一个额外参数中再传入一个数组的组件类型进去,实属无奈。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">convert</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> componentType<span class="token punctuation">)</span> <span class="token punctuation">{</span>         T<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>componentType<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>最后,笔者认为通过擦除法来实现泛型,还丧失了一些面向对象思想应有的优雅,带来了一些模棱两可的模糊状况</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypes</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"invoke method(List&lt;String> list)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"invoke method(List&lt;Integer> list)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码是不能被编译的,因为参数<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>编译之后都被擦除了,变成了同一种的裸类型<code>List</code>, 类型擦除导致这两个方法的特征签名变得一模一样。</p><p>但是下面的例子在JDK 6的Javac编译器中又能通过并执行成功。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypes</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">method</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"invoke method(List&lt;String> list)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"invoke method(List&lt;Integer> list)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重载当然不是根据返回值来确定的,之所以这次能编译和执行成功,是因为两个<code>method()</code>方法加入了不同的返回值后才能共存在一个Class文件之中。在Class文件方法表(method_info)的数据结构中,<strong>方法重载</strong>要求方法具备不同的特征签名,返回值并不包含在方法的特征签名中,所以返回值不参与重载选择,这一点如果前端编译器不保证,即可编译通过。</p><p>而对于<strong>Class文件格式</strong>来说,只要描述符不是完全一致的两个方法就可以共存，所以编译通过后的代码也是可以执行的。</p></li></ul><p>由于Java泛型的引入,各种场景(虚拟机解析、反射等)下的方法调用都可能对原有的基础产生影响并带来新的需求,如在泛型类中如何获取传入的参数化类型等。所以JCP组织对《Java虚拟机规范》做出了相应的修改,引入了诸如Signature、LocalV ariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题,Signature是其中最重要的一项属性,它的作用就是存储一个方法在字节码层面的特征签名,这个属性中保存的参数类型并不是原生类型,而是包括了参数化类型的信息。<a href="http://java.sun.com/docs/books/jvms/second_edition/jvms-clarify.html" target="_blank" rel="noopener">修改后的虚拟机规范</a>要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</p><p>从上面的例子中可以看到擦除法对实际编码带来的不良影响,由于<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>擦除后是同一个类型,我们只能添加两个并不需要实际使用到的返回值才能完成重载,这是一种毫无优雅和美感可言的解决方案,并且存在一定语意上的混乱,譬如上面脚注中提到的,必须用JDK 6的Javac才能编译成功,其他版本或者是ECJ编译器都有可能拒绝编译。</p><p>另外,从Signature属性的出现我们还可以得出结论,擦除法所谓的擦除,仅仅是对方法的Code属性中的字节码进行擦除,实际上元数据中还是保留了泛型信息,这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</p><h5 id="值类型与未来的泛型"><a href="#值类型与未来的泛型" class="headerlink" title="值类型与未来的泛型"></a>值类型与未来的泛型</h5><p>在2014年,刚好是Java泛型出现的十年之后,Oracle建立了一个名为Valhalla的语言改进项目[10], 希望改进Java语言留下的各种缺陷(解决泛型的缺陷就是项目主要目标其中之一)。</p><p>在V alhalla项目中规划了几种不同的新泛型实现方案,被称为Model 1到Model 3,在这些新的泛型设计中,泛型类型有可能被具现化,也有可能继续维持类型擦除以保持兼容(取决于采用哪种实现方案),即使是继续采用类型擦除的方案,泛型的参数化类型也可以选择不被完全地擦除掉,而是相对完整地记录在Class文件中,能够在运行期被使用,也可以指定编译器默认要擦除哪些类型。相对于使用不同方式实现泛型,<strong>目前比较明确的是未来的Java应该会提供“值类型”(Value Type)的语言层面的支持</strong>。</p><p>说起值类型,这点也是C#用户攻讦Java语言的常用武器之一,C#并没有Java意义上的原生数据类型,在C#中使用的int、bool、double关键字其实是对应了一系列在.NET框架中预定义好的结构体(Struct),如Int32、Boolean、Double等。在C#中开发人员也可以定义自己值类型,只要继承于ValueType类型即可,而ValueType也是统一基类Object的子类,所以并不会遇到Java那样int不自动装箱就无法转型为Object的尴尬。</p><p>值类型可以与引用类型一样,具有构造函数、方法或是属性字段,等等,而它与引用类型的区别在于它在赋值的时候通常是整体复制,而不是像引用类型那样传递引用的。更为关键的是,值类型的实例很容易实现分配在方法的调用栈上的,这意味着值类型会随着当前方法的退出而自动释放,不会给垃圾收集子系统带来任何压力。</p><p>在Valhalla项目中,Java的值类型方案被称为“内联类型”,计划通过一个新的关键字inline来定义, 字节码层面也有专门与原生类型对应的以Q开头的新的操作码(譬如iload对应qload)来支撑。</p><h4 id="2-gt-自动装箱、拆箱与遍历循环"><a href="#2-gt-自动装箱、拆箱与遍历循环" class="headerlink" title="2&gt;自动装箱、拆箱与遍历循环"></a>2&gt;自动装箱、拆箱与遍历循环</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator localIterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> localIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> localIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖,分别展示了它们在编译前后发生的变化。泛型就不必说了,自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法,如<code>Integer.valueOf()</code>与<code>Integer.intValue()</code>方法,而遍历循环则是把代码还原成了迭代器的实现,这也是为何遍历循环需要被遍历的类实现<code>Iterable</code>接口的原因。最后再看看变长参数,它在调用的时候变成了一个数组类型的参数,在变长参数出现之前,程序员的确也就是使用数组来完成类似功能的。</p><p>以下是一些自动拆箱的不正确用法。</p><pre class="line-numbers language-java"><code class="language-java">        Integer a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Integer b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        Integer c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        Integer d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        Integer e <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>        Integer f <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>        Long g <span class="token operator">=</span> 3L<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true：发现对象是同一个，貌似是因为数值较小，所以会共用一个对象(常量池？)</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e <span class="token operator">==</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false："=="没有遇到运算符不会自动拆箱，且数值较大，不会共用对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true："=="遇到运算符会自动拆箱</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//true："=="遇到运算符会自动拆箱</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g <span class="token operator">==</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true："=="遇到运算符会自动拆箱</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//false：equals会做类型判断且不会处理类型转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-gt-条件编译"><a href="#3-gt-条件编译" class="headerlink" title="3&gt;条件编译"></a>3&gt;条件编译</h4><p>许多程序设计语言都提供了条件编译的途径,如C、C++中使用预处理器指示符(#ifdef)来完成条件编译。C、C++的预处理器最初的任务是解决编译时的代码依赖关系(如极为常用的#include预处理命令)。</p><ul><li><p>C/C++在预处理阶段通过对源文件中宏的判断条件进行预处理，对满足条件的一些宏定义进行展开。之后在编译阶段再对展开后的源文件进行整体编译。</p></li><li><p>而在Java语言之中并没有使用预处理器,因为Java语言天然的编译方式(编译器并非一个个地编译Java文件,而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译,因此各个文件之间能够互相提供符号信息)就无须使用到预处理器。</p></li></ul><p>Java语言当然也可以进行条件编译,方法就是使用条件为常量的if语句。如下：</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反编译后得到</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"block 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>该代码中的if语句不同于其他Java代码,它在编译阶段就会被“运行”</strong>,生成的字节码之中只包括<code>System.out.println(&quot;block 1&quot;);</code>一条语句,并不会包含if语句及另外一个分子中的<code>System.out.println(&quot;block 2&quot;);</code>。</p><p>只能使用<strong>条件为常量的if语句</strong>才能达到上述效果,如果使用常量与其他带有条件判断能力的语句搭配,则可能在控制流分析中提示错误,被拒绝编译：</p><pre class="line-numbers language-java"><code class="language-java">      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译器将会提示“Unreachable code” </span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-5、修改字节码的方式"><a href="#6-2-5、修改字节码的方式" class="headerlink" title="6.2.5、修改字节码的方式"></a>6.2.5、修改字节码的方式</h3><ol><li>手动编辑.class文件或者自己编写代码直接基于二进制流修改字节码</li><li>基于一些字节码框架如ASM</li><li>动态代理框架如JDK的动态代理、CGLIB</li><li>Javac提供的注解处理器机制</li></ol><h2 id="6-3、后端编译：JIT编译器"><a href="#6-3、后端编译：JIT编译器" class="headerlink" title="6.3、后端编译：JIT编译器"></a>6.3、后端编译：JIT编译器</h2><p>JIT（Just In Time Compiler）编译器：就是虚拟机将字节码直接编译成和本地机器平台相关的机器语言。</p><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</p><h3 id="6-3-1、和解释器并存"><a href="#6-3-1、和解释器并存" class="headerlink" title="6.3.1、和解释器并存"></a>6.3.1、和解释器并存</h3><p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以尽管JRocket VM程序因为不包含解释器，在启动过程将字节码完全编译后才开始运行带来了很高的性能，但这个编译过程可能花费了很长时间。对于服务端应用来说，启动时间并非是关注重点，但对于那些看重启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获取更高的执行效率。</p><p>当程序运行环境中内存资源限制较大,可以使用解释执行节约内存(如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在),反之可以使用编译执行来提升效率。同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的”逃生门”。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流,可能使处于冷机状态的服务器因无法承载流量而假死。在生产环境发布过程中,以分批的方式进行发布,根据机器数量划分成多个批次,每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例:某程序员在发布平台进行分批发布,在输入发布总批数时,误填写成分为两批发布。如果是热机状态,在正常情况下一半的机器可以勉强承载流量,但由于刚启动的JVM均是解释执行,还没有进行热点代码统计和JIT动态编译,导致机器启动之后,当前1/2发布成功的服务器马上全部宕机,此故障说明了JIT的存在。—阿里团队</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115328.png" alt="image-20200917114330410"></p><h3 id="6-3-2、热点代码及探测方式触发编译及优化"><a href="#6-3-2、热点代码及探测方式触发编译及优化" class="headerlink" title="6.3.2、热点代码及探测方式触发编译及优化"></a>6.3.2、热点代码及探测方式触发编译及优化</h3><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码,也被称之为“热点代码”,JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化,将其直接编译为对应平台的本地机器指令,以此提升Java程序的执行性能。</p><p><strong>一个被多次调用的方法或者是一个方法体内部循环次数较多的循环体</strong>都可以被称之为“热点代码”,因此都可以通过JIT编译器编译为本地机器指令, 对于这两种情况,<strong>编译的目标对象都是整个方法体,而不会是单独的循环体</strong>。</p><ol><li>第一种情况,由于是依靠方法调用触发的编译,那编译器理所当然地会以整个方法作为编译对象,这种编译也是虚拟机中标准的即时编译方式。</li><li>而对于后一种情况,尽管编译动作是由循环体所触发的,热点只是方法的一部分,<strong>但编译器依然必须以整个方法作为编译对象,只是执行入口(从方法第几条字节码指令开始执行)会稍有不同,编译时会传入执行入口点字节码序号(Byte Code Index,BCI)</strong>。这种编译方式因为编译发生在方法执行的过程中,因此被很形象地称为“栈上替换”(On Stack Replacement,OSR),即方法的栈帧还在栈上,方法就被替换了。</li></ol><p>一个方法究竟要被调用多少次,或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><h4 id="1-gt-基于计数器探测"><a href="#1-gt-基于计数器探测" class="headerlink" title="1&gt;基于计数器探测"></a>1&gt;基于计数器探测</h4><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。HotSpot VM将会为每一个方法都建立2个不同类型的计数器,分别为方法调用计数器(Invocation Counter)和回边计数器(back Edge Counter).当虚拟机运行参数确定的前提下,这两个计数器都有一个明确的阈值,计数器阈值一旦溢出,就会触发即时编译。</p><p>这种统计方法实现起来要麻烦一些,需要为每个方法建立并维护计数器,而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p><ol><li><p>方法调用计数器用于统计方法的调用次数</p><ul><li><p>这个计数器就用于统计方法被调用的次数,它的默认阈值在 client模式下是1500次,在 Server模式下是10000次。超过这个阈值,就会触发JIT编译。这个阈值可以通过虚拟机参数<code>-xx: CompileThreshold</code>来人为设定。</p></li><li><p>当一个方法被调用时,会先检查该方法是否存在被JIT编译过的版本：</p><ul><li><p>如果存在,则优先使用编译后的本地代码来执行。</p></li><li><p>如果不存在已被编译过的版本,则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值,那么将会向即时编译器提交一个该方法的代码编译请求。</p><p>如果没有做过任何设置,执行引擎默认不会同步等待编译请求完成,而是继续进入解释器按照解释方式执行字节码,直到提交的请求被即时编译器编译完成。当编译工作完成后,这个方法的调用入口地址就会被系统自动改写成新值,下一次调用该方法时就会使用已编译的版本了。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115336.png" alt="image-20200917141432235"></p></li></ul></li><li><p><strong>热度衰减</strong><br>如果不做任何设置,方法调用计数器统计的并不是方法被调用的绝对次数,而是一个相对的执行频率,即一段时间之内方法被调用的次数。当超过一定的时间限度,如果方法的调用次数仍然不足以让它提交给即时编译器编译,那这个方法的调用计数器就会被减少一半,这个过程称为方法调用计数器热度的衰减(Counter Decay),而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)。<br>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的,可以使用虚拟机参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减,让方法计数器统计方法调用的绝对次数,这样,只要系统运行时间足够长,绝大部分方法都会被编译成本地代码。<br>另外,可以使用<code>-XX:CounterHalfLife=&lt;N&gt;</code>参数设置半衰周期的时间,单位是秒。</p></li></ul></li><li><p>回边计数器则用于统计循环体执行的循环次数</p><p>它的作用是统计一个方法中循环体代码执行的次数<a href="准确地说,应当是回边的次数而不是循环次数,因为并非所有的循环都是回边,如空循环实际上就可以视为自己跳转到自己的过程,因此并不算作控制流向后跳转,也不会被回边计数器统计。">^2</a>,在字节码中遇到控制流向后跳转的指令就称为“回边(Back Edge)”,很显然建立回边计数器统计的目的是为了触发栈上的替换编译。</p><p>关于回边计数器的阈值,虽然HotSpot虚拟机也提供了一个类似于方法调用计数器阈值<code>-XX: CompileThreshold</code>的参数<code>-XX:BackEdgeThreshold</code>供用户设置,但是当前的HotSpot虚拟机实际上并未使用此参数,我们必须设置另外一个参数<code>-XX:OnStackReplacePercentage</code>来间接调整回边计数器的阈值,其计算公式有如下两种。</p><ul><li>虚拟机运行在客户端模式下,回边计数器阈值计算公式为:方法调用计数器阈值(<code>-XX: CompileThreshold</code>)乘以OSR比率(<code>-XX:OnStackReplacePercentage</code>)除以100。其中<code>-XX: OnStackReplacePercentage</code>默认值为933,如果都取默认值,那客户端模式虚拟机的回边计数器的阈值为13995。</li><li>虚拟机运行在服务端模式下,回边计数器阈值的计算公式为:方法调用计数器阈值(<code>-XX: CompileThreshold</code>)乘以(OSR比率(<code>-XX:OnStackReplacePercentage</code>)减去解释器监控比率(<code>-XX: InterpreterProfilePercentage</code>)的差值)除以100。其中<code>-XX:OnStack ReplacePercentage</code>默认值为140,<code>-XX:InterpreterProfilePercentage</code>默认值为33,如果都取默认值,那服务端模式虚拟机回边计数器的阈值为10700。</li></ul><p>当解释器遇到一条回边指令时,会先查找将要执行的代码片段是否有已经编译好的版本,如果有的话,它将会优先执行已编译的代码,否则就把回边计数器的值加一,然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候,将会提交一个栈上替换编译请求, 并且把回边计数器的值稍微降低一些,以便继续在解释器中执行循环,等待编译器输出编译结果</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115344.png" alt="image-20200917142023229"></p><p><strong>与方法计数器不同,回边计数器没有计数热度衰减的过程,因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候,它还会把方法计数器的值也调整到溢出状态,这样下次再进入该方法的时候就会执行标准编译过程。</strong></p></li></ol><h4 id="2-gt-基于采样的热点探测"><a href="#2-gt-基于采样的热点探测" class="headerlink" title="2&gt;基于采样的热点探测"></a>2&gt;基于采样的热点探测</h4><p>除了HotSpot采用的计数器探测法，另外还有一种方法是基于采样的热点探测(Sample Based Hot Spot Code Detection)。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶,如果发现某个(或某些)方法经常出现在栈顶,那这个方法就是“热点方法”。</p><p>基于采样的热点探测的好处是实现简单高效,还可以很容易地获取方法调用关系(将调用堆栈展开即可),缺点是很难精确地确认一个方法的热度,容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p><h3 id="6-3-3、编译过程"><a href="#6-3-3、编译过程" class="headerlink" title="6.3.3、编译过程"></a>6.3.3、编译过程</h3><p>在默认条件下,无论是方法调用产生的标准编译请求,还是栈上替换编译请求,虚拟机在编译器还未完成编译之前,都仍然将按照解释方式继续执行代码,而编译动作则在后台的编译线程中进行。<br>用户可以通过参数<code>-XX:-BackgroundCompilation</code>来禁止后台编译,后台编译被禁止后,当达到触发即时编译的条件时,执行线程向虚拟机提交编译请求以后将会一直阻塞等待,直到编译过程完成再开始执行编译器输出的本地代码。</p><p>那在后台执行编译的过程中,编译器具体会做什么事情呢?服务端编译器和客户端编译器的编译过程是有所差别的。</p><h4 id="客户端编译期"><a href="#客户端编译期" class="headerlink" title="客户端编译期"></a>客户端编译期</h4><p>对于客户端编译器来说,它是一个相对简单快速的三段式编译器,主要的关注点在于局部性的优化,而放弃了许多耗时较长的全局优化手段。</p><ol><li>在第一个阶段,一个平台独立的前端将字节码构造成一种高级中间代码表示(High-Level Intermediate Representation,HIR,即与目标机器指令集无关的中间表示)。HIR使用静态单分配(Static Single Assignment,SSA)的形式来代表代码值,这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化,如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</li><li>在第二个阶段,一个平台相关的后端从HIR中产生低级中间代码表示(Low-Level Intermediate Representation,LIR,即与目标机器指令集相关的中间表示),而在此之前会在HIR上完成另外一些优化,如空值检查消除、范围检查消除等,以便让HIR达到更高效的代码表示形式。</li><li>最后的阶段是在平台相关的后端使用线性扫描算法(Linear Scan Register Allocation)在LIR上分配寄存器,并在LIR上做窥孔(Peephole)优化,然后产生机器代码。客户端编译器大致的执行过程如图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115352.png" alt="image-20200922211554031"></p><h4 id="服务端编译期"><a href="#服务端编译期" class="headerlink" title="服务端编译期"></a>服务端编译期</h4><p>而服务端编译器则是专门面向服务端的典型应用场景,并为服务端的性能配置针对性调整过的编译器,也是一个能容忍很高优化复杂度的高级编译器,几乎能达到GNU C++编译器使用-O2参数时的优化强度。它会执行大部分经典的优化动作,如:无用代码消除(Dead Code Elimination)、循环展开(Loop Unrolling)、循环表达式外提(Loop Expression Hoisting)、消除公共子表达式(Common Subexpression Elimination)、常量传播(Constant Propagation)、基本块重排序(Basic Block Reordering)等,还会实施一些与Java语言特性密切相关的优化技术,如范围检查消除(Range Check Elimination)、空值检查消除(Null Check Elimination,不过并非所有的空值检查消除都是依赖编译器优化的,有一些是代码运行过程中自动优化了)等。另外,还可能根据解释器或客户端编译器提供的性能监控信息,进行一些不稳定的预测性激进优化,如守护内联(Guarded Inlining)、分支频率预测(Branch Frequency Prediction)等。</p><p>服务端编译采用的寄存器分配器是一个全局图着色分配器,它可以充分利用某些处理器架构(如RISC)上的大寄存器集合。以即时编译的标准来看,服务端编译器无疑是比较缓慢的,但它的编译速度依然远远超过传统的静态优化编译器,而且它相对于客户端编译器编译输出的代码质量有很大提高,可以大幅减少本地代码的执行时间,从而抵消掉额外的编译时间开销,所以也有很多非服务端的应用选择使用服务端模式的HotSpot虚拟机来运行。</p><h3 id="6-3-4、如何查看JIT编译情况"><a href="#6-3-4、如何查看JIT编译情况" class="headerlink" title="6.3.4、如何查看JIT编译情况"></a>6.3.4、如何查看JIT编译情况</h3><h4 id="使用JVM参数打印编译信息"><a href="#使用JVM参数打印编译信息" class="headerlink" title="使用JVM参数打印编译信息"></a>使用JVM参数打印编译信息</h4><h5 id="查看方法编译情况和方法内联情况"><a href="#查看方法编译情况和方法内联情况" class="headerlink" title="查看方法编译情况和方法内联情况"></a>查看方法编译情况和方法内联情况</h5><p>FastDebug或SlowDebug优化级别的HotSpot虚拟机, 需要自己编译将“–with-debug-level”参数设置为“fastdebug”或者“slowdebug”。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUM <span class="token operator">=</span> <span class="token number">15000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 这个空循环用于后面演示JIT代码优化过程</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calcSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+=</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">calcSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-XX:+PrintCompilation</code>要求虚拟机打印编译信息，其中带有“%”的输出说明是由回边计数器触发的栈上替换编译，输出的信息中可以确认,main()、calcSum()和doubleV alue()方法已经被编译</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">310</span>   <span class="token number">1</span>       java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token operator">:</span><span class="token operator">:</span><span class="token function">charAt</span> <span class="token punctuation">(</span><span class="token number">33</span> bytes<span class="token punctuation">)</span>     <span class="token number">329</span>   <span class="token number">2</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span><span class="token function">calcSum</span> <span class="token punctuation">(</span><span class="token number">26</span> bytes<span class="token punctuation">)</span>     <span class="token number">329</span>   <span class="token number">3</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span><span class="token function">doubleValue</span> <span class="token punctuation">(</span><span class="token number">4</span> bytes<span class="token punctuation">)</span>     <span class="token number">332</span>   <span class="token number">1</span><span class="token operator">%</span>      org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span>main @ <span class="token function">5</span> <span class="token punctuation">(</span><span class="token number">20</span> bytes<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>加上<code>-XX:+PrintInlining</code>要求虚拟机打印方法内联信息，doubleV alue()方法已被内联编译到calcSum()方法中,而calcSum()方法又被内联编译到main()方法里面,所以虚拟机再次执行main()方法的时候(举例而已, main()方法当然不会运行两次),calcSum()和doubleV alue()方法是不会再被实际调用的,没有任何方法分派的开销,它们的代码逻辑都被直接内联到main()方法里面了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">273</span>   <span class="token number">1</span>       java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token operator">:</span><span class="token operator">:</span><span class="token function">charAt</span> <span class="token punctuation">(</span><span class="token number">33</span> bytes<span class="token punctuation">)</span>     <span class="token number">291</span>   <span class="token number">2</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span><span class="token function">calcSum</span> <span class="token punctuation">(</span><span class="token number">26</span> bytes<span class="token punctuation">)</span>       @   <span class="token number">9</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span>doubleValue  <span class="token function">inline</span> <span class="token punctuation">(</span>hot<span class="token punctuation">)</span>     <span class="token number">294</span>   <span class="token number">3</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span><span class="token function">doubleValue</span> <span class="token punctuation">(</span><span class="token number">4</span> bytes<span class="token punctuation">)</span>     <span class="token number">295</span>   <span class="token number">1</span><span class="token operator">%</span>      org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span>main @ <span class="token function">5</span> <span class="token punctuation">(</span><span class="token number">20</span> bytes<span class="token punctuation">)</span>       @   <span class="token number">5</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span>calcSum  <span class="token function">inline</span> <span class="token punctuation">(</span>hot<span class="token punctuation">)</span>       @   <span class="token number">9</span>       org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>Test<span class="token operator">:</span><span class="token operator">:</span>doubleValue  <span class="token function">inline</span> <span class="token punctuation">(</span>hot<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查看反汇编代码"><a href="#查看反汇编代码" class="headerlink" title="查看反汇编代码"></a>查看反汇编代码</h5><p>自己编译或者在网上下载反汇编适配器HSDIS插件配合使用<code>-XX: +PrintAssembly</code>参数要求虚拟机打印编译方法的汇编代码。另外<code>FastDebug</code>或<code>SlowDebug</code>优化级别的HotSpot虚拟机才能直接支持,如果使用<code>Product</code>版的虚拟机,则需要在最前面加入参数<code>-XX: +UnlockDiagnosticVMOptions</code>打开虚拟机诊断模式。</p><p>如果没有HSDIS插件支持,也可以使用<code>-XX:+PrintOptoAssembly</code>(用于服务端模式的虚拟机) 或<code>-XX:+PrintLIR</code>(用于客户端模式的虚拟机)来输出比较接近最终结果的中间代码表示,上面代码被编译后部分反汇编(使用-XX:+PrintOptoAssembly)的输出结果如下所示。对于阅读来说,使用<code>-XX:+PrintOptoAssembly</code>参数输出的伪汇编结果包含了更多的信息(主要是注释),有利于人们阅读、理解虚拟机即时编译器的优化结果。</p><pre><code>…… ……000   B1: #       N1 &lt;- BLOCK HEAD IS JUNK   Freq: 1 000       pushq   rbp                               subq    rsp, #16    # Create frame                               nop     # nop for patch_verified_entry 006       movl    RAX, RDX    # spill 008       sall    RAX, #1 00a       addq    rsp, 16     # Destroy frame                               popq    rbp                               testl   rax, [rip + #offset_to_poll_page]    # Safepoint: poll for GC …… ……</code></pre><h5 id="查看本地代码具体生成过程"><a href="#查看本地代码具体生成过程" class="headerlink" title="查看本地代码具体生成过程"></a>查看本地代码具体生成过程</h5><p>如果除了本地代码的生成结果外,还想再进一步跟踪本地代码生成的具体过程,那可以使用参数<code>-XX:+PrintCFGToFile</code>(用于客户端编译器)或<code>-XX:PrintIdealGraphFile</code>(用于服务端编译器)要求Java虚拟机将编译过程中各个阶段的数据(譬如对客户端编译器来说包括字节码、HIR生成、LIR生成、寄存器分配过程、本地代码生成等数据)输出到文件中。然后使用<a href="http://ssw.jku.at/Research/Projects/JVM/CCVis.html" target="_blank" rel="noopener">Java HotSpot Client Compiler Visualizer</a>(用于分析客户端编译器)或<a href="http://ssw.jku.at/General/Staff/TW/igv.html" target="_blank" rel="noopener">Ideal Graph Visualizer</a>(用于分析服务端编译器)打开这些数据文件进行分析。</p><p>服务端编译器的中间代码表示是一种名为理想图(Ideal Graph)的程序依赖图(Program Dependence Graph,PDG),在运行Java程序的FastDebug或SlowDebug优化级别的虚拟机上的参数中加入<code>-XX:PrintIdealGraphLevel=2</code>、<code>-XX:PrintIdealGraphFile=ideal.xml</code>,即时编译后将会产生一个名为ideal.xml的文件,它包含了服务端编译器编译代码的全过程信息,可以使用Ideal Graph Visualizer对这些信息进行分析。</p><h6 id="编译Ideal-Graph-Visualizer及使用"><a href="#编译Ideal-Graph-Visualizer及使用" class="headerlink" title="编译Ideal Graph Visualizer及使用"></a>编译Ideal Graph Visualizer及使用</h6><p>上面地址里面的是基于JDK7版本的，8及以上都不能用。打算自己基于open jdk9版本编译一份出来，记录下编译步骤：</p><ol><li><p>下载<a href="https://downloads.apache.org/ant/binaries/" target="_blank" rel="noopener">ant构建工具</a>并配置环境变量<code>ANT_HOME=${ANT路径}</code>、<code>PATH=$PATH:$ANT_HOME/bin</code></p></li><li><p>进入openjdk IdealGraphVisualizer路径：<code>${openjdk9 sourcecode 根路径}/hotspot/src/share/tools/IdealGraphVisualizer/</code></p></li><li><p>参考目录下的<code>README.md</code>进行编译，直接运行<code>ant build</code>，但是遇到以下问题：</p><ul><li><p>下载<code>tasks.jar</code>超时：</p><pre class="line-numbers language-shell"><code class="language-shell">download:     [echo] Downloading clusters ide|platform      [get] Getting: http://deadlock.netbeans.org/hudson/job/nbms-and-javadoc/lastSuccessfulBuild/artifact/nbbuild/netbeans/harness/tasks.jar      [get] To: /var/folders/82/yy1bqb7s141_3m40prm43xz40000gn/T/tasks.jar      [get] Error getting http://deadlock.netbeans.org/hudson/job/nbms-and-javadoc/lastSuccessfulBuild/artifact/nbbuild/netbeans/harness/tasks.jar to /var/folders/82/yy1bqb7s141_3m40prm43xz40000gn/T/tasks.jarBUILD FAILED/Users/zhonghongpeng/ClionProjects/jvm/openjdk/hotspot/src/share/tools/IdealGraphVisualizer/build.xml:7: The following error occurred while executing this line:/Users/zhonghongpeng/ClionProjects/jvm/openjdk/hotspot/src/share/tools/IdealGraphVisualizer/nbproject/build-impl.xml:41: The following error occurred while executing this line:/Users/zhonghongpeng/ClionProjects/jvm/openjdk/hotspot/src/share/tools/IdealGraphVisualizer/nbproject/platform.xml:27: java.net.ConnectException: Operation timed out (Connection timed out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决：</p><p>参考了以下链接的描述将<code>./nbproject/platform.properties</code>中的<code>bootstrap.url</code>属性设置成<code>http://bits.netbeans.org/dev/nbms-and-javadoc/lastSuccessfulBuild/artifact/nbbuild/netbeans/harness/tasks.jar</code>。</p><blockquote><p><a href="https://bugs.openjdk.java.net/browse/JDK-8191868" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8191868</a></p><p><a href="http://hg.openjdk.java.net/jdk/hs/rev/f140bebf0348" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk/hs/rev/f140bebf0348</a></p></blockquote></li><li><p>下载的<code>catalog.xml.gz</code>文件有问题</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span> Downloading http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>updates<span class="token punctuation">.</span>netbeans<span class="token punctuation">.</span>org<span class="token operator">/</span>netbeans<span class="token operator">/</span>updates<span class="token operator">/</span><span class="token number">7.4</span><span class="token operator">/</span>uc<span class="token operator">/</span><span class="token keyword">final</span><span class="token operator">/</span>distribution<span class="token operator">/</span>catalog<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>gz<span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span> 九月 <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">2020</span> <span class="token number">9</span><span class="token operator">:</span><span class="token number">37</span><span class="token operator">:</span><span class="token number">32</span> 上午 org<span class="token punctuation">.</span>netbeans<span class="token punctuation">.</span>nbbuild<span class="token punctuation">.</span>AutoUpdateCatalogParser getInputSource<span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span> 信息<span class="token operator">:</span> The file at http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>updates<span class="token punctuation">.</span>netbeans<span class="token punctuation">.</span>org<span class="token operator">/</span>netbeans<span class="token operator">/</span>updates<span class="token operator">/</span><span class="token number">7.4</span><span class="token operator">/</span>uc<span class="token operator">/</span><span class="token keyword">final</span><span class="token operator">/</span>distribution<span class="token operator">/</span>catalog<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>gz<span class="token punctuation">,</span> corresponding to the catalog at http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>updates<span class="token punctuation">.</span>netbeans<span class="token punctuation">.</span>org<span class="token operator">/</span>netbeans<span class="token operator">/</span>updates<span class="token operator">/</span><span class="token number">7.4</span><span class="token operator">/</span>uc<span class="token operator">/</span><span class="token keyword">final</span><span class="token operator">/</span>distribution<span class="token operator">/</span>catalog<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>gz<span class="token punctuation">,</span> does not look like the gzip file<span class="token punctuation">,</span> trying to parse it as the pure xml<span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>EOFException<span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span>     at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>GZIPInputStream<span class="token punctuation">.</span><span class="token function">readUByte</span><span class="token punctuation">(</span>GZIPInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">268</span><span class="token punctuation">)</span><span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span>     at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>GZIPInputStream<span class="token punctuation">.</span><span class="token function">readUShort</span><span class="token punctuation">(</span>GZIPInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">258</span><span class="token punctuation">)</span><span class="token punctuation">[</span>autoupdate<span class="token punctuation">]</span>     at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>GZIPInputStream<span class="token punctuation">.</span><span class="token function">readHeader</span><span class="token punctuation">(</span>GZIPInputStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">164</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决：</p><p>参考<code>https://stackoverflow.com/questions/54326975/unable-to-connect-to-the-netbeans-distribution-because-of-zero-sized-file</code>将<code>./nbproject/platform.properties</code>中的<code>autoupdate.catalog.url</code>属性的”http”改成”https”。</p></li></ul></li><li><p>构建完成后授权执行即可：</p><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon IdealGraphVisualizer % chmod 777 ./igv.sh                               zhonghongpeng@bogon IdealGraphVisualizer % ./igv.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用参数<code>-XX:PrintIdealGraphLevel=2 -XX:PrintIdealGraphFile=ideal.xml -Xbatch</code>运行上面的代码得到多份<code>ideal&lt;n&gt;.xml</code>(注意参考<code>README.md</code>，其中就说明了最后一个参数如果不加将会导致程序结束后dump的xml文件不完整，导入到Ideal Graph Visualizer会报错)</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115402.png" alt="image-20200923101300031"></p><p>在Ideal Graph Visualizer中全部打开即可进行查看</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115408.png" alt="image-20200923101334213"></p></li></ol><h4 id="利用一些监控工具查看编译情况"><a href="#利用一些监控工具查看编译情况" class="headerlink" title="利用一些监控工具查看编译情况"></a>利用一些监控工具查看编译情况</h4><h5 id="VisualVM查看编译次数和时间"><a href="#VisualVM查看编译次数和时间" class="headerlink" title="VisualVM查看编译次数和时间"></a>VisualVM查看编译次数和时间</h5><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115417.png" alt="image-20200917114807396"></p><h5 id="Jconsole查看"><a href="#Jconsole查看" class="headerlink" title="Jconsole查看"></a>Jconsole查看</h5><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115427.png" alt="image-20200917114954541"></p><h3 id="6-3-5、分层优化"><a href="#6-3-5、分层优化" class="headerlink" title="6.3.5、分层优化"></a>6.3.5、分层优化</h3><p>由于即时编译器编译本地代码需要占用程序运行时间,通常要编译出优化程度越高的代码,所花费的时间便会越长;而且想要编译出优化程度更高的代码,解释器可能还要替编译器收集性能监控信息,这对解释执行阶段的速度也有所影响。为了在程序启动响应速度与运行效率之间达到最佳平衡, HotSpot虚拟机在编译子系统中加入了分层编译的功能[^1],分层编译的概念其实很早就已经提出,但直到JDK 6时期才被初步实现,后来一直处于改进阶段,最终在JDK 7的服务端模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时,划分出不同的编译层次,其中包括: </p><ul><li>第0层。程序纯解释执行,并且解释器不开启性能监控功能(Profiling)。</li><li>第1层。使用客户端编译器将字节码编译为本地代码来运行,进行简单可靠的稳定优化,不开启性能监控功能。</li><li>第2层。仍然使用客户端编译器执行,仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层。仍然使用客户端编译器执行,开启全部性能监控,除了第2层的统计信息外,还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层。使用服务端编译器将字节码编译为本地代码,相比起客户端编译器,服务端编译器会启用更多编译耗时更长的优化,还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>实施分层编译后,解释器、客户端编译器和服务端编译器就会同时工作,热点代码都可能会被多次编译,用客户端编译器获取更高的编译速度,用服务端编译器来获取更好的编译质量,在解释执行的时候也无须额外承担收集性能监控信息的任务,而在服务端编译器采用高复杂度的优化算法时,客户端编译器可先采用简单优化来为它争取更多的编译时间。</p><p>[^1]: 分层编译在JDK 6时期出现,到JDK 7之前都需要使用<code>-XX:+TieredCompilation</code>参数来手动开启, 如果不开启分层编译策略,而虚拟机又运行在服务端模式,服务端编译器需要性能监控信息提供编译依据,则是由解释器收集性能监控信息供服务端编译器使用。分层编译的相关资料可参见: <a href="http://weblogs.java.net/blog/forax/archive/2010/09/04/tiered-compilation。" target="_blank" rel="noopener">http://weblogs.java.net/blog/forax/archive/2010/09/04/tiered-compilation。</a></p><h4 id="配置执行引擎运行方式"><a href="#配置执行引擎运行方式" class="headerlink" title="配置执行引擎运行方式"></a>配置执行引擎运行方式</h4><p>缺省情况下 HotSpot VM是采用解释器与即时编译器并存的架构,当然开发人员可以根据具体的应用场景,通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行,还是完全采用即时编译器执行。如下所示:  </p><p><code>-Xint</code>：完全采用解释器模式执行程序<br><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题,解释器会介入执行。<br><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115438.png" alt="image-20200917142725766"></p><h3 id="6-3-6、编译器优化技术"><a href="#6-3-6、编译器优化技术" class="headerlink" title="6.3.6、编译器优化技术"></a>6.3.6、编译器优化技术</h3><h4 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a><a href="https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex" target="_blank" rel="noopener">优化技术概览</a></h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115446.png" alt="image-20200923114911958"><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115456.png" alt="image-20200923114932612"></p><p><strong>即时编译器对这些代码优化变换是建立在源代码转换得的中间表示或者是机器码之上的,绝不是直接在Java源码上去做的。</strong>下面仅仅基于Java源码作一个比喻：</p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// ...do stuff...</span>    z <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>方法内联,它的主要目的有两个:一是去除方法调用的成本(如查找方法版本、建立栈帧等); 二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段,可以获取更好的优化效果。因此各种编译器一般都会把内联优化放在优化序列最靠前的位置。内联后的代码：</li></ol><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ...do stuff...</span>        z <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>冗余访问消除(Redundant Loads Elimination),假设代码中间注释掉的<code>…do stuff…</code>所代表的操作不会改变<code>b.value</code>的值,那么就可以把<code>z=b.value</code>替换为<code>z=y</code>,因为上一句<code>y=b.value</code>已经保证了变量<code>y</code>与<code>b.value</code>是一致的,这样就可以不再去访问对象<code>b</code>的局部变量了。如果把<code>b.value</code>看作一个表达式,那么也可以把这项优化看作一种公共子表达式消除(Common Subexpression Elimination)</li></ol><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ...do stuff...</span>        z <span class="token operator">=</span> y<span class="token punctuation">;</span>        sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>复写传播(Copy Propagation),因为这段程序的逻辑之中没有必要使用一个额外的变量z,它与变量y是完全相等的,因此我们可以使用y来代替z。</li></ol><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ...do stuff...</span>        y <span class="token operator">=</span> y<span class="token punctuation">;</span>        sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>无用代码消除(Dead Code Elimination),无用代码可能是永远不会被执行的代码,也可能是完全没有意义的代码。因此它又被很形象地称为“Dead Code”, 如<code>y=y</code>是没有意义的</li></ol><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// ...do stuff...</span>        sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终优化出来得代码达到的效果是一致的,但是前者比后者省略了许多语句,体现在字节码和机器码指令上的差距会更大,执行效率的差距也会更高。</p><h4 id="最重要的优化技术之一-方法内联"><a href="#最重要的优化技术之一-方法内联" class="headerlink" title="最重要的优化技术之一:方法内联"></a>最重要的优化技术之一:方法内联</h4><p>方法内联,说它是编译器最重要的优化手段,甚至都可以不加上“之一”。内联被业内戏称为优化之母,因为除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do something"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testInline</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object obj <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上所示的简单例子就揭示了内联对其他优化手段的巨大价值:没有内联,多数其他优化都无法有效进行。例子里<code>testInline()</code>方法的内部全部是无用的代码,但如果不做内联,后续即使进行了无用代码消除的优化,也无法发现任何“Dead Code”的存在。如果分开来看,<code>foo()</code>和<code>testInline()</code>两个方法里面的操作都有可能是有意义的。</p><p>方法内联的优化行为理解起来是没有任何困难的,不过就是把目标方法的代码原封不动地“复制”到发起调用的方法之中,避免发生真实的方法调用而已。但实际上Java虚拟机中的内联过程却远没有想象中容易,甚至如果不是即时编译器做了一些特殊的努力,按照经典编译原理的优化理论,大多数的Java方法都无法进行内联。</p><p>无法内联的原因：只有使用<code>invokespecial</code>指令调用的私有方法、实例构造器、父类方法和使用<code>invokestatic</code>指令调用的静态方法才会在编译期进行解析。除了上述四种方法之外(最多再除去被<code>final</code>修饰的方法这种特殊情况,尽管它使用<code>invokevirtual</code>指令调用,但也是非虚方法,《Java语言规范》中明确说明了这点),其他的Java方法调用都必须在运行时进行方法接收者的多态选择,它们都有可能存在多于一个版本的方法接收者,简而言之,Java语言中默认的实例方法是虚方法。</p><p>对于一个虚方法,编译器<strong>静态地</strong>去做内联的时候很难确定应该使用哪个方法版本, 如果不依赖上下文,是无法确定b的实际类型是什么的。假如有<code>ParentB</code>和<code>SubB</code>是两个具有继承关系的父子类型,并且子类重写了父类的<code>get()</code>方法,那么此时对象<code>obj.get()</code>是执行父类的<code>get()</code>方法还是子类的<code>get()</code>方法,这应该是根据实际类型动态分派的,而实际类型必须在实际运行到这一行代码时才能确定,编译器很难在编译时得出绝对准确的结论。</p><p>更糟糕的情况是,由于Java提倡使用面向对象的方式进行编程,而Java对象的方法默认就是虚方法,可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。根据上面的分析可知,<strong>内联与虚方法之间会产生“矛盾”</strong>,那是不是为了提高执行性能,就应该默认给每个方法都使用<strong>final关键字</strong>去修饰呢（<strong>即由程序员通过编译器约定的关键字来告诉编译器那些虚方法可以进行内联</strong>）?</p><ul><li>C和C++语言的确是这样做的,默认的方法是非虚方法,如果需要用到多态,就用<code>virtual</code>关键字来修饰</li><li>但Java选择了在虚拟机中解决这个问题。</li></ul><p>为了解决虚方法的内联问题,Java虚拟机首先引入了一种名为<strong>类型继承关系分析(Class Hierarchy Analysis,CHA)的技术</strong>,这是整个应用程序范围内的类型分析技术,<strong>用于确定在目前已加载的类中,某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息</strong>。这样,编译器在进行内联时就会分不同情况采取不同的处理：</p><ul><li><p>如果是非虚方法,那么直接进行内联就可以了,这种的内联是有百分百安全保障的;</p></li><li><p>如果遇到虚方法,则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择：</p><ul><li><p>如果查询到只有一个版本,那就可以<strong>假设</strong>“应用程序的全貌就是现在运行的这个样子”来进行内联,这种内联被称为守护内联(Guarded Inlining)。</p><p>不过由于Java程序是动态连接的,说不准什么时候就会加载到新的类型从而改变CHA结论,因此这种内联属于<strong>激进预测性优化</strong>,必须预留好“逃生门”,即当假设条件不成立时的“退路”(Slow Path)。假如在程序的后续执行过程中<strong>,虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类</strong>,那这个内联优化的代码就可以一直使用下去。如果加载了导致继承关系发生变化的新类,那么就必须抛弃已经编译的代码,退回到解释状态进行执行,或者重新进行编译。</p></li><li><p>假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择,那即时编译器还将进行最后一次努力,使用<strong>内联缓存</strong>(Inline Cache)的方式来缩减方法调用的开销。这种状态下<strong>方法调用是真正发生</strong>了的,但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口之前的缓存,它的工作原理大致为:</p><p>在未发生方法调用之前,内联缓存状态为空,当第一次调用发生后,缓存记录下方法接收者的版本信息,并且每次进行方法调用时都比较接收者的版本。</p><ul><li>如果以后进来的每次调用的方法接收者版本都是一样的,那么这时它就是一种单态内联缓存(Monomorphic Inline Cache)。通过该缓存来调用,比用不内联的非虚方法调用,仅多了一次类型判断的开销而已。</li><li>但如果真的出现方法接收者不一致的情况,就说明程序用到了虚方法的多态特性,这时候会退化成超多态内联缓存(Megamorphic Inline Cache),其开销相当于真正查找虚方法表来进行方法分派。</li></ul></li></ul></li></ul><p>所以说,在多数情况下Java虚拟机进行的方法内联都是一种<strong>激进优化</strong>。事实上,激进优化的应用在高性能的Java虚拟机中比比皆是,极为常见。除了方法内联之外,对于出现概率很小(通过经验数据或解释器收集到的性能监控信息确定概率大小)的隐式异常、使用概率很小的分支等都可以被激进优化“移除”,如果真的出现了小概率事件,这时才会从“逃生门”回到解释状态重新执行。</p><h4 id="最前沿的优化技术之一-逃逸分析"><a href="#最前沿的优化技术之一-逃逸分析" class="headerlink" title="最前沿的优化技术之一:逃逸分析"></a>最前沿的优化技术之一:逃逸分析</h4><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术,它与类型继承关系分析一样,并不是直接优化代码的手段,而是为其他优化措施提供依据的分析技术。</p><p>逃逸分析的基本原理是分析对象动态作用域,当一个对象在方法里面被定义后,它可能被外部方法所引用：</p><ul><li>例如作为调用参数或者返回值传递到其他方法中、赋值到全局变量中,这种称为方法逃逸</li><li>甚至还有可能被外部线程访问到,譬如赋值给可以在其他线程中访问的实例变量,这种称为线程逃逸</li></ul><p>从<strong>不逃逸、方法逃逸到线程逃逸</strong>,称为对象由低到高的不同逃逸程度。</p><p>如果能证明一个对象不会逃逸到方法或线程之外(换句话说是别的方法或线程无法通过任何途径访问到这个对象),或者逃逸程度比较低(只逃逸出方法而不会逃逸出线程),则可能为这个对象实例采取不同程度的优化,如：</p><h5 id="1-gt-栈上分配-Stack-Allocations-3"><a href="#1-gt-栈上分配-Stack-Allocations-3" class="headerlink" title="1&gt;栈上分配(Stack Allocations)[^3]"></a>1&gt;栈上分配(Stack Allocations)[^3]</h5><p>在Java虚拟机中,Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识,Java堆中的对象对于各个线程都是共享和可见的,只要持有这个对象的引用,就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象,但回收动作无论是标记筛选出可回收对象,还是回收和整理内存,都需要耗费大量资源。如果确定一个对象不会逃逸出线程之外,那让这个对象在栈上分配内存将会是一个很不错的主意,对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中,完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的,如果能使用栈上分配,那大量的对象就会随着方法的结束而自动销毁了,垃圾收集子系统的压力将会下降很多。<strong>栈上分配可以支持方法逃逸,但不能支持线程逃逸</strong>。</p><h5 id="2-gt-标量替换-Scalar-Replacement"><a href="#2-gt-标量替换-Scalar-Replacement" class="headerlink" title="2&gt;标量替换(Scalar Replacement)"></a>2&gt;标量替换(Scalar Replacement)</h5><p>若一个数据已经无法再分解成更小的数据来表示了,Java虚拟机中的原始数据类型(int、long等数值类型及reference类型等)都不能再进一步分解了,那么这些数据就可以被称为标量。相对的,如果一个数据可以继续分解,那它就被称为聚合量(Aggregate),Java 中的对象就是典型的聚合量。</p><blockquote><p>这里的标量和线性代数中的标量还不是一回事</p></blockquote><p>如果把一个Java对象拆散,根据程序访问的情况,将其用到的成员变量恢复为原始类型来访问,这个过程就称为标量替换。假如逃逸分析能够证明<strong>一个对象不会被方法外部访问</strong>,并且这个对象可以被拆散,那么程序真正执行的时候将可能不去创建这个对象,而改为直接创建它的若干个被这个方法使用的成员变量来代替。<strong>将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,很大机会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写之外,还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例,实现更简单(不用考虑整个对象完整结构的分配),但对逃逸程度的要求更高,它不允许对象逃逸出方法范围内</strong>。</p><h5 id="3-gt-同步消除-Synchronization-Elimination"><a href="#3-gt-同步消除-Synchronization-Elimination" class="headerlink" title="3&gt;同步消除(Synchronization Elimination)"></a>3&gt;同步消除(Synchronization Elimination)</h5><p>线程同步本身是一个相对耗时的过程,如果逃逸分析能够确定一个变量不会逃逸出线程,无法被其他线程访问,那么这个变量的读写肯定就不会有竞争, 对这个变量实施的同步措施也就可以安全地消除掉。</p><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。同步锁消除能大大提高并发性能。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115509.png" alt="image-20200916150511162"></p><p>以下方法锁对象未发生逃逸，在转换成字节码之后，可以看到还是有加锁字节码指令的，所以前端编译器完全没有参与到逃逸分析和同步锁消除得过程，它完全依赖后端(JIT)编译器。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115536.png" alt="image-20200916150716430"></p><h5 id="逃逸分析发展"><a href="#逃逸分析发展" class="headerlink" title="逃逸分析发展"></a>逃逸分析发展</h5><p>关于逃逸分析的研究论文早在1999年就已经发表,但直到JDK 6,HotSpot才开始支持初步的逃逸分析,而且到现在这项优化技术尚未足够成熟,仍有很大的改进余地。不成熟的原因主要是逃逸分析的计算成本非常高,甚至不能保证逃逸分析带来的性能收益会高于它的消耗。如果要百分之百准确地判断一个对象是否会逃逸,需要进行一系列复杂的数据流敏感的过程间分析,才能确定程序各个分支执行时对此对象的影响。前面介绍即时编译、提前编译优劣势时提到了过程间分析这种大压力的分析算法正是即时编译的弱项。可以试想一下,<strong>如果逃逸分析完毕后发现几乎找不到几个不逃逸的对象, 那这些运行期耗用的时间就白白浪费了,所以目前虚拟机只能采用不那么准确,但时间压力相对较小的算法来完成分析</strong>。</p><p>在实际的应用程序中,尤其是大型程序中反而发现实施逃逸分析可能出现效果不稳定的情况,或分析过程耗时但却无法有效判别出非逃逸对象而导致性能(即时编译的收益)下降,所以曾经在很长的一段时间里,即使是服务端编译器,也默认不开启逃逸分析[^4],甚至在某些版本(如JDK 6 Update 18)中还曾经完全禁止了这项优化,一直到<strong>JDK 7时这项优化才成为服务端编译器默认开启的选项</strong>。如果有需要,或者确认对程序运行有益,用户也可以使用参数<code>-XX:+DoEscapeAnalysis</code>来手动开启逃逸分析, 开启之后可以通过参数<code>-XX:+PrintEscapeAnalysis</code>来查看分析结果。有了逃逸分析支持之后,用户可以使用参数<code>-XX:+EliminateAllocations</code>来开启标量替换,使用<code>+XX:+EliminateLocks</code>来开启同步消除,使用参数<code>-XX:+PrintEliminateAllocations</code>查看标量的替换情况。</p><h5 id="逃逸分析优化示例"><a href="#逃逸分析优化示例" class="headerlink" title="逃逸分析优化示例"></a>逃逸分析优化示例</h5><p>C和C++语言里面原生就支持了栈上分配(不使用new操作符即可)。</p><p>而C#也支持值类型,可以很自然地做到标量替换(但并不会对引用类型做这种优化)。</p><p>在灵活运用栈内存方面,确实是Java的一个弱项。在现在仍处于实验阶段的Valhalla项目里,设计了新的inline关键字用于定义Java的内联类型, <strong>目的是实现与C#中值类型相对标的功能</strong>。有了这个标识与约束,以后逃逸分析做起来就会简单很多。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 完全未优化的代码</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        Point p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>xx<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 步骤1:将Point的构造函数和getX()方法进行内联优化</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        Point p <span class="token operator">=</span> <span class="token function">point_memory_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 在堆中分配P对象的示意方法    </span>        p<span class="token punctuation">.</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// Point构造函数被内联后的样子</span>        p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">42</span>         <span class="token keyword">return</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// Point::getX()被内联后的样子</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 步骤2:经过逃逸分析,发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸, 这样可以对它进行标量替换优化,把其内部的x和y直接置换出来,分解为test()方法内的局部变量,从而避免Point对象实例被实际创建</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> px <span class="token operator">=</span> xx<span class="token punctuation">;</span>        <span class="token keyword">int</span> py <span class="token operator">=</span> <span class="token number">42</span>         <span class="token keyword">return</span> px<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 步骤3:通过数据流分析,发现py的值其实对方法不会造成任何影响,那就可以放心地去做无效代码消除得到最终优化结果</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h5><p><a href="https://www.jianshu.com/p/20bd2e9b1f03" target="_blank" rel="noopener">浅谈Hotspot逃逸分析</a></p><p>[^3]: 由于复杂度等原因,HotSpot中目前暂时还没有做这项优化,但一些其他的虚拟机(如Excelsior JET)使用了这项优化<br>[^4]: 从JDK 6 Update 23开始,服务端编译器中开始才默认开启逃逸分析。</p><h4 id="语言无关的经典优化技术之一-公共子表达式消除"><a href="#语言无关的经典优化技术之一-公共子表达式消除" class="headerlink" title="语言无关的经典优化技术之一:公共子表达式消除"></a>语言无关的经典优化技术之一:公共子表达式消除</h4><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术,它的含义是:如果一个表达式E之前已经被计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化,那么E 的这次出现就称为公共子表达式。对于这种表达式,没有必要花时间再对它重新进行计算,只需要直接用前面计算过的表达式结果代替E。如果这种优化仅限于<strong>程序基本块内</strong>,便可称为局部公共子表达式消除(Local Common Subexpression Elimination),如果这种优化的范围涵盖了多个基本块,那就称为全局公共子表达式消除(Global Common Subexpression Elimination)。</p><blockquote><p>基本块可以通俗理解为一个没有嵌套的大括号范围，如：<code>if</code>语句块、<code>while</code>语句块等。</p></blockquote><pre><code>int d = (c * b) * 12 + a + (a + b * c);</code></pre><p>如果这段代码交给Javac编译器则不会进行任何优化,那生成的代码如下</p><pre><code>iload_2       // b imul          // 计算b*c bipush 12     // 推入12 imul          // 计算(c * b) * 12 iload_1       // a iadd          // 计算(c * b) * 12 + a iload_1       // a iload_2       // b iload_3       // c imul          // 计算b * c iadd          // 计算a + b * c iadd          // 计算(c * b) * 12 + a + a + b * c istore 4</code></pre><p>当这段代码进入虚拟机即时编译器后,它将进行如下优化:编译器检测到c<em>b与b</em>c是一样的表达式,而且在计算期间b与c的值是不变的。因此这条表达式就可能被视为:</p><pre><code>int d = E * 12 + a + (a + E);</code></pre><p>这时候,编译器还可能(取决于哪种虚拟机的编译器以及具体的上下文而定)进行另外一种优化——代数化简(Algebraic Simplification),在E本来就有乘法运算的前提下,把表达式变为:</p><pre><code>int d = E * 13 + a + a;</code></pre><h4 id="语言相关的经典优化技术之一-数组边界检查消除"><a href="#语言相关的经典优化技术之一-数组边界检查消除" class="headerlink" title="语言相关的经典优化技术之一:数组边界检查消除"></a>语言相关的经典优化技术之一:数组边界检查消除</h4><p>组边界检查消除(Array Bounds Checking Elimination)是即时编译器中的一项语言相关的经典优化技术。我们知道Java语言是一门动态安全的语言,对数组的读写访问也不像C、C++那样实质上就是裸指针操作。如果有一个数组<code>foo[]</code>,在Java语言中访问数组元素<code>foo[i]</code>的时候系统将会自动进行上下界的范围检查,即i必须满足<code>i&gt;=0&amp;&amp;i&lt;foo.length</code>的访问条件,否则将抛出一个运行时异常: <code>java.lang.ArrayIndexOutOfBoundsException</code>。这对软件开发者来说是一件很友好的事情,即使程序员没有专门编写防御代码,也能够避免大多数的溢出攻击。但是对于虚拟机的执行子系统来说,<strong>每次数组元素的读写都带有一次隐含的条件判定操作,对于拥有大量数组访问的程序代码,这必定是一种性能负担</strong>。</p><p>无论如何,为了安全,数组边界检查肯定是要做的,但数组边界检查是不是必须在运行期间一次不漏地进行则是可以“商量”的事情。例如：</p><ul><li><p>下面这个简单的情况:<strong>数组下标是一个常量</strong>,如<code>foo[3]</code>,<strong>只要在编译期根据数据流分析来确定<code>foo.length</code>的值</strong>,并判断下标<code>3</code>没有越界,就去掉检查的代码, 在执行的时候就没有了检查边界的那一步了。</p></li><li><p>更加常见的情况是,数组访问发生在循环之中,并且使用循环变量来进行数组的访问。如果编译器<strong>只要通过数据流分析就可以判定循环变量的取值范围永远在区间<code>[0,foo.length)</code>之内</strong>,那么在循环中就可以把整个数组的上下界检查消除掉,这可以节省很多次的条件判断操作。</p></li><li><p>把这个数组边界检查的例子放在更高的视角来看,大量的安全检查使编写Java程序比编写C和C++程序容易了很多,比如:数组越界会得到<code>ArrayIndexOutOfBoundsException</code>异常;空指针访问会得到<code>NullPointException</code>异常;除数为零会得到<code>ArithmeticException</code>异常……在C和C++程序中出现类似的问题,一个不小心就会出现<code>Segment Fault</code>信号或者Windows编程中常见的“XXX内存不能为Read/Write”之类的提示,处理不好程序就直接崩溃退出了。但这些安全检查也导致出现相同的程序, 从而使Java比C和C++要做更多的事情(各种检查判断),这些事情就会导致一些隐式开销,如果不处理好它们,就很可能成为一项“Java语言天生就比较慢”的原罪。</p><p>为了消除这些隐式开销,<strong>除了如数组边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外,还有一种避开的处理思路——隐式异常处理</strong>,Java中空指针检查和算术运算中除数为零的检查都采用了这种方案：</p><p>虚拟机会注册一个<code>Segment Fault</code>信号的异常处理器,此时不用进行任何检查,而代价就是发生空指针调用或者除0的时候,<strong>必须转到异常处理器中恢复中断并抛出<code>NullPointException</code>或者<code>ArithmeticException</code>异常</strong>。进入异常处理器的过程涉及进程从用户态转到内核态中处理的过程,结束后会再回到用户态,速度远比一次判空检查要慢得多。当这样的错误发生极少的时候,隐式异常优化是值得的,但假如发生很频繁,这样的优化反而会让程序更慢。幸好HotSpot虚拟机足够聪明,它会根据运行期收集到的性能监控信息自动选择最合适的方案。</p></li></ul><h2 id="6-4、提前编译器：AOT"><a href="#6-4、提前编译器：AOT" class="headerlink" title="6.4、提前编译器：AOT"></a>6.4、提前编译器：AOT</h2><p>前编译在Java技术体系中并不是新事物。1996年JDK 1.0发布,Java有了正式的运行环境,第一个可以使用外挂即时编译器的Java版本是1996年7月发布的JDK 1.0.2,而Java提前编译器的诞生并没有比这晚多少。仅几个月后,IBM公司就推出了第一款用于Java语言的提前编译器(IBM High Performance Compiler for Java)。在1998年,GNU组织公布了著名的GCC家族(GNU Compiler Collection)的新成员GNU Compiler for Java(GCJ,2018年从GCC家族中除名),这也是一款Java的提前编译器[1],而且曾经被广泛应用。在OpenJDK流行起来之前,各种Linux发行版带的Java实现通常就是GCJ。</p><p>但是提前编译很快又在Java世界里沉寂了下来,因为当时Java的一个核心优势是平台中立性,其宣传口号是“一次编译,到处运行”,这与平台相关的提前编译在理念上就是直接冲突的。GCJ出现之后在长达15年的时间里,提前编译这条故事线上基本就再没有什么大的新闻和进展了。</p><p>现在提前编译产品和对其的研究有着两条明显的分支:</p><ul><li>一条分支是做与传统C、C++编译器类似的,在程序运行之前把程序代码编译成机器码的静态翻译工作，这是传统的提前编译应用形式：<ol><li>它在Java中存在的价值直指即时编译的最大弱点即时编译要占用程序运行时间和运算资源。即使现在先进的即时编译器已经足够快,但是,无论如何,即时编译消耗的时间都是原本可用于程序运行的时间,消耗的运算资源都是原本可用于程序运行的资源,这个约束从未减弱,更不会消失。在编译过程中最耗时的优化措施之一是通过“过程间分析”(Inter-Procedural Analysis,IPA,也经常被称为全程序分析,即Whole Program Analysis)来获得诸如某个程序点上某个变量的值是否一定为常量、某段代码块是否永远不可能被使用、在某个点调用的某个虚方法是否只能有单一版本等的分析结论。这些信息对生成高质量的优化代码有着极为巨大的价值,但是要精确(譬如对流敏感、对路径敏感、对上下文敏感、对字段敏感)得到这些信息, 必须在全程序范围内做大量极耗时的计算工作,目前所有常见的Java虚拟机对过程间分析的支持都相当有限,要么借助大规模的方法内联来打通方法间的隔阂,以过程内分析(Intra-Procedural Analysis, 只考虑过程内部语句,不考虑过程调用的分析)来模拟过程间分析的部分效果;要么借助可假设的激进优化,不求得到精确的结果,只求按照最可能的状况来优化,有问题再退回来解析执行。</li><li>但如果是在程序运行之前进行的静态编译,这些耗时的优化就可以放心大胆地进行了,譬如Graal VM中的Substrate VM,在创建本地镜像的时候,就会采取许多原本在HotSpot即时编译中并不会做的全程序优化措施以获得更好的运行时性能,反正做镜像阶段慢一点并没有什么大影响。</li></ol></li><li>另外一条分支是把原本即时编译器在运行时要做的编译工作提前做好并保存下来,下次运行到这些代码(譬如公共库代码在被同一台机器其他Java进程使用)时直接把它加载进来使用。本质是给即时编译器做缓存加速,去改善Java程序的启动时间,以及需要一段时间预热后才能到达最高性能的问题。这种提前编译被称为动态提前编译(Dynamic AOT)或者索性就大大方方地直接叫即时编译缓存(JIT Caching)。<ul><li>真正引起业界普遍关注的是OpenJDK/OracleJDK 9中所带的Jaotc提前编译器,这是一个基于Graal编译器实现的新工具,目的是让用户可以针对目标机器,为应用程序进行提前编译。HotSpot运行时可以直接加载这些编译的结果,实现加快程序启动速度,减少程序达到全速运行状态所需时间的目的。这里面确实有比较大的优化价值,试想一下,各种Java应用最起码会用到Java的标准类库,如java.base等模块,如果能够将这个类库提前编译好,并进行比较高质量的优化,显然能够节约不少应用运行时的编译成本。</li><li>这的确是很好的想法,但实际应用起来并不是那么容易,原因是这种提前编译方式不仅要和目标机器相关,甚至还必须与HotSpot虚拟机的运行时参数绑定。譬如虚拟机运行时采用了不同的垃圾收集器,这原本就需要即时编译子系统的配合(典型的如生成内存屏障代码,见第3章相关介绍)才能正确工作,要做提前编译的话,自然也要把这些配合的工作平移过去。至于前面提到过的提前编译破坏平台中立性、字节膨胀等缺点当然还存在,这里就不重复了。尽管还有许多困难,但提前编译无疑已经成为一种极限榨取性能(启动、响应速度)的手段,且被官方JDK关注,相信日后会更加灵活、更加容易使用</li></ul></li></ul><h3 id="和JIT编译对比"><a href="#和JIT编译对比" class="headerlink" title="和JIT编译对比"></a>和JIT编译对比</h3><h4 id="性能分析制导优化-Profile-Guided-Optimization-PGO"><a href="#性能分析制导优化-Profile-Guided-Optimization-PGO" class="headerlink" title="性能分析制导优化(Profile-Guided Optimization,PGO)"></a>性能分析制导优化(Profile-Guided Optimization,PGO)</h4><p>在解释器或者客户端编译器运行过程中,会不断收集性能监控信息,譬如某个程序点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等,这些数据一般在静态分析时是无法得到的,或者不可能存在确定且唯一的解, 最多只能依照一些启发性的条件去进行猜测。但在动态运行时却能看出它们具有非常明显的偏好性。</p><p>如果一个条件分支的某一条路径执行特别频繁,而其他路径鲜有问津,那就可以把热的代码集中放到一起,集中优化和分配更好的资源(分支预测、寄存器、缓存等)给它。</p><h4 id="激进预测性优化-Aggressive-Speculative-Optimization"><a href="#激进预测性优化-Aggressive-Speculative-Optimization" class="headerlink" title="激进预测性优化(Aggressive Speculative Optimization)"></a>激进预测性优化(Aggressive Speculative Optimization)</h4><p>这也已经成为很多即时编译优化措施的基础。静态优化无论如何都必须保证优化后所有的程序外部可见影响(不仅仅是执行结果) 与优化前是等效的,不然优化之后会导致程序报错或者结果不对,若出现这种情况,则速度再快也是没有价值的。然而,相对于提前编译来说,即时编译的策略就可以不必这样保守,如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断,就已经可以大胆地按照高概率的假设进行优化,万一真的走到罕见分支上,大不了退回到低级编译器甚至解释器上去执行,并不会出现无法挽救的后果。只要出错概率足够低,这样的优化往往能够大幅度降低目标程序的复杂度, 输出运行速度非常高的代码。譬如在Java语言中,默认方法都是虚方法调用,部分C、C++程序员(甚至一些老旧教材)会说虚方法是不能内联的,但如果Java虚拟机真的遇到虚方法就去查虚表而不做内联的话,Java技术可能就已经因性能问题而被淘汰很多年了。实际上虚拟机会通过类继承关系分析等一系列激进的猜测去做去虚拟化(Devitalization),以保证绝大部分有内联价值的虚方法都可以顺利内联。内联是最基础的一项优化措施。(即编译期还有一个解释器逃生门)</p><h4 id="链接时优化-Link-Time-Optimization-LTO"><a href="#链接时优化-Link-Time-Optimization-LTO" class="headerlink" title="链接时优化(Link-Time Optimization,LTO)"></a>链接时优化(Link-Time Optimization,LTO)</h4><p>Java语言天生就是动态链接的,一个个Class文件在运行期被加载到虚拟机内存当中,然后在即时编译器里产生优化后的本地代码,这类事情在Java程序员眼里看起来毫无违和之处。但如果类似的场景出现在使用提前编译的语言和程序上,譬如C、C++的程序要调用某个动态链接库的某个方法,就会出现很明显的边界隔阂,还难以优化。这是因为主程序与动态链接库的代码在它们编译时是完全独立的,两者各自编译、优化自己的代码。这些代码的作者、编译的时间,以及编译器甚至很可能都是不同的,当出现跨链接库边界的调用时,那些理论上应该要做的优化——譬如做对调用方法的内联,就会执行起来相当的困难。如果刚才说的虚方法内联让C、C++程序员理解还算比较能够接受的话(其实C++编译器也可以通过一些技巧来做到虚方法内联),那这种跨越动态链接库的方法内联在他们眼里可能就近乎于离经叛道了(但实际上依然是可行的)。</p><h3 id="最大好处"><a href="#最大好处" class="headerlink" title="最大好处"></a>最大好处</h3><p>Java虚拟机加载已经预编译成二进制库,可以直接执行。不必等待即时编译器的预热,减少Java应用给人带来“第一次运行慢”的不良体验。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>破坏了java”一次编译,到处运行”,必须为每个不同硬件、OS编译对应的发行包。</li><li>降低了Java链接过程的动态性,加载的代码在编译期就必须全部已知。</li><li>还需要继续优化中,最初只支持 Linux x64 java base</li></ul><h3 id="实战：Jaotc的提前编译"><a href="#实战：Jaotc的提前编译" class="headerlink" title="实战：Jaotc的提前编译"></a>实战：Jaotc的提前编译</h3><p>JDK 9引入了用于支持对Class文件和模块进行提前编译的工具Jaotc,以减少程序的启动时间和到达全速性能的预热时间,但由于这项功能必须针对特定物理机器和目标虚拟机的运行参数来使用,加之限制太多,Java开发人员对此了解、使用普遍比较少</p><p>我们首先通过一段测试代码(什么代码都可以,最简单的HelloWorld都可以,内容笔者就不贴了)来演示Jaotc的基本使用过程,操作如下: </p><pre class="line-numbers language-shell"><code class="language-shell">$ javac HelloWorld.java$ java HelloWorld Hello World! $ jaotc --output libHelloWorld.so HelloWorld.class <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过以上命令,就生成了一个名为<code>libHelloWorld.so</code>的库,我们可以使用Linux的<code>ldd</code>命令来确认这是否是一个静态链接库,使用<code>mn</code>命令来确认其中是否包含了HelloWorld的构造函数和<code>main()</code>方法的入口信息,操作如下</p><pre class="line-numbers language-shell"><code class="language-shell">$ ldd libHelloWorld.so statically linked $ nm libHelloWorld.so ……0000000000002a20 t HelloWorld.()V 0000000000002b20 t HelloWorld.main([Ljava/lang/String;)V ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们就可以使用这个静态链接库而不是Class文件来输出HelloWorld了:</p><pre class="line-numbers language-shell"><code class="language-shell"> java -XX:AOTLibrary=./libHelloWorld.so HelloWorld Hello World!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提前编译一个HelloWorld只具备演示价值,下一步我们来做更有实用意义的事情:把<code>java.base</code>模块编译成类似的静态链接库。<code>java.base</code>包含的代码数量庞大,虽然其中绝大部分内容现在都能被Jaotc的提前编译所支持了,但总还有那么几个“刺头”会导致编译异常。因此我们要建立一个编译命令文件来排除这些目前还不支持提前编译的方法,将此文件取名为<code>java.base-list.txt</code>,其具体内容如下: </p><pre class="line-numbers language-shell"><code class="language-shell"># jaotc: java.lang.StackOverflowError exclude sun.util.resources.LocaleNames.getContents()[[Ljava/lang/Object; exclude sun.util.resources.TimeZoneNames.getContents()[[Ljava/lang/Object; exclude sun.util.resources.cldr.LocaleNames.getContents()[[Ljava/lang/Object; exclude sun.util.resources..*.LocaleNames_.*.getContents\(\)\[\[Ljava/lang/Object; exclude sun.util.resources..*.LocaleNames_.*_.*.getContents\(\)\[\[Ljava/lang/Object; exclude sun.util.resources..*.TimeZoneNames_.*.getContents\(\)\[\[Ljava/lang/Object; exclude sun.util.resources..*.TimeZoneNames_.*_.*.getContents\(\)\[\[Ljava/lang/Object; # java.lang.Error: Trampoline must not be defined by the bootstrap classloader exclude sun.reflect.misc.Trampoline.<clinit>()V exclude sun.reflect.misc.Trampoline.invoke(Ljava/lang/reflect/Method;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; # JVM asserts exclude com.sun.crypto.provider.AESWrapCipher.engineUnwrap([BLjava/lang/String;I)Ljava/security/Key; exclude sun.security.ssl.* exclude sun.net.RegisteredDomain.<clinit>()V # Huge methods exclude jdk.internal.module.SystemModules.descriptors()[Ljava/lang/module/ModuleDescriptor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们就可以开始进行提前编译了,使用的命令如下所示:</p><pre class="line-numbers language-shell"><code class="language-shell">jaotc -J-XX:+UseCompressedOops -J-XX:+UseG1GC -J-Xmx4g --compile-for-tiered --info --compile-commands java.base-list.txt --output libjava.base-coop.so --module java.base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面Jaotc用了<code>-J</code>参数传递与目标虚拟机相关的运行时参数,这些运行时信息与编译的结果是直接相关的,编译后的静态链接库只能支持运行在相同参数的虚拟机之上,如果需要支持多种虚拟机运行参数(譬如采用不同垃圾收集器、是否开启压缩指针等)的话,可以花点时间为每一种可能用到的参数组合编译出对应的静态链接库。此外,由于Jaotc是基于Graal编译器开发的,所以现在ZGC和Shenandoah收集器还不支持Graal编译器,自然它们在Jaotc上也是无法使用的。事实上,目前Jaotc只支持G1和Parallel(PS+PS Old)两种垃圾收集器。使用Jaotc编译java.base模块的输出结果如下所示: </p><pre class="line-numbers language-shell"><code class="language-shell">$ jaotc -J-XX:+UseCompressedOops -J-XX:+UseG1GC -J-Xmx4g --compile-for-tiered --info --compile-commands java.base-list.txt --output libjava.base-coop.so --module java.base Compiling libjava.base-coop.so...6177 classes found (335 ms) 55845 methods total, 49575 methods to compile (1037 ms) Compiling with 4 threads ……49575 methods compiled, 0 methods failed (138821 ms) Parsing compiled code (906 ms) Processing metadata (10867 ms) Preparing stubs binary (0 ms) Preparing compiled binary (103 ms) Creating binary: libjava.base-coop.o (2719 ms) Creating shared library: libjava.base-coop.so (5812 ms) Total time: 163609 ms <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成后,我们就可以使用提前编译版本的<code>java.base</code>模块来运行Java程序了,方法与前面运行HelloWorld是一样的,用<code>-XX:AOTLibrary</code>来指定链接库位置即可,譬如: </p><pre class="line-numbers language-shell"><code class="language-shell">java -XX:AOTLibrary=java_base/libjava.base-coop.so,./libHelloWorld.so HelloWorld Hello World!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们还可以使用<code>-XX:+PrintAOT</code>参数来确认哪些方法使用了提前编译的版本,从输出信息中可以看到,如果不使用提前编译版本的<code>java.base</code>模块,就只有HelloWord的构造函数和<code>main()</code>方法是提前编译版本的</p><pre class="line-numbers language-java"><code class="language-java">$ java <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintAOT <span class="token operator">-</span>XX<span class="token operator">:</span>AOTLibrary<span class="token operator">=</span><span class="token punctuation">.</span>/libHelloWorld<span class="token punctuation">.</span>so HelloWorld      <span class="token number">11</span>    <span class="token number">1</span>     loaded    <span class="token punctuation">.</span>/libHelloWorld<span class="token punctuation">.</span>so  aot library     <span class="token number">105</span>    <span class="token number">1</span>     aot<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span>   HelloWorld<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>V     <span class="token number">105</span>    <span class="token number">2</span>     aot<span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">]</span>   HelloWorld<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V Hello World<span class="token operator">!</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如果加入<code>libjava.base-coop.so</code>,那使用到的几乎所有的标准Java SE API都是被提前编译好的,输出如下:</p><pre class="line-numbers language-shell"><code class="language-shell">java -XX:AOTLibrary=java_base/libjava.base-coop.so,./libHelloWorld.so HelloWorld Hello World!    13    1     loaded    java_base/libjava.base-coop.so  aot library         13    2     loaded    ./libHelloWorld.so  aot library [Found  [Z  in  java_base/libjava.base-coop.so] …… // 省略其他输出[Found  [J  in  java_base/libjava.base-coop.so]         31    1     aot[ 1]   java.lang.Object.()V         31    2     aot[ 1]   java.lang.Object.finalize()V …… // 省略其他输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前状态的Jaotc还有许多需要完善的地方,仍难以直接编译SpringBoot、MyBatis这些常见的第三方工具库,甚至在众多Java标准模块中,能比较顺利编译的也只有java.base模块而已。不过随着Graal编译器的逐渐成熟,相信Jaotc前途还是可期的。</p><p>此外除了Jaotc,同样有发展潜力的Substrate VM也不应被忽视。Jaotc做的提前编译属于本节开头所说的“第二条分支”,即做即时编译的缓存;而Substrate VM则是选择的“第一条分支”,做的是传统的静态提前编译。</p><h2 id="6-5、Graal"><a href="#6-5、Graal" class="headerlink" title="6.5、Graal"></a>6.5、Graal</h2><p>自JDK10起, HotSpot又加入一个全新的编译器: Graal编译器，它是HotSpot即时编译器以及提前编译器共同的最新成果。编译效果短短几年时间就追评了C2编译器。未来可期。目前,带着“实验状态”标签,需要使用开关参数<code>-xx:+UnlockExperimentalVMOptions</code>、<code>-xx:+UseJVMCICompiler</code>去激活,才可以使用。</p><h3 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h3><p>2012年,Graal编译器从Maxine虚拟机(也是一款Java虚拟机)项目中分离,成为一个独立发展的Java编译器项目,Oracle Labs希望它最终能够成为一款高编译效率、高输出质量、支持提前编译和即时编译,同时支持应用于包括HotSpot在内的不同虚拟机的编译器。<strong>由于这个编译器使用Java编写</strong>,代码清晰,又继承了许多来自HotSpot的服务端编译器的高质量优化技术,所以无论是科技企业还是高校研究院,都愿意在它上面研究和开发新编译技术。HotSpot服务端编译器的创造者Cliff Click自己就对Graal编译器十分推崇,并且公开表示再也不会用C、C++去编写虚拟机和编译器了。Twitter的Java虚拟机团队也曾公开说过C2目前犹如一潭死水, 亟待一个替代品,因为在它上面开发、改进实在太困难了。</p><p>Graal编译器在JDK 9时以Jaotc提前编译工具的形式首次加入到官方的JDK中,从JDK 10起,Graal 编译器可以替换服务端编译器,成为HotSpot分层编译中最顶层的即时编译器。这种可替换的即时编译器架构的实现,得益于HotSpot编译器接口的出现。</p><p>早期的Graal曾经同C1及C2一样,与HotSpot的协作是紧耦合的,这意味着每次编译Graal均需重新编译整个HotSpot。JDK 9时发布的JEP 243:Java虚拟机编译器接口(Java-Level JVM Compiler Interface,JVMCI)使得Graal可以从HotSpot的代码中分离出来。JVMCI主要提供如下三种功能: </p><ul><li><p>响应HotSpot的编译请求,并将该请求分发给Java实现的即时编译器。</p></li><li><p>允许编译器访问HotSpot中与即时编译相关的数据结构,包括类、字段、方法及其性能监控数据等,并提供了一组这些数据结构在Java语言层面的抽象表示。</p></li><li><p>提供HotSpot代码缓存(Code Cache)的Java端抽象表示,允许编译器部署编译完成的二进制机器码。</p></li></ul><p>综合利用上述三项功能,我们就可以把一个在HotSpot虚拟机外部的、用Java语言实现的即时编译器(不局限于Graal)集成到HotSpot中,响应HotSpot发出的最顶层的编译请求,并将编译后的二进制代码部署到HotSpot的代码缓存中。此外,单独使用上述第三项功能,又可以绕开HotSpot的即时编译系统,让该编译器直接为应用的类库编译出二进制机器码,将该编译器当作一个提前编译器去使用(如Jaotc)。</p><h3 id="构建编译调试环境"><a href="#构建编译调试环境" class="headerlink" title="构建编译调试环境"></a>构建编译调试环境</h3><p>由于Graal编译器要同时支持Graal VM下的各种子项目,如Truffle、Substrate VM、Sulong等,还要支持作为HotSpot和Maxine虚拟机的即时编译器,所以只用Maven或Gradle的话,配置管理过程会相当复杂。为了降低代码管理、依赖项管理、编译和测试等环节的复杂度,Graal团队专门用Python 2写了一个名为mx的小工具来自动化做好这些事情。我们要构建Graal的调试环境,第一步要先把构建工具mx 安装好,这非常简单,进行如下操作即可:</p><pre class="line-numbers language-shell"><code class="language-shell">$ git clone https://github.com/graalvm/mx.git $ export PATH=`pwd`/mx:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然Graal编译器是以Java代码编写的,那第二步自然是要找一个合适的JDK来编译。考虑到Graal VM项目是基于OpenJDK 8开发的,而JVMCI接口又在JDK 9以后才会提供,所以Graal团队提供了一个<strong><a href="https://github.com/graalvm/graal-jvmci-8" target="_blank" rel="noopener">带有JVMCI功能的OpenJDK 8版本</a></strong>,我们可以选择这个版本的JDK 8来进行编译。如果只关注Graal 编译器在HotSpot上的应用而不想涉及Graal VM其他方面时,可直接采用<strong>JDK 9及之后的标准Open/OracleJDK</strong>。选择好JDK版本后,设置JAV A_HOME环境变量即可,这是编译过程中唯一需要手工处理的依赖:</p><pre class="line-numbers language-shell"><code class="language-shell">export JAVA_HOME=/usr/lib/jvm/oraclejdk1.8.0_212-jvmci-20-b01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三步是获取Graal编译器代码,编译器部分的代码是与整个Graal VM放在一块的,我们把Graal VM复制下来,大约有700MB,操作如下:</p><pre class="line-numbers language-shell"><code class="language-shell">$ git clone https://github.com/graalvm/graal.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他目录中存放着Truffle、Substrate VM、Sulong等其他项目,这些在本次实战中不会涉及。进入compiler子目录,使用mx构建Graal编译器,操作如下:</p><pre class="line-numbers language-shell"><code class="language-shell">$ cd graal/compiler $ mx build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于整个构建过程需要的依赖项都可以自动处理,需要手动处理的只有OpenJDK一个,所以编译一般不会出现什么问题,大概两三分钟编译即可完成。此时其实已经可以修改、调试Graal编译器了。mx工具能够支持Eclipse、Intellij IDEA和NetBeans三种主流的Java IDE项目的创建, Graal团队中使用Eclipse占多数,支持也最好,生成eclipse配置文件如下</p><pre class="line-numbers language-shell"><code class="language-shell">$ cd graal/compiler $ mx eclipseinit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>无论使用哪种IDE,都需要把IDE配置中使用的Java堆修改到2GB或以上,才能保证Graal在IDE中的编译构建能够顺利进行,譬如Eclipse默认配置(eclipse.ini文件)下的Java堆最大为1GB,这是不够的。设置完成后,在Eclipse中选择File-&gt;Open Projects from File System,再选择Graal项目的根目录,将会导入整个Graal VM</p><p>图</p><p>如果你采用的是JDK 8,那么要记得在Eclipse中也必须将那个带有JVMCI功能的特殊JDK 8用作Eclipse里面“Java SE-1.8”的环境配置(Windows-&gt;Preferences-&gt;Java-&gt;Install JREs-&gt;Execution Environments-&gt;Java SE-1.8),此外,还需要手工将以其他版本号结尾的工程关闭。这对于采用其他版本JDK来编译的读者也是一样的。到此为止,整个编译、调试环境就已经构建完毕。</p><h3 id="JVMCI编译器接口"><a href="#JVMCI编译器接口" class="headerlink" title="JVMCI编译器接口"></a>JVMCI编译器接口</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/07-zhi-jie-nei-cun/"/>
      <url>/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/07-zhi-jie-nei-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存空间。它来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存(底层都是调用unsafe包的api)。</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li><p>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</p></li><li><p>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。</p><pre class="line-numbers language-Java"><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocateDirect(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外这里申请的直接内存也会被GC</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="在读写文件中直接内存的好处"><a href="#在读写文件中直接内存的好处" class="headerlink" title="在读写文件中直接内存的好处"></a>在读写文件中直接内存的好处</h2><p>在普通IO的情况下，使用的是JVM进程的内存，这是用户态的内存空间。读写文件，需要与磁盘交互，涉及用户态和内核态之间的切换。如果不是使用直接内存，则会发生内核态与用户态直接的内存拷贝（读一次，写一次）。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111921.png" alt="image-20200917094412411"></p><p>但是，如果使用直接内存，JVM则可以利用操作系统的<a href="https://mp.weixin.qq.com/s/8J3Hnr7PX7YBX4hbK8oAQQ" target="_blank" rel="noopener">零拷贝</a>特性减少内存复制带来的消耗。</p><h1 id="直接内存异常"><a href="#直接内存异常" class="headerlink" title="直接内存异常"></a>直接内存异常</h1><p>直接内存也可能导致<code>OutOfMemoryError:Direct Memory Buffer</code>或者<code>OutOfMemoryError:null</code>异常。由于直接内存在Java堆外，因此它的大小不会直接受限于<code>-Xmx</code>指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><p>缺点：</p><ul><li><p>分配回收成本较高</p></li><li><p>垃圾收集进行时,虚拟机虽然会对直接内存进行回收,但是直接内存却不能像新生代、老年代那样,发现空间不足了就主动通知收集器进行垃圾回收,它只能等待老年代满后Full GC出现后,“顺便”帮它清理掉内存的废弃对象。</p><p>所以如果JVM”本身申请管理的内存”没有很大消耗，反而直接内存消耗很大的时候，将直接抛出OOM。除非手动调用<code>System.gc()</code>进行Full GC，但是该方法可以通过<code>-XX:+DisableExplicitGC</code>禁用。</p></li></ul><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置，如果不指定，默认与堆的最大值<code>-Xmx</code>一致。（注意，元空间占用的内存不在这里讲的直接内存中）  </p><h1 id="内存分布图示"><a href="#内存分布图示" class="headerlink" title="内存分布图示"></a>内存分布图示</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111922.png" alt="image-20200917100817936"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/09-dui-xiang/"/>
      <url>/2020/09/17/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/09-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、对象的实例化"><a href="#一、对象的实例化" class="headerlink" title="一、对象的实例化"></a>一、对象的实例化</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><a href="file:///Users/zhonghongpeng/Library/Mobile%20Documents/iCloud~com~toketaware~ios~ithoughts/Documents/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.itmz" target="_blank" rel="noopener">思维导图</a></h2><h2 id="字节码举例"><a href="#字节码举例" class="headerlink" title="字节码举例"></a>字节码举例</h2><pre class="line-numbers language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上代码对应下列字节码，可以看到我们定义的构造方法是在字节码<code>invokespecial</code>字节码进行执行(初始化)的。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115738.png" alt="image-20200917081025938"></p><h1 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h1><h2 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a><a href="file:///Users/zhonghongpeng/Library/Mobile%20Documents/iCloud~com~toketaware~ios~ithoughts/Documents/jvm/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.itmz" target="_blank" rel="noopener">思维导图</a></h2><h1 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h1><h2 id="思维导图-2"><a href="#思维导图-2" class="headerlink" title="思维导图"></a><a href="file:///Users/zhonghongpeng/Library/Mobile%20Documents/iCloud~com~toketaware~ios~ithoughts/Documents/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.itmz" target="_blank" rel="noopener">思维导图</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/16/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/06-fang-fa-qu/"/>
      <url>/2020/09/16/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/06-fang-fa-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111755.png" alt="image-20200916164449831"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111756.png" alt="image-20200916164505074"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111757.png" alt="image-20200916164613255"></p><h1 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h1><ul><li>方法区看作是一块独立于Java堆的内存空间，在HotSpotJVM中它有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMeoryError: PermGen space</code>或者<code>java.lang.OutOfMemoryError: Metaspace</code></li><li>关闭JVM就会释放这个区域的内存</li></ul><h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111758.png" alt="image-20200916173238733"></p><h2 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h2><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111759.png" alt="image-20200916173331932"></p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称</li><li>这个类型直接父类的完整有效名（对于interface或者是<code>java.lang.Object</code>都没有父类）</li><li>这个类型的修饰符（public、abstrace、final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包含：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）</li></ul><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈和局部变量表的大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的引用</li></ul></li></ul><h3 id="运行时常量池VS常量池"><a href="#运行时常量池VS常量池" class="headerlink" title="运行时常量池VS常量池"></a>运行时常量池VS常量池</h3><p>方法区中的运行时常量池和字节码文件中的常量池是不同的。</p><h4 id="字节码文件的常量池"><a href="#字节码文件的常量池" class="headerlink" title="字节码文件的常量池"></a>字节码文件的常量池</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111800.png" alt="image-20200916180016967"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量(右值)和对类型、域和方法的<strong>符号</strong>(左值)引用。</p><h5 id="字节码文件中为什么需要常量池"><a href="#字节码文件中为什么需要常量池" class="headerlink" title="字节码文件中为什么需要常量池"></a>字节码文件中为什么需要常量池</h5><ol><li>配合构建字节码文件的自描述能力</li><li>压缩字节码文件大小（符号引用不会替换成其指向的字节码内容、使用二进制位进行描述）</li></ol><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>运行时常量池(Runtime Constant Pool)是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li><li>运行时常量池在加载类和接口到虚拟机后，就会创建。</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包含编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号引用了，已经替换为真实的直接引用。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM就会抛出OutOfMemoryError</li></ul><h5 id="运行时常量池中的”常量”"><a href="#运行时常量池中的”常量”" class="headerlink" title="运行时常量池中的”常量”"></a>运行时常量池中的”常量”</h5><p>运行时常量池之中主要存放的两大类常量：字面量和符号引用。</p><p>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，包含下面三类常量：</p><ol><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol><h5 id="补充：non-final的类变量和final修饰的类变量"><a href="#补充：non-final的类变量和final修饰的类变量" class="headerlink" title="补充：non-final的类变量和final修饰的类变量"></a>补充：non-final的类变量和final修饰的类变量</h5><ul><li>非final静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。类变量被类的所有实例共享，即使没有类实例时你也可以访问它</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111801.png" alt="image-20200916174431865"></p><ul><li>被声明为final的类变量和非final类变量初始化时机不同。。</li></ul><h1 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h1><h2 id="占用内存位置调整"><a href="#占用内存位置调整" class="headerlink" title="占用内存位置调整"></a>占用内存位置调整</h2><p>在JDK7及之前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。</p><p>本质上，方法区和永久代并不等价，仅是因为Hotspot JVM中垃圾收集器将方法区定义为永久代。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/IBM J9中不存在永久代的概念。</p><p>现在看来，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过<code>-XX:MaxpermSize</code>上限）。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111802.png" alt="image-20200916170345428"></p><p>而到了JDK8，终于完全废弃了永久代的概念，该用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111803.png" alt="image-20200916170454628"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机控制的内存中，而是使用本地内存。</p><p>永久代、元空间二者并不只是名字变了，内存结构也调整了。</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="存储内容变化"><a href="#存储内容变化" class="headerlink" title="存储内容变化"></a>存储内容变化</h2><ol><li><p>首先明确，只有HotSpot才有永久代。BEA JRockit、IBM J9等不存在永久代的概念。</p></li><li><p>Hotspot中方法区的变化：</p><table><thead><tr><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>JDK1.6及之前</td><td>有永久代（permanent generation），静态(类)变量放在永久代上</td></tr><tr><td>JDK1.7</td><td>有永久代，但已经逐步”去永久代”，字符串常量池、静态(类)变量移到在堆中，永久代其它信息不变</td></tr><tr><td>JDK1.8及之后</td><td>无永久代，类型信息、字段、方法、常量(JDK1.6运行时常量池中除字符串常量之外的其它常量)保存在本地内存的元空间，但字符串常量池、静态(类)变量仍在堆</td></tr></tbody></table></li></ol><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111804.png" alt="image-20200916183025199"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111805.png" alt="image-20200916183040354"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111806.png" alt="image-20200916183124256"></p><h2 id="关于静态-类-变量需要注意的点"><a href="#关于静态-类-变量需要注意的点" class="headerlink" title="关于静态(类)变量需要注意的点"></a>关于静态(类)变量需要注意的点</h2><p>上面提到静态变量在JDK1.6及之前都是在永久代，在7及之后才移到堆(老年代)中。以下特别说明一个情况：</p><p>加上<code>-XX:+PrintGCDetails</code>分别在JDK6、JDK7、JDK8运行下面这段代码，在程序退出之后会打印退出的时候各分代信息，发现无论是6、7还是8，始终是老年代的内存占用102400K的字节，说明这个字节数组无论是在6，7还是8都落在了堆的老年代中（应该是size太大，直接进入老年代）。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111807.png" alt="image-20200916205847835"></p><p>JDK7和8都将静态变量移到了堆，这个可以理解，但是为什么在JDK6中静态变量也是这样呢？因为目前为止无论是任何版本，对象的创建都是保存在堆中（栈上分配也没有实现对象分配，而是标量替换后进行分配），我们讲的静态常量指的是它保存的一个引用，即该数组对象的地址在JDK6中保存在永久代的，而无论在任何版本，该数组对象本身的数据内容都是存放在堆中。而7及之后则是将该静态变量放到了<code>java.lang.Class</code>对象中进行保存，该对象也是在堆中。所以现在的结构就是：</p><p>方法区类元信息——-引用——–&gt;<code>java.lang.class</code>——-包含——–&gt;静态变量——-引用——–&gt;数组对象</p><p>而6及之前的结构应该是：</p><p>方法区类元信息(包含静态变量)——-引用——–&gt;<code>java.lang.class</code></p><p>​                                    |——-引用——–&gt;数组对象</p><p>除了方法区元信息之后，其它数据都在堆区，其中方法区类元信息也是GC Root。</p><p>下面例子再次进行说明：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111808.png" alt="image-20200916203914505"></p><p>可以使用JHSDB工具分析上面带面执行过程<code>staticObj</code>、<code>instanceObj</code>、<code>localObj</code>三个静态、实例、方法局部变量涉及的内存分布。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111809.png" alt="image-20200916203843641"></p><p><code>staticObj</code>随着Test的类型信息存放在方法区，<code>instanceObj</code>随着Test的对象实例存放在Java堆，<code>localObj</code>则是存放在<code>foo()</code>方法栈帧的局部变量表中。经过工具分析得到以下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111810.png" alt="image-20200916204326241"></p><p>三个对象的数据都落在Eden区范围内（且是递增的），（所以结论：只要是对象实例必然会在Java堆中分配。）接着，找到了一个引用该<code>staticObj</code>对象的地方，是在一个<code>java.lang.Class</code>的实例里，并且<code>java.lang.Class</code>类型的对象实例，里面有一个名为<code>staticObj</code>的实例字段：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111811.png" alt="image-20200916204746680"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。<strong>JDK7及其以后版本的HotSpot虚拟机选择把静态变量与描述类型的Java语言Class对象</strong>放在一起，存储于Java堆中。</p><h2 id="永久代为什么要被元空间替代"><a href="#永久代为什么要被元空间替代" class="headerlink" title="永久代为什么要被元空间替代"></a>永久代为什么要被元空间替代</h2><ul><li><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消息了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p></li><li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li><li><p>这项改动是很有必要的，原因有：</p><ol><li><p>为永久代设置空间大小是很难确定的</p><p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111812.png" alt="image-20200916183640560"></p><p>而元空间和永久代之间最大区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p></li><li><p>对永久代进行调优是很困难的</p></li></ol></li></ul><h1 id="设置方法区大小与OOm"><a href="#设置方法区大小与OOm" class="headerlink" title="设置方法区大小与OOm"></a>设置方法区大小与OOm</h1><ul><li><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p></li><li><p>JDK7及之前：</p><ul><li><p>通过<code>-XX:PermSize=&lt;N&gt;</code>来设置永久代初始分配空间。默认值是20.75M。</p></li><li><p><code>-XX:MaxPermSize</code>来设定永久代最大可分配空间。32位及其默认是64M，64位及其默认是82M。</p></li><li><p>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError：PermGem space</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111813.png" alt="image-20200916171545341"></p></li></ul></li><li><p>JDK8及之后：</p><ul><li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</li><li>默认指依赖于平台。Windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，即没有限制。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Mataspace</li><li><code>-XX:MetaspaceSize:&lt;N&gt;</code>设置初始的元空间大小。对于一个64位的服务端JVM来说，其默认值位21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁的GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul></li></ul><h2 id="OOM例子"><a href="#OOM例子" class="headerlink" title="OOM例子"></a>OOM例子</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111814.png" alt="image-20200916172507704"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111815.png" alt="image-20200916172530703"></p><h2 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h2><ol><li>要解决OOM异常，一般的手段是首先通过内存映象分析工具对dump出来的堆转存快照进行分析，终点是确认内存中的对象是否是必要的，也就是先分清楚是不是内存泄露（Memory Leak）导致的内存溢出（Memory Overflow）。</li><li>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息，以及GC Roots引用链信息，就可以比较准确地定位出泄露代码的位置。</li><li>如果不存在内存泄露，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h1 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h1><p>《Java虚拟机规范》对方法区的约束非常宽松，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄露。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。</p><p>判定一个常量是否”废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收,也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收,这个条件除非是经过精心设计的可替换类加载器的场景,如OSGi、JSP的重加载等,否则通常是很难达成的。</li><li>该类对应的<code>java.lang.Class</code>对象(在堆中)没有在任何地方被引用,无法在任何地方通过反射访问该类的方法</li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收,这里说的仅仅是“被允许”,而并不是和对象一样,没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了<code>- Xnoclassgc</code>参数进行控制,还可以使用<code>-verbose:class</code>以及-<code>XX:+TraceClassLoading</code>、<code>-XX: +TraceClassUnLoading</code>查看类加载和卸载信息,其中-verbose:class和<code>-XX:+TraceClassLoading</code>可以在Product版的虚拟机中使用,<code>-XX:+TraceClassUnLoading</code>参数需要FastDebug版的虚拟机支持。<br>在大量使用反射、动态代理、CGLib等字节码框架,动态生成JSP以及OSGi这类频繁自定义类加载器的场景中,通常都需要Java虚拟机具备类型卸载的能力,以保证不会对方法区造成过大的内存压力。</p><h1 id="StringTable为什么要调整"><a href="#StringTable为什么要调整" class="headerlink" title="StringTable为什么要调整"></a>StringTable为什么要调整</h1><p>JDK7中将StringTable(字符串常量池)放到了堆空间中，因为永久代的回收效率很低，所以只有在Full GC的时候才会触发。而Full GC是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收频率不高。而我们开发中会有大量的字符串被创建，将其移到堆中划分老年代是为了提高回收频率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/16/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/05-dui/"/>
      <url>/2020/09/16/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/05-dui/</url>
      
        <content type="html"><![CDATA[<h1 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111711.png" alt="image-20200916075349717"></p><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。<ul><li>堆内存的大小是可以调节的</li></ul></li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，<strong>在这里还可以划分线程私有的缓冲区</strong>（Thread Local Allocation Buffer，TLAB）</li><li>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应该在运行时分配在堆上。<ul><li>实际上，是”几乎”所有的对象实例都在这里分配内存</li></ul></li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</li><li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ul><h2 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h2><p>现代垃圾收集器大部分都基于分代收集理论设计：</p><p>堆和方法区是一组从功能上定义的内存区域名称；分代命名是从垃圾回收的角度进行内存区域划分和命名，方便垃圾收集器对不同分代区域进行特定的针对性内存分配及回收逻辑。</p><ul><li><p>Java 7及之前堆内存逻辑上分为两部分：新生代、老年代</p><ul><li>Young(New) Generation Space<ul><li>Eden、Survivor(from、to)</li></ul></li><li>Tenure(Old) generation space</li></ul></li><li><p>方法区被划为永久代（在Java虚拟机规范中没有定义方法区的实际位置，在7及之前它和堆共用一块内存，它所占用的内存空间称为非堆内存）：Permanent Space</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111712.png" alt="image-20200916082710521"></p></li><li><p>Java8及之后堆内存逻辑上分为三部分：新生代、老年代</p><ul><li>Young(New) Generation Space<ul><li>Eden、Survivor</li></ul></li><li>Tenure(Old) generation space</li></ul></li><li><p>永久代移除，使用元空间替代(在8之后出现，不占用堆内存，使用直接内存/又叫堆外内存，很蹩脚的命名)：Meta Spoce</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111713.png" alt="image-20200916082818919"></p></li></ul><h1 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h1><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项<code>-Xmx</code>和<code>-Xms</code>来进行设置</p><ul><li><code>-Xms</code>用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code>则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li></ul><p>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，将会抛出<code>OutOfMemoryError</code>异常</p><p>通常会将<code>-Xms</code>和<code>-Xmx</code>两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配计算堆区的大小，从而提高性能。</p><p>默认情况下：</p><ul><li>初始内存大小：物理电脑内存大小/64</li><li>最大内存大小：物理电脑内存大小/4</li></ul><p>查看堆内存情况：</p><ul><li><code>jps</code>查看Java进程，<code>jstat -gc 进程id</code>查看内存使用情况和GC次数等</li><li><code>-XX:+PrintGCDetails</code></li></ul><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111714.png" alt="image-20200916085807115"></p><h1 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h1><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做form区、to区）</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111715.png" alt="image-20200916090311825"></p><h3 id="相关参数设置"><a href="#相关参数设置" class="headerlink" title="相关参数设置"></a>相关参数设置</h3><ul><li><p>配置新生代与老年代在堆结构的占比</p><ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>可以根据需要进行修改，一般开发中不会修改</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111716.png" alt="image-20200916090614423"></p></li><li><p>在Hotspot中，Eden空间和另外两个Survivor空间空间缺省所占的比例是8:1:1。可以通过以下参数进行设置：</p><ul><li>设置新生代中Eden区与Survivor区的比例：<code>-XX:SurvivorRatio=8</code>。默认是8（from和to平分Survivor区域）</li></ul></li><li><p><code>-XX:-UseAdaptiveSizePolicy</code>：关闭自适应的内存分配策略（否则新生代中分区可能和SurvivorRatio参数是不匹配的）</p></li></ul><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了（IBM公司的专门研究表明，新生代中的80%的对象都是朝生夕死的）。</p><ul><li>可以使用选项<code>-Xmn</code>设置新生代最大内存大小，这个参数一般使用默认值即可。</li></ul><h1 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h1><h2 id="对象分配过程：概述"><a href="#对象分配过程：概述" class="headerlink" title="对象分配过程：概述"></a>对象分配过程：概述</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生碎片。</p><ol><li>new的对象先放在Eden区。此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden区和from区进行垃圾回收（Minor GC/YGC），将Eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden区</li><li>然后将Eden中的剩余对象移动到幸存者to区域（默认是0区），然后切换from和to</li><li>如果再次触发垃圾回收，同样对Eden和from区域进行回收，此时from区域为0区，to区域切换为1区，本次垃圾回收的幸存者将会移动到幸存者0区的</li><li>就这样经历不断的垃圾回收，幸存者一直在新生代的from区和to区之间移动。如果经过<code>-XX:MaxTenuringThreshold=&lt;N&gt;</code>设置的次数之后(默认15)，该对象还没有被回收，该对象将被移到tenure老年代。</li><li>另外如果MinorGC后新建对象还是过大或者GC清理对象过少，剩余对象过多，to区无法承载新建对象，则该对象直接进入老年区（如果老年区够大）。</li><li>在老年代，相当悠闲。当老年代内存不足时，再次触发GC：Major GC，进行老年代的内存清理。</li><li>若老年代执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常：<code>java.lang.OutOfMemoryError: Java heap space</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111717.png" alt="image-20200916093717986"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>针对幸存者s0和s1区，复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年区收集，几乎不在永久区/元空间收集</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111718.png" alt="image-20200916094118286"></p><h2 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h2><ul><li>JDK命令行：jstat、jinfo、jmap、jps、jstack等</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>VisualVM</li><li>Jprofiler</li><li>Java Flight Recorder（在JMC里面）</li><li>GCViewer</li><li>GC Easy</li></ul><h1 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h1><p>JVM在进行GC时，并非每次都对三个内存区域(新生代、老年代、方法区)一起回收的，大部分时候回收的都是指新生代。</p><p>针对HotSpot VM的实现，它的垃圾收集按照回收区域又分为两大种类：一种是部分收集（Partial GC），另一种是整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有CMS收集器会有单独收集老年代的行为</li><li>注意，很多时候Major GC和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收（根据使用的垃圾收集器区分）</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1收集器会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li></ul><h2 id="最简单的分代式GC策略的触发条件"><a href="#最简单的分代式GC策略的触发条件" class="headerlink" title="最简单的分代式GC策略的触发条件"></a>最简单的分代式GC策略的触发条件</h2><ul><li><p>年轻代GC（Minor GC）触发机制：</p><ul><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是Eden+from。</li><li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li><li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul></li><li><p>老年代GC（Major GC/Full GC）触发机制：</p><ul><li>指发生在老年代的GC，对象从老年代消失时，我们说”Major GC”或者”Full GC”发生了。</li><li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。<ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，会触发Major GC</li></ul></li><li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li><li>如果Major GC后，内存还不足，就报OOM了。</li></ul></li><li><p>Full GC触发机制：</p><p>触发Full GC执行的情况有如下五种：</p><ol><li>调用<code>System.gc()</code>时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、suvivor space0（From Sapce）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol></li></ul><ol start="6"><li><p>CMS 因为资源不足无法进行多线程回收发生 Concurrent mode failed</p><p>说明：Full GC是开发或调优中尽量要避免的。这样暂停时间会短一些。</p></li></ol><h1 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h1><p>为什么需要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有Eden、两块大小相同的Survivor（又称为from/to、s0/s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111719.png" alt="image-20200916105218715"></p><p>分代的最大作用就是优化GC性能，对对象进行提前打标，在垃圾收集的时候就可以针对不同标识进行相关收集动作，防止在收集阶段才进行全对象的打标，会导致GC时间过长。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111720.png" alt="image-20200916105519846"></p><h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><p>如果对象在Eden出生并经过第一次MinorGC后依然存货，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p><p>对象晋升老年代的年龄阈值，可以通过选项<code>-XX:MaxTenuringThresold</code>来设置。</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li><p>优先分配到Eden</p></li><li><p>大于<code>-XX:PretenureSizeThreshold</code>的大对象直接分配到老年代</p><ul><li>尽量避免程序中出现过多的大对象，尤其是小于该阈值的大对象，因为它会先放在新生代，新生代的空间较小，很容易引发GC</li></ul></li><li><p>长期存活的对象分配到老年代</p><ul><li>每在年轻代经过一次Minor GC，对象年龄+1，年龄超过<code>-XX: MaxTenuringThreshold</code>的对象为长期存活</li></ul></li><li><p>动态对象年龄判断</p><ul><li>如果Survivor区中<strong>相同年龄的所有对象大小的总和</strong>大于<strong>Survivor空间的一半</strong>，<strong>年龄大于或等于该年龄的对象</strong>可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄</li></ul></li><li><p>空间分配担保：<code>-XX:HandlePromotionFailure</code></p><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>如果大于，则此次Minor GC是安全的。（所有新生代对象都不能被收集且年龄满足晋升到老年代的极端情况下）</li><li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允许担保小范围GC带来的风险（例如MinorGC之后可能老年代内存还是不足以存放新生代幸存下来且要晋升到老年代的对象，此时还是要进行FullGC。所以此时相较于一开始就进行FullGC多了一次MinorGC）。<ul><li>如果该值为true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小<ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的，因为参考的是一个平均值</li><li>如果小于，则改为进行一次Full GC</li></ul></li><li>如果该值为false，则改为进行一次Full GC</li></ul></li></ul><p>在JDK6 Update24之后，<code>HandlePromotionFailure</code>参数不会再影响到虚拟机的空间分配担保策略，虽然源码中还定义了该参数，但是代码中已经不会再使用它了。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将会进行Full GC。</p></li></ul><h1 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h1><p>为什么有TLAB（Thread Local Allocation Buffer）？</p><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>什么是TLAB？</p><ul><li><p>TLAB全称<code>ThreadLocalAllocBuffer</code>，是线程的一块私有内存，如果设置了虚拟机参数 <code>-XX:UseTLAB</code>，<strong>在线程初始化时</strong>，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用，这个申请动作还是需要原子操作的。</p><p>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，均摊对GC堆（eden区）里共享的分配指针做更新而带来的同步开销，提升内存分配的吞吐量，因此可以将这种内存分配方式称之为快速分配策略。  </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111721.png" alt="image-20200916113105504"></p><p>在TLAB中分配内存直接通过指针碰撞方式（移动指针）进行分配。</p><p>TLAB的再说明：</p><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</li><li>在程序中，开发人员可以通过选项<code>-XX:UseTLAB</code>设置是否开启TLAB空间</li><li>默认情况下，TLAB空间的内存非常小（所以线程创建的时候Eden中的TLAB空间如果用完了，就不会给这个线程初始化TLAB），仅占有整个Eden空间的1%，当然我们可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置TLAB空间所占用Eden空间的百分比大小。</li><li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性到Eden空间中再申请内存。</li></ul><h1 id="小结堆空间的参数设置"><a href="#小结堆空间的参数设置" class="headerlink" title="小结堆空间的参数设置"></a>小结堆空间的参数设置</h1><pre><code>打印所有的参数默认初始值-XX:+PrintFlagsInitial打印所有的参数的实际值-XX:+PrintFlagsFinal# 在JVM运行期间查看设置参数步骤：# 1. jps：查看当前运行中的进程id# 2. jinfo -flag SurvivorRatio 进程id：查看具体JVM进程的指定参数值初始化堆空间内存（默认为物理内存的1/64）-Xms128m最大堆空间内存（默认为物理内存的1/4）-Xmx128m设置新生代大小（初始值及最大值）-Xmn128m配置新生代与老年代在堆结构的占比-XX:NewRatio=3设置新生代中Eden和S0/S1空间的比例-XX:SurvivorRatio=4设置新生代垃圾的最大年龄-XX:MaxTenuringThreshold=15输出详细的GC处理日志-XX:+PrintGCDetails打印GC简要信息-XX:+PrintGC、-verbose:gc设置是否空间分配担保-XX:HandlePromotionFailure</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/15/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/04-ben-di-fang-fa-jie-kou-ji-ben-di-fang-fa-zhan/"/>
      <url>/2020/09/15/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/04-ben-di-fang-fa-jie-kou-ji-ben-di-fang-fa-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h1><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告诉C++编译器去调用一个C的函数。</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111656.png" alt="image-20200915220446930"></p><p>标识符native可以与所有其它的java标识符连用，但是abstract除外。</p><h1 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h1><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li><p>与Java环境外交互</p><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想象Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p></li><li><p>与操作系统的交互</p><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用这些本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p></li><li><p>Sun’s Java</p><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类<code>Java.lang.Thread</code>的<code>setPriority()</code>方法是用Java实现的，但是它实现调用的是该类里的本地方法<code>setPriority0()</code>。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1></li></ul><p>目前该方法使用得越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信发达，比如可以使用Socket通信，也可以使用Web Service等等。</p><h1 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h1><ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul></li><li>本地方法是使用C语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111657.png" alt="image-20200915224410094"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/15/jvm/source/bian-yi-diao-shi-jdk9/"/>
      <url>/2020/09/15/jvm/source/bian-yi-diao-shi-jdk9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/11/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/03-xu-ni-ji-zhan-fang-fa-zhan/"/>
      <url>/2020/09/11/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/03-xu-ni-ji-zhan-fang-fa-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h1><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>栈是运行时的单位(线程绑定、方法相关)，而堆是存储的单位。即，栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111529.png" alt="image-20200911114147108"></p><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul><li><p>Java虚拟机栈(Java virtual Machine Stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。是线程私有的。</p></li><li><p>生命周期和线程一致</p></li><li><p>主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。</p></li></ul><blockquote><p>这里有个疑问，JVM的用户方法是否对应到native中是否是一对一的方法，如果不是，用户方法的栈帧就应该是JVM自己实现的一个数据结构？</p></blockquote><h3 id="栈的特点-优点"><a href="#栈的特点-优点" class="headerlink" title="栈的特点(优点)"></a>栈的特点(优点)</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着压栈</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题</p><h3 id="开发中遇到的异常有哪些？"><a href="#开发中遇到的异常有哪些？" class="headerlink" title="开发中遇到的异常有哪些？"></a>开发中遇到的异常有哪些？</h3><p>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的：</p><ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将抛出一个StackOverflowError异常。<ul><li>我们可以使用参数<code>-Xss</code>选项来设置线程的栈容量，栈的容量直接决定了函数调用的最大可达深度。</li></ul></li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程的时候没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutofMemoryError异常。</li></ul><h1 id="栈的存储单位-栈帧"><a href="#栈的存储单位-栈帧" class="headerlink" title="栈的存储单位-栈帧"></a>栈的存储单位-栈帧</h1><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在。</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul><h3 id="栈执行原理"><a href="#栈执行原理" class="headerlink" title="栈执行原理"></a>栈执行原理</h3><ul><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循”先进后出”/“后进先出”原则。</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）。</strong></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其它方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li><li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p></li><li><p>如果当前方法调用了其它方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p></li><li><p>Java方法会有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111530.png" alt="image-20200911145920934"></p><h3 id="1、局部变量表-Local-Variables"><a href="#1、局部变量表-Local-Variables" class="headerlink" title="1、局部变量表(Local Variables)"></a>1、局部变量表(Local Variables)</h3><ul><li><p>局部变量表也被称之为局部变量数组或本地变量表。</p></li><li><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型在编译期即可确定，包括各类基本数据类型、对象引用(reference)，以及returnAddress类型。</p></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p></li><li><p>局部变量表<strong>所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p></li><li><p>局部变量表，最基本的存储单元是slot（变量槽）</p></li><li><p>在局部变量表里，32位以内的类型只占用一个slot（boolean、byte、char、short、int、float、reference和returnAddress），64位的类型(long和double)占用两个slot。</p><ul><li>byte、short、char在存储前被转换成int，boolean也被转换成int，0表示false，非0表示true</li></ul></li><li><p>long和double则占据两个slot</p><blockquote><ul><li><p>reference类型在不同虚拟机、不同机器上的长度可能不一样，有的32位有的64位</p></li><li><p>returnAddress类型目前已经很少见了,它是为字节码指令jsr、jsr_w和ret服务的,指向了一条字节码指令的地址,某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转,但现在也已经全部改为采用异常表来代替了</p></li></ul></blockquote></li><li><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p></li><li><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量都会<strong>按照顺序被复制</strong>到局部变量表的每一个slot上。</p></li><li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p></li><li><p>如果当前帧时由构造方法或者实例方法创建的（<strong>非静态方法</strong>），那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111531.png" alt="image-20200915152023282"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111532.png" alt="image-20200915153851804"></p></li><li><p>栈帧中的局部变量表中的槽位时可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111533.png" alt="image-20200915152856343"></p><p>但是可能在垃圾回收方面会带来一些问题，如果失效作用域内的变量槽没有再次被赋值，那这个槽位就会一直持有对应的数据对象的引用，无法被GC；除非经过了JIT编译器的优化，JIT编译器会对这种情况进行优化，如果发现该变量没有发生逃逸且所属作用域已经失效，即判为引用失效，可以进行回收。</p></li><li><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p></li><li><p>成员变量：在使用前，都经历过默认初始化赋值</p><ul><li>类变量：linking的prepare阶段给类变量默认赋值；在initial阶段将程序员定义的值进行赋值</li><li>局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用，编译错误</li></ul></li><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行的时候，虚拟机使用局部变量表完成方法的传递。</p></li><li><p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p></li></ul><h3 id="2、操作数栈-Operand-Stack"><a href="#2、操作数栈-Operand-Stack" class="headerlink" title="2、操作数栈(Operand Stack)"></a>2、操作数栈(Operand Stack)</h3><ul><li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack)。</p></li><li><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)。</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li><li>比如：执行复制、交换、求和等操作。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111534.png" alt="image-20200915155210392"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111535.png" alt="image-20200915155315502"></p></li><li><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量(本地变量表中的变量)临时的存储空间。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区(从本地变量表加载数据到操作数栈、对栈顶数据进行计算、把计算结果写回本地变量表并弹栈)，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型（8种基本数据类型和引用类型）</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，我们说Java虚拟机的解释引擎时基于栈的执行引擎，其中的栈指的就是操作数栈。</p></li></ul><h4 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111536.png" alt="image-20200915160522240"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111537.png" alt="image-20200915160613692"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111538.png" alt="image-20200915160713714"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111539.png" alt="image-20200915160758187"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111540.png" alt="image-20200915160836515"></p><h4 id="栈顶缓存技术-ToS，Top-of-Stack-Caching"><a href="#栈顶缓存技术-ToS，Top-of-Stack-Caching" class="headerlink" title="栈顶缓存技术(ToS，Top-of-Stack Caching)"></a>栈顶缓存技术(ToS，Top-of-Stack Caching)</h4><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数。</p><p>由于操作数时存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们<strong>提出了（仅是提出?）</strong>栈顶缓存(ToS，Top-of-Stack Caching)计数，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><h3 id="3、动态链接-Dynamic-Linking"><a href="#3、动态链接-Dynamic-Linking" class="headerlink" title="3、动态链接(Dynamic Linking)"></a>3、动态链接(Dynamic Linking)</h3><p>指向运行时常量池的方法引用。</p><ul><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。<strong>Class文件</strong>的常量池中存有大量的符号引用,字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。<ul><li>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用,这种转化被称为静态解析。</li><li>另外一部分将在每一次运行期间都转化为直接引用,这部分就称为动态连接。</li></ul></li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池区中，在后续编译阶段会进行内存分配将符号引用替换为真实的直接引用，保存在运行时常量池，而在C/C++中，方法也是可以作为一个对象进行取址从而进行动态地传递和调用的，所以所有的方法符号引用也会被转换为直接内存引用保存在常量池中，此后在进行相关方法调用的时候，会根据编译期得到的信息判断它调用了哪些方法，从而将相关方法的直接引用也保存到其栈帧中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111541.png" alt="image-20200915163545120"></p><h3 id="4、方法返回地址-Return-Address"><a href="#4、方法返回地址-Return-Address" class="headerlink" title="4、方法返回地址(Return Address)"></a>4、方法返回地址(Return Address)</h3><ul><li><p>一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p><ul><li>方法正常退出时，调用者的pc计数器的值都作为返回地址，即调用该方法的指令的下一条指令的地址。所以这里的意思是发生方法调用的时候，调用方的PC计数器的值由被调用方进行保存，保存的位置就是当前被调用方栈帧中的”方法返回地址”内存区域，在弹出栈帧的时候重新取出该值调整后设置到PC计数器。（同时如果方法有返回值就压入到调用方的操作数栈中）</li><li>而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li></ul></li><li><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li><p>执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者，简称正常完成出口。</p><ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short、int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li></ul></li><li><p>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表(根据try catch代码块构建)中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111542.png" alt="image-20200915182531902"></p><p>上述描述了一个异常表(通过classlib或者javap都可以查看)，表示在4到16、19到21直接的字节码指令遇到任何(any)类型的异常都跳转到(goto)19字节码指令。</p></li></ol></li></ul><p>本质上，方法退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值。</p><h3 id="5、一些附加信息"><a href="#5、一些附加信息" class="headerlink" title="5、一些附加信息"></a>5、一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p><p>栈的相关面试题</p><h1 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h1><ul><li><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时时不可变的。这样的方法称为非虚方法。</p><p>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</p></li><li><p>其它方法称为虚方法。</p></li></ul><p>虚拟机中提供了以下几条方法调用指令：</p><ul><li>普通调用指令：<ol><li>invokestatic:：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有方法、父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法，在运行时再确定一个实现该接口的对象</li></ol></li><li>动态调用指令：<ol><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol></li></ul><p>前面4 条调用指令,分派逻辑都固化在Java虚拟机内部,而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</p><p>只要能被invokestatic和invokespecial指令调用的方法,都可以在解析阶段中确定唯一的调用版本, Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种,<strong>再加上被final 修饰的方法</strong>(尽管它使用invokevirtual指令调用),这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。<strong>这些方法统称为“非虚方法”(Non-Virtual Method),</strong>与之相反,其他方法就被称为“虚方法”(Virtual Method)。</p><h1 id="方法的调用：链接与绑定维度"><a href="#方法的调用：链接与绑定维度" class="headerlink" title="方法的调用：链接与绑定维度"></a>方法的调用：链接与绑定维度</h1><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p><ul><li>静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为”静态链接”。</li><li>动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为”动态链接”</li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li>早期绑定：早期绑定就是被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是属于哪个class，因此也就可以使用静态链接的方式将符号引用直接转换为符号引用。<ul><li>例如在某个方法中对某个class的构造函数的调用，这个就是可以在编译期可以确定它指的就是某个具体class的某个构造函数，此时在编译该方法所属class的时候可以直接在其内存区域保存该构造函数转换后的直接引用即可。</li><li>另外<code>this.method()</code>和<code>super.method</code>的调用都是可以明确确定具体要调用的方法的。</li><li><code>final</code>方法表示不可被重写，也是可以在早期绑定的。</li><li>其它参考下面虚方法与非虚方法介绍</li></ul></li><li>晚期绑定：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型(class)绑定相关的方法，这种绑定方式也就被称之为晚期绑定(例如方法中调用的其它非final普通方法的引用绑定)。<ul><li>对于其它方法的调用都是动态绑定，因为Java是面向对象的，具有多态性，即使在调用某个方法的时候，该方法的所属(declared)类是没有子类的，但是Java的字节码是可以动态注入的，所以体现了final关键字的作用。故不能在调用普通方法的class的编译期就将该方法的符号引用替换为具体的直接引用，而是在运行期(创建栈帧)的时候根据传入的实际类型(该普通方法的所属class对象地址)获取到对应的方法引用进行绑定。</li></ul></li></ul><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数(C++中则需要使用关键字virtual来显式定义)。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h1 id="方法的调用：解析与分派维度"><a href="#方法的调用：解析与分派维度" class="headerlink" title="方法的调用：解析与分派维度"></a>方法的调用：解析与分派维度</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用,在类加载的解析阶段,会将其中的一部分符号引用转化为直接引用,这种解析能够成立的前提是:<strong>方法在程序真正运行之前就有一个可确定的调用版本,并且这个方法的调用版本在运行期是不可改变的</strong>。换句话说,调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析(Resolution)。</p><p><strong>所有非虚方法都会在类加载的时候直接解析。</strong></p><p>解析调用一定是个静态的过程,在编译期间就完全确定,在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用,不必延迟到运行期再去完成。而另一种主要的方法调用形式:分派(Dispatch)调用则要复杂许多,它可能是静态的也可能是动态的,按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p><h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><h3 id="静态分派与重载"><a href="#静态分派与重载" class="headerlink" title="静态分派与重载"></a>静态分派与重载</h3><p>所有<strong>依赖静态类型来决定方法执行版本</strong>的分派动作,都称为静态分派。静态分派的最典型应用表现就是方法重载。静态分派发生在编译阶段,因此确定静态分派的动作实际上不是由虚拟机来执行的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 方法静态分派演示 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticDispatch</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Human guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,guy!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Man guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,gentleman!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Woman guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello,lady!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Human man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Human woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StaticDispatch sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果：</span><span class="token comment" spellcheck="true">//hello,guy!</span><span class="token comment" spellcheck="true">//hello,guy!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中的“Human”称为变量的“静态类型”(Static Type),或者叫“外观类型”(Apparent Type),后面的“Man”则被称为变量的“实际类型”(Actual Type)或者叫“运行时类型”(Runtime Type)。静态类型和实际类型在程序中都可能会发生变化,区别是：</p><ul><li><p>静态类型的变化仅仅在使用时发生,变量本身的静态类型不会被改变,并且最终的静态类型是在编译期可知的;</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 强制转换使静态类型变化，但是依旧是编译期可知</span>sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Man<span class="token punctuation">)</span> human<span class="token punctuation">)</span> sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Woman<span class="token punctuation">)</span> human<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>而实际类型变化的结果在运行期才可确定,编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 实际类型变化</span>Human human <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="重载方法匹配优先级"><a href="#重载方法匹配优先级" class="headerlink" title="重载方法匹配优先级"></a>重载方法匹配优先级</h4><p>字面量就没有显式的静态类型,它的静态类型只能通过语言、语法的规则去理解和推断。例如下面代码中的’a’。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/22 09:10 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overload</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello int"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">long</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello long"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Character arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Character"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello char"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello char ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>Serializable arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello Serializable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的’a’会按照以下顺序通过本身的类型或者安全地转型之后得到一个静态类型结果进行匹配。但不会匹配到byte和short类型的重载,因为char到byte或short的转型是不安全的。(可以通过一行行地注释代码得到验证)</p><ul><li><p>char：首先对自身的类型作为静态类型进行匹配，如果没有匹配到就往下走</p></li><li><p>int&gt;long&gt;float&gt;double：按照从左到右地优先级进行安全的宽化转型之后进行匹配，如果没有匹配到就往下走</p></li><li><p>Character：寻找装箱类型，如果还是没有就往下走</p></li><li><p>Serializable：寻找装箱类型实现的接口（Character还实现了一个Comparable接口，如果同时出现这两个重载方法，javac编译期将无法确定是哪一个，将无法编译通过，此时必须进行手动强转入参’a’为其中的一个接口类型）</p></li><li><p>Object：所有接口到找不到就寻找父类，按照继承关系从下到上一层层找，直到Object</p></li><li><p>char …：最后匹配多参类型</p></li></ul><blockquote><p>注：赋值为null的时候，只有装箱、接口、父类重载可以匹配。</p></blockquote><h3 id="动态分派与重写"><a href="#动态分派与重写" class="headerlink" title="动态分派与重写"></a>动态分派与重写</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 方法动态分派演示 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>        <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"man say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"woman say hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Human man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Human woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果</span><span class="token comment" spellcheck="true">//man say hello</span><span class="token comment" spellcheck="true">//woman say hello</span><span class="token comment" spellcheck="true">//woman say hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是字节码指令，0到15步分别new了Man和Woman对象并存储到了本地变量表的1和2位置，16到21分别加载对应的对象引用到操作数栈顶，然后调用invokevirtual指令取操作数栈顶引用进行虚方法调用：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111543.png" alt="image-20200922092619242"></p><p>invokevirtual指令的运行时解析过程大致分为以下几步: </p><ol><li><p>找到操作数栈顶的第一个元素所指向的对象的实际类型,记作C。</p></li><li><p>如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验,如果通过则返回这个方法的直接引用,查找过程结束;不通过则返回<code>java.lang.IllegalAccessError</code>异常。</p></li><li><p>否则,按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p></li><li><p>如果始终没有找到合适的方法,则抛出<code>java.lang.AbstractMethodError</code>异常。</p><blockquote><p>优化：由于在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能印象到执行效率。因此，为了提高性能，JVM采用在class对象的内存区域中建立一个<strong>虚方法表(virtual method table)</strong>(非虚方法不会出现在表中)来实现，使用索引表来代替查找，借助数组利用到CPU的缓存已经减少寻址次数。</p><p>该虚方法表中存放着<strong>当前class的所有方法引用</strong>，如果有重写了父类的方法，则保存的是重写的方法引用；如果有未重写父类的方法，则保存的是父方法的引用。</p><p>虚方法表会在类加载的链接(第三阶段-解析)阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p></blockquote></li></ol><p><strong>正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型</strong>,所以两次调用中的invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了,还会根据方法接收者的实际类型来选择方法版本,这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h4 id="方法动态分派以及继承体系下同名字段的问题"><a href="#方法动态分派以及继承体系下同名字段的问题" class="headerlink" title="方法动态分派以及继承体系下同名字段的问题"></a>方法动态分派以及继承体系下同名字段的问题</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 字段不参与多态 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldHasNoPolymorphic</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            money <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am Father, i have $"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            money <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am Son,  i have $"</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Father gay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This gay has $"</span> <span class="token operator">+</span> gay<span class="token punctuation">.</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span><span class="token comment" spellcheck="true">//I am Son,  i have $0</span><span class="token comment" spellcheck="true">//I am Son,  i have $4</span><span class="token comment" spellcheck="true">//This gay has $2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两句输出”I am Son”，说明<code>showMeTheMoney()</code>方法都是调用到了Son的方法，此时方法栈中本地变量表第一个槽位压入的就是Son对象的引用，而第一句接着输出”i have $0”说明在<code>Father()</code>构造函数中money的赋值动作是赋值到了Father对象，因为此时<code>Son#showMeTheMoney()</code>中<code>money</code>(即<code>this.money</code>)得到的值是0，因为<code>Son#money</code>还没有初始化。</p><p>这就奇怪了，对于<code>showMeTheMoney()</code>方法能调用到子类的方法这个还好理解，只能说在子类构造函数中对父类构造函数调用时，父类构造函数中栈帧的本地变量表压入的this是子类对象引用。但是为什么对于<code>money</code>的访问(即对字段的访问)又是访问到父类的呢？下面是父类<code>&lt;init&gt;</code>方法的字节码，可以看到在<code>putfield</code>和<code>invokevirtual</code>之前都有一个<code>aload_0</code>指令加载this到操作数栈的，难道<code>putfield</code>之类对于字段访问的指令的相关<code>aload_0</code>都是无意义的？关于这个有待后面研究了。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111544.png" alt="image-20200922093825364"></p><h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><p><strong>方法的接收者(invokevirtual或者invokeinterface之前通过aload_0加载到的对象引用)</strong>与<strong>方法的参数</strong>统称为方法的宗量,这个定义最早应该来源于著名的《Java与模式》一书。根据分派基于多少种宗量,可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择,多分派则是根据多于一个宗量对目标方法进行选择。</p><p>Java的<strong>静态分派是在编译阶段，根据方法所属的类的静态类型以及方法参数列表中的静态类型进行方法分派</strong>，涉及两个宗量，所以属于多分派。</p><p>在运行阶段中的动态分派过程，执行到<code>invokevirtual</code>指令的时候，<strong>此时虚拟机只关心方法所属的类的实际类型</strong>，所以只有一个宗量作为选择依据，所以属于单分派。</p><p>综上，称目前Java语言是一门静态多分派、动态单分派语言。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>可以认为解析调用和分派调用是对立的，一个方法只能是其中的一种调用方式。</strong></p><p><strong>静态分派和动态分派是合作关系，它们是分派调用的两个阶段，来共同确定最终要调用的方法是哪一个。</strong></p><h1 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h1><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>何谓动态类型语言<a href="注意,动态类型语言与动态语言、弱类型语言并不是一个概念,需要区别对待。">^1</a>?动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的,满足这个特征的语言有很多,常用的包括:APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl,等等。那相对地,在编译期就进行类型检查过程的语言,譬如C++和Java等就是最常用的静态类型语言。</p><p>对于Java 来说，下面的代码合法性很明显。对于代码片段2正是说明了Java语言会在编译期做类型检查，导致该段代码编译不通过</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//片段1：不合法</span>PrintStream obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//片段2：合法</span>PrintStream obj <span class="token operator">=</span> System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在ECMAScript(JavaScript)中情况则不一样,无论obj具体是何种类型,无论其继承关系如何,只要这种类型的方法定义中确实包含有println(String)方法,能够找到相同签名的方法,调用便可成功。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//片段2：合法</span><span class="token keyword">var</span> obj <span class="token operator">=</span> System<span class="token punctuation">.</span>out<span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>产生这种差别产生的根本原因是Java语言在编译期间却已将println(String)方法完整的符号引用(本例中为一项CONSTANT_InterfaceMethodref_info常量)生成出来,并作为方法调用指令的参数存储到Class文件中,例如下面这个样子: </p><pre class="line-numbers language-java"><code class="language-java">invokevirtual #<span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>#4</code>表示字节码常量池中的第4项常量，这个常量必定是一个”CONSTANT_InterfaceMethodref_info”方法符号引用，这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息,通过这个符号引用,Java虚拟机就可以翻译出该方法的直接引用。</p><p>而ECMAScript等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型,变量obj的值才具有类型,所以编译器在编译时最多只能确定方法名称、参数、返回值这些信息,而不会去确定方法所在的具体类型(即方法接收者不固定)。“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</p><p>它们都有自己的优点,选择哪种语言是需要权衡的事情。静态类型语言能够在编译期确定变量类型,最显著的好处是编译器可以提供全面严谨的类型检查,这样与数据类型相关的潜在问题就能在编码时被及时发现,利于稳定性及让项目容易达到更大的规模。而动态类型语言在运行期才确定类型,这可以为开发人员提供极大的灵活性,某些在静态类型语言中要花大量臃肿代码来实现的功能,由动态类型语言去做可能会很清晰简洁,清晰简洁通常也就意味着开发效率的提升。</p><h2 id="Java与动态类型"><a href="#Java与动态类型" class="headerlink" title="Java与动态类型"></a>Java与动态类型</h2><p>Java虚拟机层面对动态类型语言的支持一直都还有所欠缺,主要表现在方法调用方面:JDK 7以前的字节码指令集中,4条方法调用指令(invokevirtual、invokespecial、invokestatic、invokeinterface)的第一个参数都是<strong>被调用的方法的符号引用</strong>(CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量), <strong>方法的符号引用在编译时产生</strong>, <strong>而动态类型语言是在运行期才确定的</strong>。</p><h2 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h2><p>JDK 7时新加入的java.lang.invoke包是JSR 292的一个重要组成部分,这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外,提供一种新的动态确定目标方法的机制,称为“方法句柄”(Method Handle)。与C/C++中的函数指针(Function Pointer),或者C#里面的委派(Delegate)，如：</p><pre class="line-numbers language-c++"><code class="language-c++">void sort(int list[], const int size, int (*compare)(int, int))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但在Java语言中做不到这一点,没有办法单独把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口,以实现这个接口的对象作为参数,例如Java类库中的<code>Collections::sort()</code>方法就是这样定义的:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Comparator c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过,在拥有方法句柄之后,Java语言也可以拥有类似于函数指针或者委托的方法别名这样的工具了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>MethodHandle<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>MethodHandles<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>MethodType<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * JSR 292 MethodHandle基础用法演示 * @author zzm */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodHandleTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        Object obj <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> System<span class="token punctuation">.</span>out <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 无论obj最终是哪个实现类,下面这句都能正确调用到println方法。</span>        <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">"icyfenix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> MethodHandle <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>Object reveiver<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// MethodType:代表“方法类型”,包含了方法的返回值(methodType()的第一个参数)和 具体参数(methodType()第二个及以后的参数)。</span>        MethodType mt <span class="token operator">=</span> MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// lookup()方法来自于MethodHandles.lookup,这句的作用是在指定类中查找符合给定的方法名称、方法类型,并且符合调用权限的方法句柄。</span>        <span class="token comment" spellcheck="true">// 因为这里调用的是一个虚方法,按照Java语言的规则,方法第一个参数是隐式的,代表该方法的接收者,也即this指向的对象,这个参数以前是放在参数列表中进行传递,现在提供了bindTo()方法来完成这件事情。</span>        <span class="token keyword">return</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>reveiver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"println"</span><span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>reveiver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中无论obj是何种类型(临时定义的ClassA抑或是实现PrintStream接口的实现类System.out),都可以正确调用到println()方法。</p><p>仅站在Java语言的角度看,MethodHandle在使用方法和效果上与Reflection有众多相似之处。不过,它们也有以下这些区别: </p><ul><li><p>Reflection和MethodHandle机制本质上都是在模拟方法调用,但是Reflection是在模拟Java代码层次的方法调用,而MethodHandle是在模拟字节码层次的方法调用。</p><ul><li><p>在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual(以及invokeinterface)和invokespecial这几条字节码指令的执行权限校验行为(即将原本编译期就能确定的符号引用延迟到运行期由用户代码来确定)</p></li><li><p>而这些动作对于Reflection API来说是一个JVM的底层动作，先对于它来说是抽象的，它是不需要关心的。</p></li></ul></li><li><p>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是方法在Java端的全面映像,包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式,还包含执行权限等的运行期信息。而后者仅包含执行该方法的相关信息。用开发人员通俗的话来讲,Reflection是重量级,而MethodHandle 是轻量级。</p></li><li><p>由于MethodHandle是对字节码的方法指令调用的模拟,那理论上虚拟机在这方面做的各种优化(如方法内联),在MethodHandle上也应当可以采用类似思路去支持(但目前实现还在继续完善中),而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施。</p></li></ul><p>MethodHandle与Reflection除了上面列举的区别外,最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度看”之后:Reflection API的设计目标是只为Java语言服务的,而MethodHandle 则设计为可服务于所有Java虚拟机之上的语言,其中也包括了Java语言而已,而且Java在这里并不是主角。</p><h2 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h2><p>JDK 7为了更好地支持动态类型语言引入了第五条方法调用的字节码指令invokedynamic, 将MethodHandle的示例代码反编译后并没有找到invokedynamic的身影,invokedynamic到底有什么应用呢? 某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的,都是为了解决原有4 条“invoke<em>”指令方法分派规则完全固化在虚拟机之中的问题：<strong>把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中,让用户(广义的用户,包含其他程序语言的设计者)有更高的自由度。</strong>而且,它们两者的思路也是可类比的,都是为了达成同一个目的,只是<strong>一个用上层代码和API来实现</strong>, <em>*另一个用字节码和Class中其他属性、常量来完成</em></em>。</p><p>每一处含有invokedynamic指令的位置都被称作“动态调用点(Dynamically-Computed Call Site)”, 这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量,而是变为JDK 7 时新加入的<strong>CONSTANT_InvokeDynamic_info</strong>常量,从这个新常量中可以得到3项信息:</p><ol><li><p>引导方法(Bootstrap Method,该方法存放在新增的BootstrapMethods属性中)</p><p>引导方法是有固定的参数,并且返回值规定是<code>java.lang.invoke.CallSite</code>对象,这个对象代表了真正要执行的目标方法调用</p></li><li><p>方法类型(MethodType)</p></li><li><p>方法名称。</p></li></ol><p>根据<strong>CONSTANT_InvokeDynamic_info</strong>常量中提供的信息,虚拟机可以找到并且执行引导方法,从而获得一个CallSite对象,最终调用到要执行的目标方法上（其实目前引导方法里面的实现还是最终会调到invoke包里面的api进行方法查找，然后将得到<code>MethodHandle</code>对象包装称一个<code>CallSite</code>）。下面例子说明<code>invokedynamic</code>指令的工作过程：</p><h3 id="例1：自定义字节码查找方法逻辑"><a href="#例1：自定义字节码查找方法逻辑" class="headerlink" title="例1：自定义字节码查找方法逻辑"></a>例1：自定义字节码查找方法逻辑</h3><p>利用JDK源码中的一个字节码转换工具将特定格式的源文件的字节码生成一个包含<code>invokedynamic</code>指令的新的字节码。</p><p>以下是特定的源文件，先对它进行javac编译得到一个class文件</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">.</span>dynamic<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InvokeDynamicTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token function">INDY_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">"icyfenix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//真正要执行的方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello String:"</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//Boostrap方法，由Boostrap属性表中的属性指定</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CallSite <span class="token function">BootstrapMethod</span><span class="token punctuation">(</span>MethodHandles<span class="token punctuation">.</span>Lookup lookup<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> MethodType mt<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConstantCallSite</span><span class="token punctuation">(</span>lookup<span class="token punctuation">.</span><span class="token function">findStatic</span><span class="token punctuation">(</span>InvokeDynamicTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取方法描述符</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> MethodType <span class="token function">MT_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> MethodType<span class="token punctuation">.</span><span class="token function">fromMethodDescriptorString</span><span class="token punctuation">(</span><span class="token string">"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取引导方法的句柄</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> MethodHandle <span class="token function">MH_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token keyword">return</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findStatic</span><span class="token punctuation">(</span>InvokeDynamicTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"BootstrapMethod"</span><span class="token punctuation">,</span> <span class="token function">MT_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//先获取引导方法的句柄，然后通过引导方法获取真正要执行方法的句柄，这个就是自定义寻找方法的实现，只不过这里放在了字节码层面来做，也就是说寻找逻辑可能在字节码层面就确定了，将无法在编译成字节码之前的源文件中定义逻辑，该逻辑一般由一门JVM语言来实现</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> MethodHandle <span class="token function">INDY_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        CallSite cs <span class="token operator">=</span> <span class="token punctuation">(</span>CallSite<span class="token punctuation">)</span> <span class="token function">MH_BootstrapMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeWithArguments</span><span class="token punctuation">(</span>MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"testMethod"</span><span class="token punctuation">,</span> MethodType<span class="token punctuation">.</span><span class="token function">fromMethodDescriptorString</span><span class="token punctuation">(</span><span class="token string">"(Ljava/lang/String;)V"</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cs<span class="token punctuation">.</span><span class="token function">dynamicInvoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在OpenJDK源码的<code>${SOURCE_CODE_HOME}/jdk/test/java/lang/invoke/indify/Indify.java</code>下面找到<code>Indify</code>工具类，然后复制出来，编写以下代码主动调用该工具类的<code>main</code>方法或者<code>java</code>执行也可以，在参数中分别指定要转换的class文件的路径(即上面编译得到的文件)以及转换的class文件的存放路径</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">.</span>dynamic<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/22 12:28 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Indify<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token string">"--verify-specifier-count=1"</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">/*INDY工具将Example.class转换成等效的class文件存放路径*/</span>                <span class="token string">"--dest=/Users/zhonghongpeng/IdeaProjects/tech-learning/jvm/target/classes/indy"</span><span class="token punctuation">,</span>                <span class="token string">"--verbose"</span><span class="token punctuation">,</span>                <span class="token string">"--expand-properties"</span><span class="token punctuation">,</span> <span class="token string">"--classpath"</span><span class="token punctuation">,</span> <span class="token string">"${java.class.path}"</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">/*输入class文件Example.class的全路径,然后使用javap打开该文件*/</span>                <span class="token string">"/Users/zhonghongpeng/IdeaProjects/tech-learning/jvm/target/classes/demo/dynamic/InvokeDynamicTest.class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Example.main();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行转换后，进入新的class文件所在目录，<code>java</code>执行新的class文件，可得到指定输出，<code>testMethod()</code>得到执行</p><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon dynamic % java -cp /Users/zhonghongpeng/IdeaProjects/tech-learning/jvm/target/classes/indy demo.dynamic.InvokeDynamicTesthello String:icyfenix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面分析新转换后的字节码是如何通过<code>invokedynamic</code>指令工作的：</p><p>首先可以看到的是在main方法中存在了一条<code>invokedynamic</code>指令，该指令指向了索引为124的常量池项。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111545.png" alt="image-20200922130539186"></p><p>通过查看124项常量为<code>CONSTANT_InvokeDynamic_info</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111546.png" alt="image-20200922130731119"></p><p>其结构为：</p><table><thead><tr><th>结构成员长度</th><th>结构成员类型</th><th>结构成员描述</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>值为18</td></tr><tr><td>u2</td><td>bootstrap_method_attr_index</td><td>值必须是对当前class文件中引导方法表的bootstrap_method[]数组的有效索引</td></tr><tr><td>u2</td><td>name_and_type_index</td><td>值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info结构，表示方法名称和方法描述符</td></tr></tbody></table><p>查看该常量内容：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111547.png" alt="image-20200922131138608"></p><p><strong>可以看到name_and_type指向的CONSTANT_NameAndType_info结构描述的正是我们要动态寻找的方法<code>testMethod</code></strong>，然后进一步查看Class文件的bootstrap_method属性表中的第0项内容，发现该项属性值为<code>#120</code>，指向了常量池中的一项<code>CONSTANT_Methodhandle_info</code>常量：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111548.png" alt="image-20200922131414368"></p><p>查看该常量，它引用了<code>#119</code>项<code>CONSTATN_Methodref_info</code>常量：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111549.png" alt="image-20200922131742684"></p><p>该<code>CONSTATN_Methodref_info</code>常量为：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111550.png" alt="image-20200922131954731"></p><p>可以看到，它引用的就是测试代码中寻找方法<code>testMethod()</code>的句柄的方法<code>INDY_BootstrapMethod</code>。</p><p>综上可以直到<code>invokedynmaic</code>方法可以通过<code>CONSTANT_Invokedynamic_info</code>常量中包含的对”被查找方法的符号引用常量”以及”查找方法逻辑的引导方法符号引用常量”一起实现动态地查找方法。</p><h3 id="例2：lambda查找方法逻辑"><a href="#例2：lambda查找方法逻辑" class="headerlink" title="例2：lambda查找方法逻辑"></a>例2：lambda查找方法逻辑</h3><p>来看下以下代码的字节码是怎么使用<code>invokedynamic</code>的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">.</span>dynamic<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/22 11:36 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaTest</span> <span class="token punctuation">{</span>    <span class="token keyword">interface</span> <span class="token class-name">PrintTool</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        PrintTool printTool <span class="token operator">=</span> System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">;</span>        printTool<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"icyfenix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接查看main方法字节码，看到了<code>invokedynamic</code>指令</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111551.png" alt="image-20200922132952160"></p><p>查看它引用的<code>#4</code>号<code>CONSTANT_Invokedynamic_info</code>常量项，可以看到此时内容和我们上面看到的不太一样了：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111552.png" alt="image-20200922133015064"></p><p>进一步查看<code>#35</code>号<code>CONSTANT_NameAndType_info</code>常量项，发现，此时该常量项指向了一个名为”println”、参数为<code>java.io.PrintStream</code>、返回值为<code>demo.dynamic.LambdaTest$PrintTool</code>的方法</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111553.png" alt="image-20200922133029845"></p><p>然后查看bootstrapmethod属性第0项，查找的是<code>java.io.PrintStream#println</code>方法</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111554.png" alt="image-20200922133134602"></p><p>另外我们看到最关键的<strong>Bootstrap Method为：<code>java.lang.invoke.LambdaMetafactory#metafactory</code></strong>，代码如下：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> CallSite <span class="token function">metafactory</span><span class="token punctuation">(</span>MethodHandles<span class="token punctuation">.</span>Lookup caller<span class="token punctuation">,</span>                                       String invokedName<span class="token punctuation">,</span>                                       MethodType invokedType<span class="token punctuation">,</span>                                       MethodType samMethodType<span class="token punctuation">,</span>                                       MethodHandle implMethod<span class="token punctuation">,</span>                                       MethodType instantiatedMethodType<span class="token punctuation">)</span>            <span class="token keyword">throws</span> LambdaConversionException <span class="token punctuation">{</span>        AbstractValidatingLambdaMetafactory mf<span class="token punctuation">;</span>        mf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClassLambdaMetafactory</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> invokedType<span class="token punctuation">,</span>                                             invokedName<span class="token punctuation">,</span> samMethodType<span class="token punctuation">,</span>                                             implMethod<span class="token punctuation">,</span> instantiatedMethodType<span class="token punctuation">,</span>                                             <span class="token boolean">false</span><span class="token punctuation">,</span> EMPTY_CLASS_ARRAY<span class="token punctuation">,</span> EMPTY_MT_ARRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>        mf<span class="token punctuation">.</span><span class="token function">validateMetafactoryArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mf<span class="token punctuation">.</span><span class="token function">buildCallSite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，Java8的lambda是通过该方法来动态寻找方法句柄的。</p><h2 id="实战运行运用"><a href="#实战运行运用" class="headerlink" title="实战运行运用"></a>实战运行运用</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> demo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>MethodHandle<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>MethodHandles<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>invoke<span class="token punctuation">.</span>MethodType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/22 14:24 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicPractise</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">GrandFather</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i am grandfather"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">GrandFather</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i am father"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 请读者在这里填入适当的代码(不能修改其他地方的代码)实现调用祖父类的thinking()方法,打印"i am grandfather"         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">void</span> <span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//JDK 7 Update 9之前</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                MethodType mt <span class="token operator">=</span> MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                MethodHandle mh <span class="token operator">=</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findSpecial</span><span class="token punctuation">(</span>GrandFather<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"thinking"</span><span class="token punctuation">,</span> mt<span class="token punctuation">,</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mh<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/*            在JDK 7 Update 10之后            这个逻辑在JDK 7 Update 9之后被视作一个潜在的安全性缺陷修正了,原因是必须保证findSpecial()查找方法版本时受到的访问约束(譬如对访问控制的限制、对参数类型的限制)            应与使用invokespecial指令一样,两者必须保持精确对等,包括在上面的场景中它只能访问到其直接父类中的方法版本。            */</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                MethodType mt <span class="token operator">=</span> MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Field lookupImpl <span class="token operator">=</span> MethodHandles<span class="token punctuation">.</span>Lookup<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"IMPL_LOOKUP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                lookupImpl<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                MethodHandle mh <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>MethodHandles<span class="token punctuation">.</span>Lookup<span class="token punctuation">)</span> lookupImpl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findSpecial</span><span class="token punctuation">(</span>GrandFather<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"thinking"</span><span class="token punctuation">,</span> mt<span class="token punctuation">,</span> GrandFather<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mh<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thinking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/11/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/02-cheng-xu-ji-shu-ji-cun-qi/"/>
      <url>/2020/09/11/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/02-cheng-xu-ji-shu-ji-cun-qi/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111502.png" alt="image-20200911110925570"></p><p>JVM中的程序计数寄存器(Program Counter Register)中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够进行逻辑计算(ALU)。</p><p>这里，并非是广义上所指的物理寄存器，它仅仅是JVM中对于物理PC寄存器的一种抽象模拟。它是JVM定义的一个数据结构，用来存储指向JVM方法中下一条JVM指令的地址(索引)，也就是可以获取到即将要执行的指令代码，由执行引擎读取下一条指令。</p><p>它是一块独立的很小的内存空间，即不属于栈(虚拟机栈和本地方法栈)也不属于堆，几乎可以忽略不记，这块内存和线程绑定。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的声明周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是在执行native方法，则是未指定值(undefined)。（所以个人猜测对于<strong>用户方法的实现</strong>就是在<strong>一个统一的通用的native方法</strong>中加载用户方法中所有jvm指令到一个列表，然后模拟CPU指令按指令进行实际的C/C++代码操作即可）</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何<code>OutofMemoryError</code>情况的区域。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111503.png" alt="image-20200911111453664"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111504.png" alt="image-20200911113000991"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111505.png" alt="image-20200911113116621"></p><h3 id="为什么要有PC寄存器"><a href="#为什么要有PC寄存器" class="headerlink" title="为什么要有PC寄存器"></a>为什么要有PC寄存器</h3><p>因为CPU需要不停地切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/11/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/01-yun-xing-shi-shu-ju-qu/"/>
      <url>/2020/09/11/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/01-yun-xing-shi-shu-ju-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>内存是非常重要的资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111343.png" alt="image-20200911073849034"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111344.png" alt="image-20200911074007528"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111345.png" alt="image-20200911074230149"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111346.png" alt="image-20200916211334192"></p><h1 id="运行时数据区分类"><a href="#运行时数据区分类" class="headerlink" title="运行时数据区分类"></a>运行时数据区分类</h1><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线性对应的数据区会随着线程开始和结束而创建和销毁。</p><ul><li>每个线程：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><h1 id="Runtime实例"><a href="#Runtime实例" class="headerlink" title="Runtime实例"></a>Runtime实例</h1><p>每个JVM只有一个<code>Runtime</code>实例。即内存结构中的运行时环境。可以通过<code>Runtime#getRuntime()</code>方法获取。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111347.png" alt="image-20200911074617973"></p><h1 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h1><p>下面是一些个人经过一些书籍和资料查询总结对于堆栈的理解。首先在数据结构上堆是一棵结点具有权重的树，栈是一个先进后出的线性表，而我们这里讨论的是计算机内存管理中的栈区和堆区，栈区和堆区在物理上没有实质的区别，主要是管理上的区别。计算机的硬件(CPU)提供了栈区的实现基础，包括直接提供了一些相关的寄存器和操作指令的支持，栈空间(每一个线程)的分配和销毁都由操作系统来完成；而堆是由库函数按照一定的规则进行动态分配的。对于用户程序来说，栈空间的使用效率会更高。</p><p>计算机硬件对栈的支持（相关寄存器和操作指令）源于计算机硬件要实现的业务中一些业务逻辑符合先进后出的线性结构。如函数调用：调用函数调用被调用函数的时候，需要保存调用方法的寄存器信息，这时候就会用到堆栈将这些信息进行压栈，被调用方法执行完成之后返回的时候进行弹栈还原函数的寄存器。(线程切换应该也可以用到)</p><p>如果用户的程序业务逻辑有符合栈结构，可以考虑直接使用系统直接提供的栈空间。</p><blockquote><p>疑问：用户可以使用栈空间吗？如果可以，是否需要在方法返回前进行弹栈操作，还原状态为和调用本方法入口时的压栈状态一致？</p></blockquote><h2 id="一、转载：堆与栈"><a href="#一、转载：堆与栈" class="headerlink" title="一、转载：堆与栈"></a>一、转载：堆与栈</h2><p>“栈”一般是由硬件（CPU）实现的，CPU用栈来保存调用子程序（函数）时的返回地址，高级语言有时也用它作为局部变量的存储空间。</p><p>“堆”是个实实在在的软件概念，使用与否完全由编程者“显示地（explicitly）”决定，如malloc。</p><p>程序经过编译连接生成执行程序后，堆和栈的起始地址就已经确定了（具体说，是通过“连接程序”），在一个具有反向增长的栈的CPU上，数据空间可表示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111348.png" alt="栈增长"></p><p>注意：</p><blockquote><p>进程地址空间的分布取决于操作系统，栈向什么方向增长取决于操作系统与CPU的组合。</p><p>不要把别的操作系统的实现方式套用到Windows上。</p><p>栈的增长方向与栈帧布局这个上下文里说的“栈”是函数调用栈，是以“栈帧”（stack frame）为单位的。每一次函数调用会在栈上分配一个新的栈帧，在这次函数调用结束时释放其空间。被调用函数（callee）的栈帧相对调用函数（caller）的栈帧的位置反映了栈的增长方向：如果被调用函数的栈帧比调用函数的在更低的地址，那么栈就是向下增长；反之则是向上增长。而在一个栈帧内，局部变量是如何分布到栈帧里的（所谓栈帧布局，stack frame layout），这完全是编译器的自由。至于数组元素与栈的增长方向：C与C++语言规范都规定了数组元素是分布在连续递增的地址上的。</p><p>堆没有方向之说，每个堆都是散落的</p><p>堆和栈之间没有谁地址高之说，看操作系统实现</p><p>数组取下标偏移总是往上涨的，和在堆还是栈没啥关系</p></blockquote><h3 id="C-内存区域"><a href="#C-内存区域" class="headerlink" title="C++内存区域"></a>C++内存区域</h3><p>C++作为一款C语言的升级版本，具有非常强大的功能。它不但能够支持各种程序设计风格，而且还具有C语言的所有功能。我们在这里为大家介绍的是其中一个比较重要的内容，C++内存区域的基本介绍。</p><p>C++内存区域分为5个区域。分别是堆，栈，自由存储区，全局/静态存储区和常量存储区。</p><p>栈：</p><blockquote><p>由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面通常是局部变量，函数参数等。</p></blockquote><p>堆：</p><blockquote><p>由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p></blockquote><p>自由存储区：</p><blockquote><p>由malloc等分配的内存块，和堆十分相似，不过它使用free来结束自己的生命。</p></blockquote><p>全局/静态存储区：</p><blockquote><p>全局变量和静态变量被分配到同一块内存中，在以前的c语言中。全局变量又分为初始化的和未初始化的，在c++里面没有这个区分了，他们共同占用同一块内存。</p></blockquote><p>常量存储区：</p><blockquote><p>这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p></blockquote><h3 id="C-内存区域中堆和栈的区别"><a href="#C-内存区域中堆和栈的区别" class="headerlink" title="C++内存区域中堆和栈的区别"></a>C++内存区域中堆和栈的区别</h3><p>管理方式不同：</p><blockquote><p>栈是由编译器自动管理，无需我们手工控制；对于堆来说，释放由程序员完成，容易产生内存泄漏。</p></blockquote><p>空间大小不同：</p><blockquote><p>一般来讲，在32位系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project–&gt;setting–&gt;link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。</p></blockquote><p>能否产生碎片：</p><blockquote><p>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。</p></blockquote><p>生长方向不同：</p><blockquote><p>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。<br>注意：进程地址空间的分布取决于操作系统，栈向什么方向增长取决于操作系统与CPU的组合。不要把别的操作系统的实现方式套用到Windows上。</p></blockquote><p>x86硬件直接支持的栈确实是“向下增长”的</p><p>分配方式不同：</p><blockquote><p>堆都是动态分配的；栈有静态和动态两种分配方式。静态分配由编译器完成，比如局部变量的分配。动态分配由malloca函数进行、但栈的动态分配和堆是不同的，它的动态分配由编译器进行释放，无需我们手工实现。</p></blockquote><p>分配效率不同：</p><blockquote><p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。</p></blockquote><h3 id="为什么要把堆和栈分开？"><a href="#为什么要把堆和栈分开？" class="headerlink" title="为什么要把堆和栈分开？"></a>为什么要把堆和栈分开？</h3><p>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</p><p>从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。</p><p>堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p><p>栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈的反向增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p><p>面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。</p><h3 id="堆和栈它们在哪儿？"><a href="#堆和栈它们在哪儿？" class="headerlink" title="堆和栈它们在哪儿？"></a>堆和栈它们在哪儿？</h3><p>栈是为执行线程留出的内存空间。当函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。</p><p>堆（heap）是为动态分配预留的内存空间。和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。</p><p>每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。</p><p>当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。</p><p>栈附属于线程，因此当线程结束时栈被回收。堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。</p><p>当线程被创建的时候，设置栈的大小。在应用程序启动的时候，设置堆的大小，但是可以在需要的时候扩展（分配器向操作系统申请更多的内存）。</p><p><strong>栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算）</strong>，然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快（译者注：局部性原理）。</p><p>堆和栈是两种内存分配的两个统称。可能有很多种不同的实现方式，但是实现要符合几个基本的概念:</p><blockquote><p>对栈而言，栈中的新加数据项放在其他数据的顶部，移除时你也只能移除最顶部的数据（不能越位获取）。</p><p>对堆而言，数据项位置没有固定的顺序。你可以以任何顺序插入和删除，因为他们没有“顶部”数据这一概念。</p><p>如前所述，堆和栈是一个统称，可以有很多的实现方式。计算机程序通常有一个栈叫做调用栈，用来存储当前函数调用相关的信息（比如：主调函数的地址，局部变量），因为函数调用之后需要返回给主调函数。栈通过扩展和收缩来承载信息。实际上，程序不是由运行时来控制的，它由编程语言、操作系统甚至是系统架构来决定。</p><p>堆是在任何内存中动态和随机分配的（内存的）统称；也就是无序的。内存通常由操作系统分配，通过应用程序调用 API 接口去实现分配。在管理动态分配内存上会有一些额外的开销，不过这由操作系统来处理。</p></blockquote><p>堆：</p><blockquote><p>堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。这个操作会更新堆中的块链表。这些元信息也存储在堆上，经常在每个块的头部一个很小区域。</p><p>堆的增加新快通常从地地址向高地址扩展。因此你可以认为堆随着内存分配而不断的增加大小。如果申请的内存大小很小的话，通常从底层操作系统中得到比申请大小要多的内存。</p><p>申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。进而申请大块内存失败，虽然空闲块的总和足够，但是空闲的小块是零散的，不能满足申请的大小，。这叫做“堆碎片”。</p><p>当旁边有空闲块的已用块被释放时，新的空闲块可能会与相邻的空闲块合并为一个大的空闲块，这样可以有效的减少“堆碎片”的产生。</p></blockquote><p>栈：</p><blockquote><p>栈经常与 sp 寄存器（译者注：”stack pointer”，了解汇编的朋友应该都知道）一起工作，最初 sp 指向栈顶（栈的高地址）。</p><p>CPU 用 push 指令来将数据压栈，用 pop 指令来弹栈。当用 push 压栈时，sp 值减少（向低地址扩展）。当用 pop 弹栈时，sp 值增大。存储和获取数据都是 CPU 寄存器的值。</p><p>当函数被调用时，CPU使用特定的指令把当前的 IP （译者注：“instruction pointer”，是一个寄存器，用来记录 CPU 指令的位置）压栈。即执行代码的地址。CPU 接下来将调用函数地址赋给 IP ，进行调用。当函数返回时，旧的 IP 被弹栈，CPU 继续去函数调用之前的代码。</p><p>当进入函数时，sp 向下扩展，扩展到确保为函数的局部变量留足够大小的空间。如果函数中有一个 32-bit 的局部变量会在栈中留够四字节的空间。当函数返回时，sp 通过返回原来的位置来释放空间。</p><p>如果函数有参数的话，在函数调用之前，会将参数压栈。函数中的代码通过 sp 的当前位置来定位参数并访问它们。</p><p>函数嵌套调用和使用魔法一样，每一次新调用的函数都会分配函数参数，返回值地址、局部变量空间、嵌套调用的活动记录都要被压入栈中。函数返回时，按照正确方式的撤销。</p><p>栈要受到内存块的限制，不断的函数嵌套/为局部变量分配太多的空间，可能会导致栈溢出。当栈中的内存区域都已经被使用完之后继续向下写（低地址），会触发一个 CPU 异常。这个异常接下会通过语言的运行时转成各种类型的栈溢出异常。（译者注：“不同语言的异常提示不同，因此通过语言运行时来转换”我想他表达的是这个含义）</p></blockquote><h3 id="转载链接"><a href="#转载链接" class="headerlink" title="转载链接"></a>转载链接</h3><blockquote><p><a href="http://code4fs.xyz/article/41/" target="_blank" rel="noopener">http://code4fs.xyz/article/41/</a></p></blockquote><h2 id="二、转载：程序的内存分配之堆和栈的区别"><a href="#二、转载：程序的内存分配之堆和栈的区别" class="headerlink" title="二、转载：程序的内存分配之堆和栈的区别"></a>二、转载：<a href="https://developer.aliyun.com/article/342485" target="_blank" rel="noopener">程序的内存分配之堆和栈的区别</a></h2><h2 id="三、方法调用中栈的使用"><a href="#三、方法调用中栈的使用" class="headerlink" title="三、方法调用中栈的使用"></a>三、方法调用中栈的使用</h2><h3 id="1-gt-转载：x86-64下函数调用及栈帧原理"><a href="#1-gt-转载：x86-64下函数调用及栈帧原理" class="headerlink" title="1&gt; 转载：x86-64下函数调用及栈帧原理"></a>1&gt; 转载：x86-64下函数调用及栈帧原理</h3><h4 id="通用寄存器使用惯例"><a href="#通用寄存器使用惯例" class="headerlink" title="通用寄存器使用惯例"></a>通用寄存器使用惯例</h4><p>函数调用时，在硬件层面我们需要关注的通常是cpu 的通用寄存器。在所有 cpu 体系架构中，每个寄存器通常都是有建议的使用方法的，而编译器也通常依照CPU架构的建议来使用这些寄存器，因而我们可以认为这些建议是强制性的。</p><p>对于 x86-64 架构，共有16个64位通用寄存器，各寄存器及用途如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111349.png" alt="x86-64寄存器"></p><p>从上图中，我们可以得到如下结论：</p><ul><li>每个寄存器的用途并不是单一的。</li><li>%rax 通常用于存储函数调用的返回结果，同时也用于乘法和除法指令中。在imul 指令中，两个64位的乘法最多会产生128位的结果，需要 %rax 与 %rdx 共同存储乘法结果，在div 指令中被除数是128 位的，同样需要%rax 与 %rdx 共同存储被除数。</li><li>%rsp 是堆栈指针寄存器，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变 %rsp 的值即移动堆栈指针的位置来实现的。</li><li>%rbp 是栈帧指针，用于标识当前栈帧的起始位置</li><li>%rdi, %rsi, %rdx, %rcx,%r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。</li><li>被标识为 “miscellaneous registers” 的寄存器，属于通用性更为广泛的寄存器，编译器或汇编程序可以根据需要存储任何数据。</li></ul><p>这里还要区分一下 “Caller Save” 和 ”Callee Save” 寄存器，即寄存器的值是由”调用者保存“ 还是由 ”被调用者保存“。当产生函数调用时，子函数内通常也会使用到通用寄存器，那么这些寄存器中之前保存的调用者(父函数）的值就会被覆盖。为了避免数据覆盖而导致从子函数返回时寄存器中的数据不可恢复，CPU 体系结构中就规定了通用寄存器的保存方式。</p><p>如果一个寄存器被标识为”Caller Save”， 那么在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值压入堆栈中，调用者保存完成后，在被调用者（子函数）中就可以随意覆盖这些寄存器的值了。如果一个寄存被标识为“Callee Save”，那么在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的。</p><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><p>子函数调用时，调用者与被调用者的栈帧结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111350.png" alt="函数调用栈帧情况"></p><p>在子函数调用时，执行的操作有：父函数将调用参数从后向前压栈 -&gt; 将返回地址压栈保存 -&gt; 跳转到子函数起始地址执行 -&gt; 子函数将父函数栈帧起始地址（%rpb） 压栈 -&gt; 将 %rbp 的值设置为当前 %rsp 的值，即将 %rbp 指向子函数栈帧的起始地址。</p><p>上述过程中，保存返回地址和跳转到子函数处执行由 call 一条指令完成，在call 指令执行完成时，已经进入了子程序中，因而将上一栈帧%rbp 压栈的操作，需要由子程序来完成。函数调用时在汇编层面的指令序列如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">...   # 参数压栈call FUNC  # 将返回地址压栈，并跳转到子函数 FUNC 处执行...  # 函数调用的返回位置FUNC:  # 子函数入口pushq %rbp  # 保存旧的帧指针，相当于创建新的栈帧movq  %rsp, %rbp  # 让 %rbp 指向新栈帧的起始位置subq  $N, %rsp  # 在新栈帧中预留一些空位，供子程序使用，用 (%rsp+K) 或 (%rbp-K) 的形式引用空位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存返回地址和保存上一栈帧的%rbp 都是为了函数返回时，恢复父函数的栈帧结构。在使用高级语言进行函数调用时，由编译器自动完成上述整个流程。对于”Caller Save” 和 “Callee Save” 寄存器的保存和恢复，也都是由编译器自动完成的。</p><p>需要注意的是，父函数中进行参数压栈时，顺序是从后向前进行的。但是，这一行为并不是固定的，是依赖于编译器的具体实现的，在gcc 中，使用的是从后向前的压栈方式，这种方式便于支持类似于 printf(“%d, %d”, i, j) 这样的使用变长参数的函数调用。</p><h4 id="函数的返回"><a href="#函数的返回" class="headerlink" title="函数的返回"></a>函数的返回</h4><p>函数返回时，我们只需要得到函数的返回值（保存在 %rax 中），之后就需要将栈的结构恢复到函数调用之差的状态，并跳转到父函数的返回地址处继续执行。由于函数调用时已经保存了返回地址和父函数栈帧的起始地址，要恢复到子函数调用之前的父栈帧，我们只需要执行以下两条指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">movq %rbp, %rsp    # 使 %rsp 和 %rbp 指向同一位置，即子栈帧的起始处popq %rbp # 将栈中保存的父栈帧的 %rbp 的值赋值给 %rbp，并且 %rsp 上移一个位置指向父栈帧的结尾处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了便于栈帧恢复，x86-64 架构中提供了 leave 指令来实现上述两条命令的功能。执行 leave 后，前面图中函数调用的栈帧结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111351.png" alt="函数调用返回后栈帧情况"></p><p>可以看出，调用 leave 后，%rsp 指向的正好是返回地址，x86-64 提供的 ret 指令，其作用就是从当前 %rsp 指向的位置（即栈顶）弹出数据，并跳转到此数据代表的地址处，在leave 执行后，%rsp 指向的正好是返回地址，因而 ret 的作用就是把 %rsp 上移一个位置，并跳转到返回地址执行。可以看出，leave 指令用于恢复父函数的栈帧，ret 用于跳转到返回地址处，leave 和ret 配合共同完成了子函数的返回。当执行完成 ret 后，%rsp 指向的是父栈帧的结尾处，父栈帧尾部存储的调用参数由编译器自动释放。</p><h4 id="函数调用示例"><a href="#函数调用示例" class="headerlink" title="函数调用示例"></a>函数调用示例</h4><p>为了更深入的了解函数调用原理，我们可以使用一个程序示例来观察函数的调用和返回。程序如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 8 个参数相加</span>  <span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">+</span> d <span class="token operator">+</span> e <span class="token operator">+</span> f <span class="token operator">+</span> g <span class="token operator">+</span> h<span class="token punctuation">;</span>  <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> m <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为了观察 %rax Caller Save 寄存器的恢复</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在main 函数中，首先进行了一个 k=i+j 的加法，这是为了观察 Caller Save 效果。因为加法会用到 %rax，而下面 add 函数的返回值也会使用 %rax。由于 %rax 是 Caller Save 寄存器，在调用 add 子函数之前，程序应该先保存 %rax 的值。</p><p>add 函数使用了 8 个参数，这是为了观察当函数参数多于6个时程序的行为，前6个参数会保存到寄存器中，多于6个的参数会保存到堆栈中。但是，由于在子程序中可能会取参数的地址，而保存在寄存器中的前6个参数是没有内存地址的，因而我们可以猜测，保存在寄存器中的前6个参数，在子程序中也会被压入到堆栈中，这样才能取到这6个参数的内存地址。上面程序生成的和子函数调用相关的汇编程序如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">add:.LFB2:    pushq    %rbp.LCFI0:    movq    %rsp, %rbp.LCFI1:    movl    %edi, -20(%rbp)    movl    %esi, -24(%rbp)    movl    %edx, -28(%rbp)    movl    %ecx, -32(%rbp)    movl    %r8d, -36(%rbp)    movl    %r9d, -40(%rbp)    movl    -24(%rbp), %eax    addl    -20(%rbp), %eax    addl    -28(%rbp), %eax    addl    -32(%rbp), %eax    addl    -36(%rbp), %eax    addl    -40(%rbp), %eax    addl    16(%rbp), %eax    addl    24(%rbp), %eax    movl    %eax, -4(%rbp)    movl    -4(%rbp), %eax    leave    retmain:.LFB3:    pushq    %rbp.LCFI2:    movq    %rsp, %rbp.LCFI3:    subq    $48, %rsp.LCFI4:    movl    $10, -20(%rbp)    movl    $20, -16(%rbp)    movl    -16(%rbp), %eax    addl    -20(%rbp), %eax    movl    %eax, -12(%rbp)    movl    $88, 8(%rsp)    movl    $77, (%rsp)    movl    $66, %r9d    movl    $55, %r8d    movl    $44, %ecx    movl    $33, %edx    movl    $22, %esi    movl    $11, %edi    call    add    movl    %eax, -8(%rbp)    movl    -12(%rbp), %eax    movl    %eax, -4(%rbp)    movl    $0, %eax    leave    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在汇编程序中，如果使用的是64位通用寄存器的低32位，则寄存器以 ”e“ 开头，比如 %eax，%ebx 等，对于 %r8-%r15，其低32 位是在64位寄存后加 “d” 来表示，比如 %r8d, %r15d。如果操作数是32 位的，则指令以 ”l“ 结尾，例如 movl $11, %esi，指令和寄存器都是32位的格式。如果操作数是64 位的，则指令以 q 结尾，例如 “movq %rsp, %rbp”。由于示例程序中的操作数全部在32位的表示范围内，因而上面的加法和移动指令全部是用的32位指令和操作数，只有在创建栈帧时为了地址对齐才使用的是64位指令及操作数。</p><p>首先看 main 函数的前三条汇编语句：</p><pre class="line-numbers language-assembly"><code class="language-assembly">.LFB3:    pushq    %rbp.LCFI2:    movq    %rsp, %rbp.LCFI3:    subq    $48, %rsp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三条语句保存了父函数的栈帧（注意main函数也有父函数），之后创建了main 函数的栈帧并且在栈帧中分配了48Byte 的空位，这三条语句执行完成后，main 函数的栈帧如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111352.png" alt="函数调用示例栈帧情况"></p><p>之后，main 函数中就进行了 k=i+j 的加法和 add 参数的处理：</p><pre class="line-numbers language-assembly"><code class="language-assembly">    movl    $10, -20(%rbp)    movl    $20, -16(%rbp)    movl    -16(%rbp), %eax    addl    -20(%rbp), %eax    movl    %eax, -12(%rbp)  # 调用子函数前保存 %eax 的值到栈中，caller save    movl    $88, 8(%rsp)    movl    $77, (%rsp)    movl    $66, %r9d    movl    $55, %r8d    movl    $44, %ecx    movl    $33, %edx    movl    $22, %esi    movl    $11, %edi    call    add<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行 k=i+j 加法时，使用 main 栈空间的方式较为特别。并不是按照我们通常认为的每使用一个栈空间就会进行一次push 操作，而是使用之前预先分配的 48 个空位，并且用 -N(%rbp) 即从 %rbp 指向的位置向下计数的方式来使用空位的，本质上这和每次进行 push 操作是一样的，最后计算 i+j 得到的结果 k 保存在了 %eax 中。之后就需要准备调用 add 函数了。</p><p>我们知道，add 函数的返回值会保存在 %eax 中，即 %eax 一定会被子函数 add 覆盖，而现在 %eax 中保存的是 k 的值。在 C 程序中可以看到，在调用完成 add 后，我们又使用了 k 的值，因而在调用 add 中覆盖%eax 之前，需要保存 %eax 值，在add 使用完%eax 后，需要恢复 %eax 值（即k 的值），由于 %eax 是 Caller Save的，应该由父函数main来保存 %eax 的值，因而上面汇编中有一句 “movl %eax, -12(%rbp)” 就是在调用 add 函数之前来保存 %eax 的值的。</p><p>对于8个参数，可以看出，最后两个参数是从后向前压入了栈中，前6个参数全部保存到了对应的参数寄存器中，与本文开始描述的一致。</p><p>进入 add 之后的操作如下：</p><pre class="line-numbers language-assembly"><code class="language-assembly">add:.LFB2:    pushq    %rbp # 保存父栈帧指针.LCFI0:    movq    %rsp, %rbp  # 创建新栈帧.LCFI1:    movl    %edi, -20(%rbp)  # 在寄存器中的参数压栈    movl    %esi, -24(%rbp)    movl    %edx, -28(%rbp)    movl    %ecx, -32(%rbp)    movl    %r8d, -36(%rbp)    movl    %r9d, -40(%rbp)    movl    -24(%rbp), %eax    addl    -20(%rbp), %eax    addl    -28(%rbp), %eax    addl    -32(%rbp), %eax    addl    -36(%rbp), %eax    addl    -40(%rbp), %eax    addl    16(%rbp), %eax    addl    24(%rbp), %eax    movl    %eax, -4(%rbp)    movl    -4(%rbp), %eax    leave    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>add 中最前面两条指令实现了新栈帧的创建。之后把在寄存器中的函数调用参数压入了栈中。在本文前面提到过，由于子程序中可能会用到参数的内存地址，这些参数放在寄存器中是无法取地址的，这里把参数压栈，正好印证了我们之前的猜想。</p><p>在参数压栈时，我们看到并未使用 push 之类的指令，也没有调整 %esp 指针的值，而是使用了 -N(%rbp) 这样的指令来使用新的栈空间。这种使用”基地址+偏移量“ 来使用栈的方式和直接使用 %esp 指向栈顶的方式其实是一样的。</p><p>这里有两个和编译器具体实现相关的问题：一是上面程序中，-8(%rbp) 和 -12(%rbp) 地址并未被使用到，这两个地址之前的地址 -4(%rbp) 和之后的 -16(%rsp) 都被使用到了，这可能是由于编译器具体的实现方式来决定的。另外一个就是如下两条指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">    movl    %eax, -4(%rbp)    movl    -4(%rbp), %eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>先是把 %eax 的值赋值给的 -4(%rbp)，之后又逆向赋值了一次，猜测可能是编译器为了通用性才如此操作的。以上两个问题需要后续进一步研究。</p><p>当add函数返回后，返回结果会存储在%eax 中，%rbp 和 %rsp 会调整为指向 main 的栈帧，之后会执行main 函数中的如下指令：</p><pre class="line-numbers language-assembly"><code class="language-assembly">movl    %eax, -8(%rbp)  # 保存 add 函数返回值到栈中，对应 C 语句 int sum = add(...)movl   -12(%rbp), %eax  # 恢复 call save 寄存器 %eax 的值，与调用add前保存 %eax 相对应 movl    %eax, -4(%rbp) # 对应 C 语句 m = k，%eax 中的值就是 k。movl    $0, %eax  # main 函数返回值leave   # main 函数返回ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，当 add 函数返回时，把返回值保存到了 %eax 中，使用完返回值后，会恢复 caller save 寄存器 %eax的值，这时main 栈帧与调用 add 之前完全一样。</p><p>需要注意的是，在调用 add 之前，main 中执行了一条 subq 48, %rsp 这样的指令，原因就在于调用 add 之后，main 中并未调用其他函数，而是执行了两条赋值语句后就直接从main返回了。 main 结尾处的 leave、ret 两条指令会直接覆盖 %rsp 的值从而回到 main 的父栈帧中。如果先调整 main 栈帧的 %rsp 值，之后 leave 再覆盖 %rsp 的值，相当于调整是多余的。因而省略main 中 add返回之后的 %rsp 的调整，而使用 leave 直接覆盖%rsp更为合理。</p><h4 id="转载链接-1"><a href="#转载链接-1" class="headerlink" title="转载链接"></a>转载链接</h4><blockquote><p><a href="https://zhuanlan.zhihu.com/p/27339191" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27339191</a></p><p><a href="https://blog.csdn.net/Hanoi_ahoj/article/details/105115117" target="_blank" rel="noopener">线程的栈是如何分配的</a></p></blockquote><h3 id="2-gt-英特尔8080芯片示例"><a href="#2-gt-英特尔8080芯片示例" class="headerlink" title="2&gt; 英特尔8080芯片示例"></a>2&gt; 英特尔8080芯片示例</h3><p>下面是英特尔8080处理器中一个子程序调用的示例。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111353.png" alt="image-20200911095457835"></p><h1 id="JVM主要内存占用以及溢出问题"><a href="#JVM主要内存占用以及溢出问题" class="headerlink" title="JVM主要内存占用以及溢出问题"></a>JVM主要内存占用以及溢出问题</h1><ul><li>直接内存:可通过<code>-XX:MaxDirectMemorySize</code>调整大小,内存不足时抛出<code>OutOfMemoryError:null</code>或者<code>OutOfMemoryError:Direct buffer memory</code>。</li><li>线程堆栈:可通过<code>-Xss</code>调整大小,内存不足时抛出StackOverflowError(如果线程请求的栈深度大于虚拟机所允许的深度)或者OutOfMemoryError(如果Java虚拟机栈容量可以动态扩展,当栈扩展时无法申请到足够的内存)。</li><li>Socket缓存区:每个Socket连接都Receive和Send两个缓存区,分别占大约37KB和25KB内存,连接多的话这块内存占用也比较可观如果无法分配,可能会抛出<code>IOException:Too many open files</code>异常。</li><li>JNI代码:如果代码中使用了JNI调用本地库,那本地库使用的内存也不在堆中,而是占用Java虚拟机的本地方法栈和本地内存的。</li><li>虚拟机和垃圾收集器:虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/11-class-wen-jian/"/>
      <url>/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/11-class-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Class文件是JVM的输入，Java虚拟机规范中定义了Class文件的结构。Class文件是JVM实现平台无关、技术无关的基础。</p><ol><li>Class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列(无特殊分隔符，如空格)</li><li>对于占用空间大于8字节的数据项，按照高位在前(Big-edian)的方式分割成多个8字节进行存储</li><li>Class文件格式里面只有两种类型：无符号数、表<ol><li>无符号数属于基本的数据类型,以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数,无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数和其它表构成的复合数据类型，通常以”_info”结尾。表用于描述有层次关系的复合结构的数据,整个Class文件本质上也可以视作是一张表</li></ol></li></ol><h2 id="Class文件图表示意"><a href="#Class文件图表示意" class="headerlink" title="Class文件图表示意"></a>Class文件图表示意</h2><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>抽象类型</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>major_verslon</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td><td>无符号数</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count</td><td>表</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>this_class</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>super_class</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td><td>无符号数</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td><td>无符号数</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td><td>无符号数</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td><td>表</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td><td>无符号数</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td><td>表</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td><td>无符号数</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td><td>表</td></tr></tbody></table><p> <img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218115959.png" alt="class"></p><h1 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h1><p>每个Class文件的头4个字节被称为魔数(Magic Number),它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件,其值为”0xCAFEBABE”。</p><p>紧接着魔数的4个字节存储的是Class文件的版本号:第5和第6个字节是次版本号(Minor Version),第7和第8个字节是主版本号(Major Version)。</p><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><p>常量池描述分为两部分：</p><ul><li><p>constant_pool_count：常量池数量，固定占两个字节</p><blockquote><p>注意：</p><p>常量池项(cp_info)从索引0开始，最后一个常量池项(cp_info)的素引值为constant_pool_count-1，所以真正常量池数量应该为constant_pool_count-1。例如constant_ pool_ count=22,则后面的常量池项(cp_info)的个数就为21。</p><p>原因是在指定 class 文件规范的时候,将第0项常量空出来是有特殊考虑的,这样做是为了满足某些指向常量池的素引值的数据在特定的情况下表达“不引用任何一个常量池项”的意思,这种情况下可以将素引值设置成0来表示) </p><p>class文件结构中只有常量池的容量计数是从1开始,对于其他集合类型,包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同,是从0开始。</p></blockquote></li><li><p>cp_info：常量池项，长度由常量池数量以及本身的常量类型决定</p></li></ul><h2 id="常量池内容"><a href="#常量池内容" class="headerlink" title="常量池内容"></a>常量池内容</h2><p>常量池中主要存放两大类常量:字面量(Literal)和符号引用(Symbolic References)。</p><ul><li>字面量比较接近于Java语言层面的常量概念, 如文本字符串、被声明为final的常量值等。</li><li>而符号引用则属于编译原理方面的概念,主要包括下面几类常量:<ul><li>被模块导出或者开放的包(Package) </li><li>类和接口的全限定名(Fully Qualified Name) </li><li>字段的名称和描述符(Descriptor) </li><li>方法的名称和描述符</li><li>方法句柄和方法类型(Method Handle、Method Type、Invoke Dynamic) </li><li>动态调用点和动态常量(Dynamically-Computed CallSite、Dynamically-Computed Constant)</li></ul></li></ul><h2 id="常量池项-cp-info-结构"><a href="#常量池项-cp-info-结构" class="headerlink" title="常量池项(cp_info)结构"></a>常量池项(cp_info)结构</h2><p>常量池中每一项常量都是一个表,现在常量表中共有17种结构各不相同的表结构数据，这17类表都有一个共同的特点,表结构起始的第一位是个u1类型的标志位(tag),代表着当前常量属于哪种常量类型。</p><pre class="line-numbers language-c"><code class="language-c">cp_info <span class="token punctuation">{</span>    u1 tag<span class="token punctuation">;</span>    u1 info<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tag值"><a href="#tag值" class="headerlink" title="tag值"></a>tag值</h3><p>每个常量池项(cp_info)都会对应记录着Class文件中的某种类型的字面量。VM虚拟机根据tag的值来确定是某个常量池项(cp_info)表示什么类型的字面量。</p><table><thead><tr><th>Tag值</th><th>表示的宇面量</th><th>更细化的结构</th></tr></thead><tbody><tr><td>1</td><td>以UTF-8编码的字符串，通常用于被其他表结构引用</td><td>CONSTANT_Utf8_info</td></tr><tr><td>3</td><td>表示4字节(int)的数值字面量</td><td>CONSTANT_Integer_info</td></tr><tr><td>4</td><td>表示4字节( Float)的数值字面量</td><td>CONSTANT_Float_info</td></tr><tr><td>5</td><td>表示8字节(Long)的数值字面量</td><td>CONSTANT_Long_info</td></tr><tr><td>6</td><td>表示8字节( double)的数值字面量</td><td>CONSTANT_Double_info</td></tr><tr><td>7</td><td>表示类成接口的符号引用</td><td>CONSTANT_Class_info</td></tr><tr><td>8</td><td>字符串类型字面量</td><td>CONSTANT_String_info</td></tr><tr><td>9</td><td>字段的<strong>符号引用</strong></td><td>CONSTANT_Fieldref_info</td></tr><tr><td>10</td><td>类中方法的<strong>符号引用</strong></td><td>CONSTANT_Methodref_info</td></tr><tr><td>11</td><td>接口中方法的<strong>符号引用</strong></td><td>CONSTANT_InterfaceMethodref_info</td></tr><tr><td>12</td><td>字段或者方法的部分<strong>符号引用</strong></td><td>CONSTANT_NameAndType_info</td></tr><tr><td>15</td><td>表示方法句柄</td><td>CONSTANT_MethodHandle_info</td></tr><tr><td>16</td><td>表示方法类型</td><td>CONSTANT_MethodType_info</td></tr><tr><td>17</td><td>表示一个动态计算常量</td><td>CONSTANT_Dynamic_info</td></tr><tr><td>18</td><td>表示动态方法调用点</td><td>CONSTANT_InvokeDynamic_info</td></tr><tr><td>19</td><td>表示一个模块</td><td>CONSTANT_Module_info</td></tr><tr><td>20</td><td>表示一个模块中开放或者导出的包</td><td>CONSTANT_Package_info</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用<code>javap -v</code>查看字节码文件。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//固定占用5字节，1字节指定tag类型为3，4字节为int二进制描述</span>CONSTANT_Integer_info<span class="token punctuation">{</span>    u1 tag<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    u4 bytes<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//固定占用5字节，1字节指定tag类型为4，4字节为float二进制描述</span>CONSTANT_Float_info<span class="token punctuation">{</span>    u1 tag<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    u4 bytes<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//固定占用9字节，1字节指定tag类型为5，后面4字节为long的高4位，再接着是long的低4位</span>CONSTANT_Long_info<span class="token punctuation">{</span>  u1 tag<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>  u4 high_bytes<span class="token punctuation">;</span>  u4 low_bytes<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//固定占用9字节，1字节指定tag类型为6，后面4字节为double的高4位，再接着是double的低4位</span>CONSTANT_Double_info<span class="token punctuation">{</span>  u1 tag<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>  u4 high_bytes<span class="token punctuation">;</span>  u4 low_bytes<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//JVM规定源文件中的所有字面量都以UTF-8编码格式存储到在class字节码文件中(包含方法名、""括起来的字符串、类名等等)</span>CONSTANT_Utf8_info<span class="token punctuation">{</span>  u1 tag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一个字节指定tag类型为1</span>  u2 length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//两个字节指定长度，所以源文件的字面量都是有长度限制的</span>  u1 bytes<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//接下来的length个长度字节承载UTF-8编码的二进制文本数据</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用双引号""括起来的字符串字面量，固定3个字节</span>CONSTANT_String_info<span class="token punctuation">{</span>  u1 tag<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一个字节指定tag类型为8</span>  u2 string_index<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//两个字节指向常量池中某个 CONSTANT_Utf8_info 项的索引</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//类名字面量，同样固定3个字节</span>CONSTANT_Class_info<span class="token punctuation">{</span>    u1 tag<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//一个字节指定tag类型为7</span>  u2 name_index<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//两个字节指向常量池中某个 CONSTANT_Utf8_info 项的索引</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对于类名字面量需要注意的：</p><ol><li><p>对于某个类而言,其class文件中至少要有两个CONSTANT_Class_info常量池项,用来表示自己的类信息和其父类信息。(除了<code>java.lang.Object</code>类除外,其他的任何类都会默认继承自<code>java.lang.Object</code>)如果类声明实现了某些接口,那么接口的信息也会生成对应的CONSTANT_Class_info常量池项。</p><p>所以对于某个类或接口而言,其自身、父类和继承或实现的接口的信息会被直接组装成CONSTANT_Class_info常量池项放置到常量池中</p></li><li><p>类中或接口中使用到了其他的类,只有在类中实际使用到了该类时,该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项; 否则Javac编译器只会将生成CONSTANT_Utf8_info而不会生成CONSTANT_Class_info</p></li></ol></blockquote><h3 id="各表结构示意"><a href="#各表结构示意" class="headerlink" title="各表结构示意"></a>各表结构示意</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120010.png" alt="image-20200921114044036"><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120016.png" alt="image-20200921114112717"><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120024.png" alt="image-20200921114153809"></p><h1 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h1><p>常量池结束之后,紧接着的2个字节(16个标志位)代表访问标志(access_flags),这个标志用于识别类或者接口层次的一些访问信息,包括:<strong>这个Class</strong>是类还是接口;是否定义为public类型;是否定义为abstract 类型;如果是类的话,是否被声明为final;等等。</p><p>access_flags中一共有16个标志位可以使用,当前只定义了其中<strong>9个</strong>,没有使用到的标志位要求一律为零：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为 public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为 final,只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用 invokespecial字节码指令的新语义, invokespecial指令的语义在JDK1.0.2发生过改变,为了区别这条指令使用哪种语义,JDK 1.0.2之后编译出来的类的这个标志都必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0X0400</td><td>是否为 abstract类型,对于接口或者抽象类来说,此标志值为真,其他类型值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0X4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE</td><td>0X8000</td><td>标识这是一个模块</td></tr></tbody></table><h1 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h1><p>类索引(this_class)和父类索引(super_class)<strong>都是一个u2类型的数据</strong>,而接口索引集合(interfaces)<strong>是一组u2类型的数据的集合</strong>,Class文件中由这三项数据来确定该类型的继承关系。</p><ol><li><strong>类索引用于确定这个类(当前Class字节码”文件”)的全限定名</strong></li><li><strong>父类索引用于确定这个类(当前Class字节码”文件”)的父类的全限定名。</strong>由于Java语言不允许多重继承,所以父类索引只有一个,除了<code>java.lang.Object</code>之外,所有的Java类都有父类,因此除了<code>java.lang.Object</code>外,所有Java类的父类索引都不为0。</li><li>接口索引集合就用来描述这个类实现了哪些接口,这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口,则应当是extends关键字)后的接口顺序从左到右排列在接口索引集合中。</li></ol><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后</p><ol><li><p>类索引和父类索引用两个u2类型的索引值表示<strong>,它们各自指向一个类型为CONSTANT_Class_info的类描述符常量,通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</strong>。</p></li><li><p>对于接口索引集合,<strong>入口的第一项u2类型的数据为接口计数器</strong>(interfaces_count),表示索引表的容量：</p><ul><li>如果该类没有实现任何接口,则该计数器值为0, 后面接口的索引表不再占用任何字节</li><li>如果该类实现了2各接口，则该计数器值为2，后面再跟两个u2类型数据存储<strong>CONSTANT_Class_info的索引</strong>。</li></ul></li></ol><h1 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h1><p>字段表(field_info)用于描述接口或者类中声明的变量。Java语言中的“字段”(Field)包括类级变量以及实例级变量,但不包括在方法内部声明的局部变量。</p><p>字段可以包括的修饰符有：</p><ol><li>字段的作用域(public、private、protected修饰符)</li><li>是实例变量还是类变量(static修饰符)</li><li>可变性(final)</li><li>并发可见性(volatile修饰符,是否强制从主内存读写)</li><li>可否被序列化(transient修饰符)</li><li>字段数据类型(基本类型、对象、数组)</li><li>字段名称</li></ol><h2 id="字段表结构"><a href="#字段表结构" class="headerlink" title="字段表结构"></a>字段表结构</h2><p>字段表集合中不会列出从父类或者父接口中继承而来的字段,但有可能出现原本Java代码之中不存在的字段,譬如在内部类中为了保持对外部类的访问性,编译器就会自动添加指向外部类实例的字段。另外,在Java语言中字段是无法重载的,两个字段的数据类型、修饰符不管是否相同,都必须使用不一样的名称,但是对于Class文件格式来讲,只要两个字段的描述符不是完全相同,那字段重名就是合法的。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h2 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table><h2 id="name-index和descriptor-index"><a href="#name-index和descriptor-index" class="headerlink" title="name_index和descriptor_index"></a>name_index和descriptor_index</h2><p>跟随access_flags标志的是两项索引值:name_index和descriptor_index。它们<strong>存储的都是常量池中某常量池项的索引值表示对其引用</strong>,分别代表着字段的简单名称以及字段和方法的描述符，概念对比：</p><ol><li><p>全限定名：”java/lang/Object;”，包名+类名以斜杠分隔并以分号结尾。</p></li><li><p>简单名称</p><ul><li>没有类型和参数修饰的方法名称</li><li>字段名称</li></ul></li><li><p>描述符</p><ul><li><p>单独作为一个”CONSTANT_Utf8_info”项描述字段的数据类型</p></li><li><p>组合<strong>多个有序</strong>的描述符以及<code>()</code>为一个”CONSTANT_Utf8_info”来描述方法的参数列表（包括数量、类型以及顺序）和返回值类型，如：<code>()Ljava/lang/String;</code>即可描述方法为无参、返回值为<code>String</code></p><blockquote><p>方法参数的类型描述符按顺序排列，完了之后才是返回值类型描述符</p></blockquote></li></ul></li></ol><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td><code>B</code></td><td>基本类型byte</td></tr><tr><td><code>C</code></td><td>基本类型char</td></tr><tr><td><code>D</code></td><td>基本类型double</td></tr><tr><td><code>F</code></td><td>基本类型float</td></tr><tr><td><code>I</code></td><td>基本类型int</td></tr><tr><td><code>J</code></td><td>基本类型long</td></tr><tr><td><code>S</code></td><td>基本类型short</td></tr><tr><td><code>Z</code></td><td>基本类型boolean</td></tr><tr><td><code>V</code></td><td>特殊类型void</td></tr><tr><td><code>L</code></td><td>后面跟一个全限定名，表示对象类型，如：Ljava/lang/Object;</td></tr><tr><td><code>[</code></td><td>数组类型,每一维度将使用一个前置的<code>[</code>字符来描述,如一个定义为<code>java.lang.String[][]</code>类型的二维数组将被记录成<code>[[Ljava/lang/String;</code>,一个整型数组<code>int[]</code>将被记录成<code>[I</code>。</td></tr></tbody></table><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>由attributes_count指定attributes项的个数，每个attributes项中包含一个CONSTANT_Utf8_info常量池项的索引，该Utf8常量表示属性的名称，另外attributes结构(属性表结构)还有其他的一些字段构成，具体参考下面的属性表介绍。</p><h1 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h1><p>与字段表集合相对应地,如果父类方法在子类中没有被重写(Override),方法表集合中就不会出现来自父类的方法信息。但同样地,有可能会出现由编译器自动添加的方法,最常见的便是类构造器<code>&lt;clinit&gt;()</code>方法和实例构造器<code>&lt;init&gt;()</code>方法。</p><h2 id="方法表结构"><a href="#方法表结构" class="headerlink" title="方法表结构"></a>方法表结构</h2><p>方法表的结构和字段表非常相似：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h2 id="Access-flags"><a href="#Access-flags" class="headerlink" title="Access_flags"></a>Access_flags</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>字段是否synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是不是由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否为native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否abstract</td></tr><tr><td>ACC_STRICT</td><td>0X0800</td><td>方法是否为strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生</td></tr></tbody></table><h2 id="属性表集合-1"><a href="#属性表集合-1" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>同字段表。</p><h1 id="属性表集合-2"><a href="#属性表集合-2" class="headerlink" title="属性表集合"></a>属性表集合</h1><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同,属性表集合的限制稍微宽松一些,不再要求各个属性表具有严格顺序,并且《Java虚拟机规范》允许只要不与已有属性名重复,任何人实现的编译器都可以向属性表中写入自己定义的属性信息,Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件,《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性,而在最新的《Java虚拟机规范》的Java SE 12版本中,预定义属性已经增加到29项。</p><p>Class文件、字段表、方法表都可以携带自己的属性表集合。</p><h2 id="常用、关键的预定义属性"><a href="#常用、关键的预定义属性" class="headerlink" title="常用、关键的预定义属性"></a>常用、关键的预定义属性</h2><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>Constantvalue</td><td>字段表</td><td>由 final关键字定义的常量值</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>被声明为 deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常列表</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性,这个属性用于标示这个类所在的外围方法</td></tr><tr><td>Innerclasses</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LinenumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalvariableTableCode</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK6中新增的属性,供新的类型检查验证器( Type Checker)检查和处理目标方法的局部变量和操作数所需要的类型是否匹配</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>JDK5中新增的属性,用于支持范型情况下的方法签名。在Java语言中,任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(TypeVariables)或参数化类型( Parameterized Types则Signature属性会为它记录泛型签名信息。由于Java 的范型采用擦除法实现,为了避免类型信息被擦除后导致签名混乱,需要这个属性记录范型中的相关信息</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>JDK5中新增的属性,用于存储额外的调试信息譬如在进行JSP文件调试时,无法通过Java堆栈来定位到JSP文件的行号,JSR45提案为这些非Java 语言编写,却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制,使用该属性就可以用于存储这个标准所新加入的调试信息</td></tr><tr><td>Synthetic</td><td>类、方法表、字段表</td><td>标识方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>JDK5中新增的属性,它使用特征签名代替描述符,是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK5中新增的属性,为动态注解提供支持。该属性用于指明哪些注解是运行时(实际上运行时就是进行反射调用)可见的</td></tr><tr><td>RuntimelnvisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK5中新增的属性,与 RuntimeVisibleAnnotations 属性作用刚好相反,用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotations</td><td>方法表</td><td>JDK5中新增的属性,作用与 RuntimeVisibleAnotations 属性类似,只不过作用对象为方法参数</td></tr><tr><td>RuntimelnvisibleParameterAnnotations</td><td>方法表</td><td>JDK5中新增的属性,作用与 RuntimelnvisibleAnnotations 属性类似,只不过作用对象为方法参数</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>JDK5中新增的属性,用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>JDK7中新增的属性,用于保存 invokedynamic指令引用的引导方法限定符</td></tr><tr><td>RuntimeVisibleTypeAnnotations</td><td>类、方法表、字段表、Code属性</td><td>JDK8中新增的属性,为实现JSR308中新增的类型注解提供的支持,用于指明哪些类注解是运行时(实际上运行时就是进行反射调用)可见的</td></tr><tr><td>RuntimelnvisibleTypeAnnotations</td><td>类、方法表、字段表、Code属性</td><td>JDK8中新增的属性,为实现JSR308中新增的类型注解提供的支持,与 RuntimeVisibleTypeAnntations 属性作用刚好相反,用于指明哪些注解是运行时不可见的</td></tr><tr><td>MethodParameters</td><td>方法表</td><td>JDK8中新增的属性,用于支持(编译时加上 -parameters参数)将方法名称编译进 Class文件中, 并可运行时获取。此前要获取方法名称(典型的如IDE的代码提示)只能通过 Javadoc中得到</td></tr><tr><td>Module</td><td>类</td><td>JDK9中新增的属性,用于记录一个 的名Module 称以及相关信息( requires、 exports, opens、uses provides)</td></tr><tr><td>ModulePackages</td><td>类</td><td>JDK9中新增的属性,用于记录一个模块中所有被 exports I或者 opens的包</td></tr><tr><td>ModuleMainClass</td><td>类</td><td>JDK9中新增的属性,用于指定一个模块的主类</td></tr><tr><td>NestHost</td><td>类</td><td>JDK11中新增的属性,用于支持嵌套类(Java中的内部类)的反射和访问控制的API,一个内部类通过该属性得知自己的宿主类</td></tr><tr><td>NestMembers</td><td>类</td><td>JDK11中新增的属性,用于支持嵌套类(Java中 的内部类)的反射和访问控制的API,一个宿主类通过该属性得知自己有哪些内部类</td></tr></tbody></table><h2 id="属性表结构"><a href="#属性表结构" class="headerlink" title="属性表结构"></a>属性表结构</h2><p>对于每一个属性项,它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示, 而<strong>属性值的结构则是完全自定义的</strong>,根据具体的属性信息有不一样的结构,只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>具体的属性类型</td><td>attribute_info</td><td>attribute_length</td></tr></tbody></table><p>attribute_length表示attribute_info的长度，所以：<code>attribute_length值=整个属性表的长度 - 6</code>。</p><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>Java程序方法体里面的代码经过Javac编译器处理之后,最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中,但并非所有的方法表都必须存在这个属性,譬如接口或者抽象类中的方法就不存在Code属性。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>max_stack</td><td>1</td></tr><tr><td>u2</td><td>max_locaIs</td><td>1</td></tr><tr><td>u4</td><td>code_length</td><td>1</td></tr><tr><td>u1</td><td>code</td><td>code_length</td></tr><tr><td>u2</td><td>exception_table_length</td><td>1</td></tr><tr><td>exception_info</td><td>exception_table</td><td>exception_table_length</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><ul><li><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引,此常量值固定为“Code”</p></li><li><p>attribute_length指示了属性值的长度</p></li><li><p>max_stack代表了操作数栈(Operand Stack)深度的最大值</p></li><li><p>max_locals代表了局部变量表所需的存储空间。在这里,max_locals的单位是变量槽(Slot),变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型,每个局部变量占用一个变量槽,而double和long这两种64 位的数据类型则需要两个变量槽来存放。方法参数(<strong>包括实例方法中的隐藏参数“this”</strong>)、显式异常处理程序的参数(Exception Handler Parameter,就是try-catch语句中catch块中所定义的异常)、方法体中定义的局部变量都需要依赖局部变量表来存放。注意,并不是在方法中用了多少个局部变量,就把这些局部变量所占变量槽数量之和作为max_locals的值,操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存,不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用,当代码执行超出一个局部变量的作用域时,这个局部变量所占的变量槽可以被其他局部变量所使用,Javac编译器会根据变量的作用域来分配变量槽给各个变量使用,根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</p></li><li><p>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度, code是用于存储字节码指令的一系列字节流。<strong>既然叫字节码指令,那顾名思义每个指令就是一个u1类型的单字节</strong>,当虚拟机读取到code中的一个字节码时,就可以对应找出这个字节码代表的是什么指令,并且可以知道这条指令后面是否需要跟随参数,以及后续的参数应当如何解析。我们知道一个u1 数据类型的取值范围为0x00<del>0xFF,对应十进制的0</del>255,也就是一共可以表达256条指令。目前, 《Java虚拟机规范》已经定义了其中约200条编码值对应的指令含义。</p><p>关于code_length,有一件值得注意的事情,虽然它是一个u4类型的长度值,理论上最大值可以达到2的32次幂,但是《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令</p></li><li><p>exception_table_length和exception_table用来存储异常表，非必须，异常表结构如下：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>end_pc</td><td>1</td></tr><tr><td>u2</td><td>handler_pc</td><td>1</td></tr><tr><td>u2</td><td>catch_type</td><td>1</td></tr></tbody></table><p>如果当字节码从第start_pc行到第end_pc行之间(不含第end_pc行)出现了类型为catch_type或者其子类的异常(catch_type为指向一个CONSTANT_Class_info型常量的索引),则转到第handler_pc行继续处理。当catch_type的值为0时,代表任意异常情况都需要转到handler_pc处进行处理。</p><p>异常表实际上是Java代码的一部分,尽管字节码中有最初为处理异常而设计的跳转指令,但《Java 虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及<strong>finally处理机制</strong>。</p><p>例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码会生成三个异常表：</p><ul><li>如果try语句块中出现属于Exception或其子类的异常,转到catch语句块处理; </li><li>如果try语句块中出现不属于Exception或其子类的异常,转到finally语句块处理; </li><li>如果catch语句块中出现任何异常,转到finally语句块处理</li></ul></li></ul><h3 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h3><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性,不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常(Checked Excepitons),也就是方法描述时在throws关键字后面列举的异常。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_exceptions</td><td>1</td></tr><tr><td>u2</td><td>exception_index_table</td><td>number_of_exception</td></tr></tbody></table><p>此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常,每一种受查异常使用一个exception_index_table项表示;exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引,代表了该受查异常的类型。</p><h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>LineNumberTable属性用于描述Java源码行号与字节码行号(字节码的偏移量)之间的对应关系。</p><p>它并不是运行时必需的属性,但默认会生成到Class文件之中,可以在Javac中使用-g:none或-g:lines 选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性,对程序运行产生的最主要影响就是当抛出异常时,堆栈中将不会显示出错的行号,并且在调试程序的时候,也无法按照源码行来设置断点。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>line_number_table_length</td><td>1</td></tr><tr><td>line_number_info</td><td>line_number_table</td><td>line_number_table_length</td></tr></tbody></table><p>line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合, line_number_info表包含start_pc和line_number两个u2类型的数据项,前者是字节码行号,后者是Java源码行号。</p><h3 id="LocalVariableTable及LocalVariableTypeTable属性"><a href="#LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable及LocalVariableTypeTable属性"></a>LocalVariableTable及LocalVariableTypeTable属性</h3><p>它是Code属性的子属性。LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系,它也不是运行时必需的属性,但默认会生成到Class文件之中,可以在Javac中使用-g:none或-g:vars选项来取消或要求生成这项信息。如果没有生成这项属性,最大的影响就是当其他人引用这个方法时,所有的参数名称都将会丢失,譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名,这对程序运行没有影响,但是会对代码编写带来较大不便,而且在调试期间无法根据参数名称从上下文中获得参数值。</p><h4 id="LocalVariableTable结构"><a href="#LocalVariableTable结构" class="headerlink" title="LocalVariableTable结构"></a>LocalVariableTable结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>local_variable_table_length</td><td>1</td></tr><tr><td>local_variable_info</td><td>local_variable_table</td><td>local_variable_table_length</td></tr></tbody></table><h4 id="local-variable-info结构"><a href="#local-variable-info结构" class="headerlink" title="local_variable_info结构"></a>local_variable_info结构</h4><p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>start_pc</td><td>1</td></tr><tr><td>u2</td><td>length</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>index</td><td>1</td></tr></tbody></table><ul><li>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度,两者结合起来就是这个局部变量在字节码之中的作用域范围。</li><li>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引,分别代表了局部变量的名称以及这个局部变量的描述符。</li><li>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时(double和long),它占用的变量槽为index和index+1两个。</li></ul><h4 id="LocalVariableTypeTable"><a href="#LocalVariableTypeTable" class="headerlink" title="LocalVariableTypeTable"></a>LocalVariableTypeTable</h4><p>在JDK 5引入泛型之后,LocalVariableTable属性增加了一个“姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalV ariableTable非常相似,仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名(Signature)。对于非泛型类型来说,描述符和特征签名能描述的信息是能吻合一致的,但是泛型引入之后,由于描述符中泛型的参数化类型被擦除掉,描述符就不能准确描述泛型类型了。因此出现了LocalV ariableTypeTable属性,使用字段的特征签名来完成泛型的描述。</p><h3 id="SourceFile及SourceDebugExtension属性"><a href="#SourceFile及SourceDebugExtension属性" class="headerlink" title="SourceFile及SourceDebugExtension属性"></a>SourceFile及SourceDebugExtension属性</h3><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的,可以使用Javac 的-g:none或-g:source选项来关闭或要求生成这项信息。在Java中,对于大多数的类来说,类名和文件名是一致的,但是有一些特殊情况(如内部类)例外。如果不生成这项属性,当抛出异常时,堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性</p><h4 id="SourceFile属性结构"><a href="#SourceFile属性结构" class="headerlink" title="SourceFile属性结构"></a>SourceFile属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>sourcefile_index</td><td>1</td></tr></tbody></table><p>sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引,常量值是源码文件的文件名。</p><h4 id="SourceDebugExtension"><a href="#SourceDebugExtension" class="headerlink" title="SourceDebugExtension"></a>SourceDebugExtension</h4><p>为了方便在编译器和动态生成的Class中加入供程序员使用的自定义内容,在JDK 5时,新增了SourceDebugExtension属性用于存储额外的代码调试信息。典型的场景是在进行JSP文件调试时,无法通过Java堆栈来定位到JSP文件的行号。JSR 45提案为这些非Java语言编写,却需要编译成字节码并运行在Java虚拟机中的程序提供了一个进行调试的标准机制,使用SourceDebugExtension属性就可以用于存储这个标准所新加入的调试信息,譬如让程序员能够快速从异常堆栈中定位出原始JSP中出现问题的行号。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>debug_extension[attribute_length]</td><td>1</td></tr></tbody></table><p>其中debug_extension存储的就是额外的调试信息,是一组通过变长UTF-8格式来表示的字符串。一个类中最多只允许存在一个SourceDebugExtension属性。</p><h3 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h3><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量(类变量)才可以使用这项属性。</p><p>类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情,但虚拟机对这两种变量赋值的方式和时刻都有所不同。</p><ul><li>对非static类型的变量(也就是实例变量)的赋值是在<code>&lt;init&gt;()</code>方法中进行的;</li><li>而对于类变量,则有两种方式可以选择:<ul><li>在<code>&lt;clinit&gt;()</code>方法中或者使用ConstantValue属性。目前Oracle公司实现的Javac编译器的选择是,如果同时使用final和static来修饰一个变量(按照习惯,这里称“常量”更贴切),并且这个变量的数据类型是基本类型或者<code>java.lang.String</code>的话,就将会生成ConstantValue属性来进行初始化;</li><li>如果这个变量没有被final修饰,或者并非基本类型及字符串,则将会选择在<code>&lt;clinit&gt;()</code>方法中进行初始化。</li></ul></li></ul><p>虽然有final关键字才更符合“ConstantValue”的语义,但《Java虚拟机规范》中并没有强制要求字段必须设置ACC_FINAL标志,只要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已,<strong>对final关键字的要求是Javac编译器自己加入的限制</strong>。</p><p>而对ConstantValue的属性值只能限于基本类型和String这点,其实并不能算是什么限制,这是理所当然的结果。因为此属性的属性值只是一个常量池的索引号,由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量,所以就算ConstantValue属性想支持别的类型也无能为力。</p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>constantvalue_index</td><td>1</td></tr></tbody></table><p>从数据结构中可以看出ConstantValue属性是一个定长属性,它的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用,根据字段类型的不同,字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</p><h3 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h3><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类,那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><h4 id="InnerClasses属性结构"><a href="#InnerClasses属性结构" class="headerlink" title="InnerClasses属性结构"></a>InnerClasses属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_class</td><td>1</td></tr><tr><td>inner_class_info</td><td>inner_classes</td><td>number_of_class</td></tr></tbody></table><p>数据项number_of_classes代表需要记录多少个内部类信息,每一个内部类的信息都由一个inner_classes_info表进行描述。</p><h4 id="inner-classes-info结构"><a href="#inner-classes-info结构" class="headerlink" title="inner_classes_info结构"></a>inner_classes_info结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>inner_class_info_index</td><td>1</td></tr><tr><td>u2</td><td>outer_class_info_index</td><td>1</td></tr><tr><td>u2</td><td>inner_name_index</td><td>1</td></tr><tr><td>u2</td><td>inner_class_access_flags</td><td>1</td></tr></tbody></table><ul><li>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引,分别代表了内部类和宿主类的符号引用。</li><li>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引,代表这个内部类的名称, 如果是匿名内部类,这项值为0。</li><li>inner_class_access_flags是内部类的访问标志,类似于类的access_flags,它的取值范围如下<table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>内部类是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>内部类是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>内部类是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>内部类是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>内部类是否为final</td></tr><tr><td>ACC_INTERFACE</td><td>0x0020</td><td>内部类是否为接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>内部类是否为abstract</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>内部类是否并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>内部类是不是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>内部类是不是一个枚举</td></tr></tbody></table></li></ul><h3 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h3><p>Deprecated和Synthetic两个属性都属于标志类型的布尔属性,只存在有和没有的区别,没有属性值的概念。<br>Deprecated属性用于表示某个类、字段或者方法,已经被程序作者定为不再推荐使用,它可以通过代码中使用“@deprecated”注解进行设置。<br>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的,而是由编译器自行添加的,在JDK 5之后,标识一个类、字段或者方法是编译器自动产生的,也可以设置它们访问标志中的ACC_SYNTHETIC标志位。编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式,实现了越权访问(越过private修饰器)或其他绕开了语言限制的功能,这可以算是一种早期优化的技巧,其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法(Bridge Method)。所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项,唯一的例外是<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法。</p><h4 id="Deprecated和Synthetic属性的结构"><a href="#Deprecated和Synthetic属性的结构" class="headerlink" title="Deprecated和Synthetic属性的结构"></a>Deprecated和Synthetic属性的结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr></tbody></table><p>其中attribute_length数据项的值必须为0x00000000,因为没有任何属性值需要设置。</p><h3 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h3><p>StackMapTable属性在JDK 6增加到Class文件规范之中,它是一个相当复杂的变长属性,位于Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器(Type Checker)使用,目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><h4 id="StackMapTable属性结构"><a href="#StackMapTable属性结构" class="headerlink" title="StackMapTable属性结构"></a>StackMapTable属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>number_of_entries</td><td>1</td></tr><tr><td>stack_map_frame</td><td>stack_map_frame_entries</td><td>number_of_entries</td></tr></tbody></table><p>StackMapTable属性中包含零至多个栈映射帧(Stack Map Frame),每个栈映射帧都显式或隐式地代表了一个字节码偏移量,用于表示执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p><h3 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h3><p>Signature属性在JDK 5增加到Class文件规范之中,它是一个可选的定长属性,可以出现于类、字段表和方法表结构的属性表中。在JDK 5里面大幅增强了Java语言的语法,在此之后,任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variable)或参数化类型(Parameterized Type),则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型,是因为Java语言的泛型采用的是擦除法实现的伪泛型,字节码(Code属性)中所有的泛型信息编译(类型变量、参数化类型)在编译之后都通通被擦除掉。使用擦除法的好处是实现简单(主要修改Javac编译器,虚拟机内部只做了很少的改动)、非常容易实现Backport,运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样,将泛型类型与用户定义的普通类型同等对待,例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的,现在Java的反射API能够获取的泛型类型,最终的数据来源也是这个属性。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>singnature_index</td><td>1</td></tr></tbody></table><p>其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构,表示类签名或方法类型签名或字段类型签名。如果当前的Signature属性是类文件的属性,则这个结构表示类签名,如果当前的Signature属性是方法表的属性,则这个结构表示方法类型签名,如果当前Signature属性是字段表的属性,则这个结构表示字段类型签名。</p><h3 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h3><p>BootstrapMethods属性在JDK 7时增加到Class文件规范之中,它是一个复杂的变长属性,位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。<br>根据《Java虚拟机规范》(从Java SE 7版起)的规定,如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量,那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性,另外,即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次,类文件的属性表中最多也只能有一个BootstrapMethods属性。BootstrapMethods属性和JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切,要介绍这个属性的作用,必须先讲清楚InovkeDynamic指令的运作原理。</p><p>虽然JDK 7中已经提供了InovkeDynamic指令,但这个版本的Javac编译器还暂时无法支持InvokeDynamic指令和生成BootstrapMethods属性,必须通过一些非常规的手段才能使用它们。直到JDK 8中Lambda表达式和接口默认方法的出现,InvokeDynamic指令才算在Java语言生成的Class文件中有了用武之地。</p><h4 id="BootstrapMethods属性结构"><a href="#BootstrapMethods属性结构" class="headerlink" title="BootstrapMethods属性结构"></a>BootstrapMethods属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>num_bootstrap_methods</td><td>1</td></tr><tr><td>bootstrap_method</td><td>bootstrap_methods</td><td>num_bootstrap_methods</td></tr></tbody></table><h4 id="boostrap-method结构"><a href="#boostrap-method结构" class="headerlink" title="boostrap_method结构"></a>boostrap_method结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>bootstrap_method_ref</td><td>1</td></tr><tr><td>u2</td><td>num_bootstrap_arguments</td><td>1</td></tr><tr><td>u2</td><td>bootstrap_arguments</td><td>num_boostrap_arguments</td></tr></tbody></table><p>BootstrapMethods属性里,num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。而bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值,它代表了一个引导方法。还包含了这个引导方法静态参数的序列(可能为空)。bootstrap_methods[]数组的每个成员必须包含以下三项内容: </p><ul><li>bootstrap_method_ref:bootstrap_method_ref项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</li><li>num_bootstrap_arguments:num_bootstrap_arguments项的值给出了bootstrap_argu-ments[]数组成员的数量。</li><li>bootstrap_arguments[]:bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效索引。</li></ul><p>常量池在该索引处必须是下列结构之一：</p><ul><li>CONSTANT_String_info</li><li>CONSTANT_Class_info</li><li>CONSTANT_Integer_info</li><li>CONSTANT_Long_info</li><li>CONSTANT_Float_info</li><li>CONSTANT_Double_info</li><li>CONSTANT_MethodHandle_info</li><li>CONSTANT_MethodType_info</li></ul><h3 id="MethodParameters属性"><a href="#MethodParameters属性" class="headerlink" title="MethodParameters属性"></a>MethodParameters属性</h3><p>MethodParameters是在JDK 8时新加入到Class文件格式中的,它是一个用在方法表中的变长属性。</p><p>MethodParameters的作用是记录方法的各个形参名称和信息。</p><p>最初,基于存储空间的考虑,Class文件默认是不储存方法参数名称的,因为给参数起什么名字对计算机执行程序来说是没有任何区别的,所以只要在源码中妥当命名就可以了。随着Java的流行,这点确实为程序的传播和二次复用带来了诸多不便,由于Class文件中没有参数的名称,如果只有单独的程序包而不附加上JavaDoc的话,在IDE中编辑使用包里面的方法时是无法获得方法调用的智能提示的,这就阻碍了JAR包的传播。后来,“-g:var”就成为了Javac以及许多IDE编译Class时采用的默认值,这样会将方法参数的名称生成到LocalV ariableTable属性之中。不过此时问题仍然没有全部解决, LocalVariableTable属性是Code属性的子属性——没有方法体存在,自然就不会有局部变量表,但是对于其他情况,譬如抽象方法和接口方法,是理所当然地可以不存在方法体的,对于方法签名来说,还是没有找到一个统一完整的保留方法参数名称的地方。所以JDK 8中新增的这个属性,使得编译器可以(编译时加上-parameters参数)将方法名称也写进Class文件中,而且MethodParameters是方法表的属性,与Code属性平级的,可以运行时通过反射API获取。</p><h4 id="属性结构-1"><a href="#属性结构-1" class="headerlink" title="属性结构"></a>属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>parameters_count</td><td>1</td></tr><tr><td>parameter</td><td>parameters</td><td>parameters_count</td></tr></tbody></table><h4 id="parameter结构"><a href="#parameter结构" class="headerlink" title="parameter结构"></a>parameter结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr></tbody></table><p>其中,name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值,代表了该参数的名称。而access_flags是参数的状态指示器,它可以包含以下三种状态中的一种或多种:</p><ul><li>0x0010(ACC_FINAL):表示该参数被final修饰。</li><li>0x1000(ACC_SYNTHETIC):表示该参数并未出现在源文件中,是编译器自动生成的。</li><li>0x8000(ACC_MANDATED):表示该参数是在源文件中隐式定义的。Java语言中的典型场景是this关键字。</li></ul><h3 id="模块化相关属性"><a href="#模块化相关属性" class="headerlink" title="模块化相关属性"></a>模块化相关属性</h3><p>JDK 9的一个重量级功能是Java的模块化功能,因为模块描述文件(module-info.java)最终是要编译成一个独立的Class文件来存储的,所以,Class文件格式也扩展了Module、ModulePackages和ModuleMainClass三个属性用于支持Java模块化相关功能。</p><h4 id="Module属性"><a href="#Module属性" class="headerlink" title="Module属性"></a>Module属性</h4><p>Module属性是一个非常复杂的变长属性,除了表示该模块的名称、版本、标志信息以外,还存储了这个模块requires、exports、opens、uses和provides定义的全部内容。</p><h5 id="属性结构-2"><a href="#属性结构-2" class="headerlink" title="属性结构"></a>属性结构</h5><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>module_name_index</td><td>1</td></tr><tr><td>u2</td><td>module_flags</td><td>1</td></tr><tr><td>u2</td><td>module_version_index</td><td>1</td></tr><tr><td>u2</td><td>requires_count</td><td>1</td></tr><tr><td>require</td><td>requires</td><td>requires_count</td></tr><tr><td>u2</td><td>exports_count</td><td>1</td></tr><tr><td>export</td><td>exports</td><td>exports_count</td></tr><tr><td>u2</td><td>opens_count</td><td>1</td></tr><tr><td>open</td><td>opens</td><td>opens_count</td></tr><tr><td>u2</td><td>uses_count</td><td>1</td></tr><tr><td>use</td><td>uses_index</td><td>uses_count</td></tr><tr><td>u2</td><td>provides_count</td><td>1</td></tr><tr><td>provide</td><td>provides</td><td>provides_count</td></tr></tbody></table><ul><li><p>其中,module_name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值,代表了该模块的名称。而module_flags是模块的状态指示器,它可以包含以下三种状态中的一种或多种:</p><ul><li>0x0020(ACC_OPEN):表示该模块是开放的。</li><li>0x1000(ACC_SYNTHETIC):表示该模块并未出现在源文件中,是编译器自动生成的。</li><li>0x8000(ACC_MANDATED):表示该模块是在源文件中隐式定义的。</li></ul></li><li><p>module_version_index是一个指向常量池CONSTANT_Utf8_info常量的索引值,代表了该模块的版本号。</p></li><li><p>后续的几个属性分别记录了模块的requires、exports、opens、uses和provides定义。它们的结构是基本相似的</p></li></ul><h6 id="示例：export属性结构"><a href="#示例：export属性结构" class="headerlink" title="示例：export属性结构"></a>示例：export属性结构</h6><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>exports_index</td><td>1</td></tr><tr><td>u2</td><td>exports_flags</td><td>1</td></tr><tr><td>u2</td><td>exports_to_count</td><td>1</td></tr><tr><td>export</td><td>exports_to_index</td><td>exports_to_count</td></tr></tbody></table><p>exports属性的每一元素都代表一个被模块所导出的包</p><ul><li>exports_index是一个指向常量池CONSTANT_Package_info常量的索引值,代表了被该模块导出的包</li><li>exports_flags是该导出包的状态指示器,它可以包含以下两种状态中的一种或多种:<ul><li>0x1000(ACC_SYNTHETIC):表示该导出包并未出现在源文件中,是编译器自动生成的。</li><li>0x8000(ACC_MANDATED):表示该导出包是在源文件中隐式定义的。</li></ul></li><li>exports_to_count是该导出包的限定计数器,如果这个计数器为零,这说明该导出包是无限定的(Unqualified),即完全开放的,任何其他模块都可以访问该包中所有内容。如果该计数器不为零, 则后面的exports_to_index是以计数器值为长度的数组,每个数组元素都是一个指向常量池中CONSTANT_Module_info常量的索引值,代表着只有在这个数组范围内的模块才被允许访问该导出包的内容。</li></ul><h4 id="ModulePackages属性"><a href="#ModulePackages属性" class="headerlink" title="ModulePackages属性"></a>ModulePackages属性</h4><p>一个用于支持Java模块化的变长属性,它用于描述该模块中所有的包,不论是不是被export或者open的。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>package_count</td><td>1</td></tr><tr><td>u2</td><td>package_index</td><td>package_count</td></tr></tbody></table><p>package_count是package_index数组的计数器,package_index中每个元素都是指向常量池CONSTANT_Package_info常量的索引值,代表了当前模块中的一个包。</p><h4 id="ModuleMainClass属性结构"><a href="#ModuleMainClass属性结构" class="headerlink" title="ModuleMainClass属性结构"></a>ModuleMainClass属性结构</h4><p>一个定长属性,用于确定该模块的主类(Main Class)</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>main_class_index</td><td>1</td></tr></tbody></table><p>其中,main_class_index是一个指向常量池CONSTANT_Class_info常量的索引值,代表了该模块的主类。</p><h3 id="运行时注解相关属性"><a href="#运行时注解相关属性" class="headerlink" title="运行时注解相关属性"></a>运行时注解相关属性</h3><p>早在JDK 5时期,Java语言的语法进行了多项增强,其中之一是提供了对注解(Annotation)的支持。为了存储源码中注解信息,Class文件同步增加了：</p><ul><li>RuntimeVisibleAnnotations</li><li>RuntimeInvisibleAnnotations</li><li>RuntimeVisibleParameterAnnotations</li><li>RuntimeInvisibleParameterAnnotations</li></ul><p>四个属性。到了JDK 8时期,进一步加强了Java语言的注解使用范围,又新增类型注解(JSR 308),所以Class文件中也同步增加了：</p><ul><li>RuntimeVisibleTypeAnnotations</li><li>RuntimeInvisibleTypeAnnotations</li></ul><p>两个属性。由于这六个属性不论结构还是功能都比较雷同,因此把它们合并到一起,以RuntimeVisibleAnnotations为代表进行介绍。</p><p>RuntimeVisibleAnnotations是一个变长属性,它记录了类、字段或方法的声明上记录运行时可见注解,当我们使用反射API来获取类、字段或方法上的注解时,返回值就是通过这个属性来取到的。</p><h4 id="RuntimeVisibleAnnotations属性结构"><a href="#RuntimeVisibleAnnotations属性结构" class="headerlink" title="RuntimeVisibleAnnotations属性结构"></a>RuntimeVisibleAnnotations属性结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u2</td><td>num_annotations</td><td>1</td></tr><tr><td>annotation</td><td>annotations</td><td>num_annotations</td></tr></tbody></table><p>num_annotations是annotations数组的计数器,annotations中每个元素都代表了一个运行时可见的注解,注解在Class文件中以annotation结构来存储</p><h4 id="annotation结构"><a href="#annotation结构" class="headerlink" title="annotation结构"></a>annotation结构</h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>type_index</td><td>1</td></tr><tr><td>u2</td><td>num_element_value_paires</td><td>1</td></tr><tr><td>element_value_pair</td><td>element_value_paires</td><td>num_element_value_paires</td></tr></tbody></table><p>type_index是一个指向常量池CONSTANT_Utf8_info常量的索引值,该常量应以字段描述符的形式表示一个注解。num_element_value_pairs是element_value_pairs数组的计数器,element_value_pairs中每个元素都是一个键值对,代表该注解的参数和值。</p><h1 id="Class文件结构解析及示例"><a href="#Class文件结构解析及示例" class="headerlink" title="Class文件结构解析及示例"></a>Class文件结构解析及示例</h1><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/10 17:14 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ClassLoader systemClassLoader <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        ClassLoader parent <span class="token operator">=</span> systemClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sun.misc.Launcher$ExtClassLoader@4dc63996</span>        ClassLoader boostrap <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>boostrap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//null</span>        ClassLoader classLoader <span class="token operator">=</span> ClassLoaderTest1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        ClassLoader strClassLoader <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//null</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>javap工具生成非正式的”虚拟机汇编语言”(方法中的代码转成jvm指令集中指令的”Java的汇编形式”)，格式如下：<code>&lt;index&gt;&lt;opcode&gt;[&lt;operand1&gt;[&lt;operand2&gt;...]][&lt;comment&gt;]</code></p><ol><li><code>&lt;index&gt;</code>是指令操作码在数组中的下标，该数组以字节形式来存储当前方法的Java虚拟机代码；也可以是相对于方法起始处的字节偏移量</li><li><code>&lt;opcode&gt;</code>是指令的助记码，<code>&lt;operand&gt;</code>是操作数、<code>&lt;comment&gt;</code>是行尾的注释</li></ol><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon classloader % javap -v ./ClassLoaderTest1.class <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java">Classfile <span class="token operator">/</span>Users<span class="token operator">/</span>zhonghongpeng<span class="token operator">/</span>IdeaProjects<span class="token operator">/</span>tech<span class="token operator">-</span>learning<span class="token operator">/</span>jvm<span class="token operator">/</span>target<span class="token operator">/</span>classes<span class="token operator">/</span>john<span class="token operator">/</span>classloader<span class="token operator">/</span>ClassLoaderTest1<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token class-name">Last</span> modified <span class="token number">2020</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span> size <span class="token number">988</span> bytes  MD5 checksum 2a924364f2c3f7e3670c6bba0d4fb145  Compiled from <span class="token string">"ClassLoaderTest1.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">john<span class="token punctuation">.</span>classloader<span class="token punctuation">.</span>ClassLoaderTest1</span>  minor version<span class="token operator">:</span> <span class="token number">0</span>  major version<span class="token operator">:</span> <span class="token number">52</span>  flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_SUPERConstant pool<span class="token operator">:</span>   #<span class="token number">1</span> <span class="token operator">=</span> Methodref          #<span class="token number">9</span><span class="token punctuation">.</span>#<span class="token number">29</span>         <span class="token comment" spellcheck="true">// java/lang/Object."&lt;init>":()V</span>   #<span class="token number">2</span> <span class="token operator">=</span> Methodref          #<span class="token number">30</span><span class="token punctuation">.</span>#<span class="token number">31</span>        <span class="token comment" spellcheck="true">// java/lang/ClassLoader.getSystemClassLoader:()Ljava/lang/ClassLoader;</span>   #<span class="token number">3</span> <span class="token operator">=</span> Fieldref           #<span class="token number">32</span><span class="token punctuation">.</span>#<span class="token number">33</span>        <span class="token comment" spellcheck="true">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="token number">4</span> <span class="token operator">=</span> Methodref          #<span class="token number">34</span><span class="token punctuation">.</span>#<span class="token number">35</span>        <span class="token comment" spellcheck="true">// java/io/PrintStream.println:(Ljava/lang/Object;)V</span>   #<span class="token number">5</span> <span class="token operator">=</span> Methodref          #<span class="token number">30</span><span class="token punctuation">.</span>#<span class="token number">36</span>        <span class="token comment" spellcheck="true">// java/lang/ClassLoader.getParent:()Ljava/lang/ClassLoader;</span>   #<span class="token number">6</span> <span class="token operator">=</span> Class              #<span class="token number">37</span>            <span class="token comment" spellcheck="true">// john/classloader/ClassLoaderTest1</span>   #<span class="token number">7</span> <span class="token operator">=</span> Methodref          #<span class="token number">38</span><span class="token punctuation">.</span>#<span class="token number">39</span>        <span class="token comment" spellcheck="true">// java/lang/Class.getClassLoader:()Ljava/lang/ClassLoader;</span>   #<span class="token number">8</span> <span class="token operator">=</span> Class              #<span class="token number">40</span>            <span class="token comment" spellcheck="true">// java/lang/String</span>   #<span class="token number">9</span> <span class="token operator">=</span> Class              #<span class="token number">41</span>            <span class="token comment" spellcheck="true">// java/lang/Object</span>  #<span class="token number">10</span> <span class="token operator">=</span> Utf8               <span class="token operator">&lt;</span>init<span class="token operator">></span>  #<span class="token number">11</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">)</span>V  #<span class="token number">12</span> <span class="token operator">=</span> Utf8               Code  #<span class="token number">13</span> <span class="token operator">=</span> Utf8               LineNumberTable  #<span class="token number">14</span> <span class="token operator">=</span> Utf8               LocalVariableTable  #<span class="token number">15</span> <span class="token operator">=</span> Utf8               <span class="token keyword">this</span>  #<span class="token number">16</span> <span class="token operator">=</span> Utf8               Ljohn<span class="token operator">/</span>classloader<span class="token operator">/</span>ClassLoaderTest1<span class="token punctuation">;</span>  #<span class="token number">17</span> <span class="token operator">=</span> Utf8               main  #<span class="token number">18</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V  #<span class="token number">19</span> <span class="token operator">=</span> Utf8               args  #<span class="token number">20</span> <span class="token operator">=</span> Utf8               <span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span>  #<span class="token number">21</span> <span class="token operator">=</span> Utf8               systemClassLoader  #<span class="token number">22</span> <span class="token operator">=</span> Utf8               Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span>  #<span class="token number">23</span> <span class="token operator">=</span> Utf8               parent  #<span class="token number">24</span> <span class="token operator">=</span> Utf8               boostrap  #<span class="token number">25</span> <span class="token operator">=</span> Utf8               classLoader  #<span class="token number">26</span> <span class="token operator">=</span> Utf8               strClassLoader  #<span class="token number">27</span> <span class="token operator">=</span> Utf8               SourceFile  #<span class="token number">28</span> <span class="token operator">=</span> Utf8               ClassLoaderTest1<span class="token punctuation">.</span>java  #<span class="token number">29</span> <span class="token operator">=</span> NameAndType        #<span class="token number">10</span><span class="token operator">:</span>#<span class="token number">11</span>        <span class="token comment" spellcheck="true">// "&lt;init>":()V</span>  #<span class="token number">30</span> <span class="token operator">=</span> Class              #<span class="token number">42</span>            <span class="token comment" spellcheck="true">// java/lang/ClassLoader</span>  #<span class="token number">31</span> <span class="token operator">=</span> NameAndType        #<span class="token number">43</span><span class="token operator">:</span>#<span class="token number">44</span>        <span class="token comment" spellcheck="true">// getSystemClassLoader:()Ljava/lang/ClassLoader;</span>  #<span class="token number">32</span> <span class="token operator">=</span> Class              #<span class="token number">45</span>            <span class="token comment" spellcheck="true">// java/lang/System</span>  #<span class="token number">33</span> <span class="token operator">=</span> NameAndType        #<span class="token number">46</span><span class="token operator">:</span>#<span class="token number">47</span>        <span class="token comment" spellcheck="true">// out:Ljava/io/PrintStream;</span>  #<span class="token number">34</span> <span class="token operator">=</span> Class              #<span class="token number">48</span>            <span class="token comment" spellcheck="true">// java/io/PrintStream</span>  #<span class="token number">35</span> <span class="token operator">=</span> NameAndType        #<span class="token number">49</span><span class="token operator">:</span>#<span class="token number">50</span>        <span class="token comment" spellcheck="true">// println:(Ljava/lang/Object;)V</span>  #<span class="token number">36</span> <span class="token operator">=</span> NameAndType        #<span class="token number">51</span><span class="token operator">:</span>#<span class="token number">44</span>        <span class="token comment" spellcheck="true">// getParent:()Ljava/lang/ClassLoader;</span>  #<span class="token number">37</span> <span class="token operator">=</span> Utf8               john<span class="token operator">/</span>classloader<span class="token operator">/</span>ClassLoaderTest1  #<span class="token number">38</span> <span class="token operator">=</span> Class              #<span class="token number">52</span>            <span class="token comment" spellcheck="true">// java/lang/Class</span>  #<span class="token number">39</span> <span class="token operator">=</span> NameAndType        #<span class="token number">53</span><span class="token operator">:</span>#<span class="token number">44</span>        <span class="token comment" spellcheck="true">// getClassLoader:()Ljava/lang/ClassLoader;</span>  #<span class="token number">40</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>String  #<span class="token number">41</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>Object  #<span class="token number">42</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader  #<span class="token number">43</span> <span class="token operator">=</span> Utf8               getSystemClassLoader  #<span class="token number">44</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">)</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span>  #<span class="token number">45</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>System  #<span class="token number">46</span> <span class="token operator">=</span> Utf8               out  #<span class="token number">47</span> <span class="token operator">=</span> Utf8               Ljava<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream<span class="token punctuation">;</span>  #<span class="token number">48</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream  #<span class="token number">49</span> <span class="token operator">=</span> Utf8               println  #<span class="token number">50</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>Object<span class="token punctuation">;</span><span class="token punctuation">)</span>V  #<span class="token number">51</span> <span class="token operator">=</span> Utf8               getParent  #<span class="token number">52</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>Class  #<span class="token number">53</span> <span class="token operator">=</span> Utf8               getClassLoader<span class="token punctuation">{</span>  <span class="token keyword">public</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">.</span><span class="token function">ClassLoaderTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> aload_0         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">8</span><span class="token operator">:</span> <span class="token number">0</span>      LocalVariableTable<span class="token operator">:</span>        Start  Length  Slot  Name   Signature            <span class="token number">0</span>       <span class="token number">5</span>     <span class="token number">0</span>  <span class="token keyword">this</span>   Ljohn<span class="token operator">/</span>classloader<span class="token operator">/</span>ClassLoaderTest1<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> invokestatic  #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method java/lang/ClassLoader.getSystemClassLoader:()Ljava/lang/ClassLoader;</span>         <span class="token number">3</span><span class="token operator">:</span> astore_1         <span class="token number">4</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="token number">7</span><span class="token operator">:</span> aload_1         <span class="token number">8</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span>        <span class="token number">11</span><span class="token operator">:</span> aload_1        <span class="token number">12</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/ClassLoader.getParent:()Ljava/lang/ClassLoader;</span>        <span class="token number">15</span><span class="token operator">:</span> astore_2        <span class="token number">16</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="token number">19</span><span class="token operator">:</span> aload_2        <span class="token number">20</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span>        <span class="token number">23</span><span class="token operator">:</span> aload_2        <span class="token number">24</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/ClassLoader.getParent:()Ljava/lang/ClassLoader;</span>        <span class="token number">27</span><span class="token operator">:</span> astore_3        <span class="token number">28</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="token number">31</span><span class="token operator">:</span> aload_3        <span class="token number">32</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span>        <span class="token number">35</span><span class="token operator">:</span> ldc           #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// class john/classloader/ClassLoaderTest1</span>        <span class="token number">37</span><span class="token operator">:</span> invokevirtual #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Class.getClassLoader:()Ljava/lang/ClassLoader;</span>        <span class="token number">40</span><span class="token operator">:</span> astore        <span class="token number">4</span>        <span class="token number">42</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="token number">45</span><span class="token operator">:</span> aload         <span class="token number">4</span>        <span class="token number">47</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span>        <span class="token number">50</span><span class="token operator">:</span> ldc           #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// class java/lang/String</span>        <span class="token number">52</span><span class="token operator">:</span> invokevirtual #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Class.getClassLoader:()Ljava/lang/ClassLoader;</span>        <span class="token number">55</span><span class="token operator">:</span> astore        <span class="token number">5</span>        <span class="token number">57</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="token number">60</span><span class="token operator">:</span> aload         <span class="token number">5</span>        <span class="token number">62</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span>        <span class="token number">65</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">10</span><span class="token operator">:</span> <span class="token number">0</span>        line <span class="token number">11</span><span class="token operator">:</span> <span class="token number">4</span>        line <span class="token number">13</span><span class="token operator">:</span> <span class="token number">11</span>        line <span class="token number">14</span><span class="token operator">:</span> <span class="token number">16</span>        line <span class="token number">16</span><span class="token operator">:</span> <span class="token number">23</span>        line <span class="token number">17</span><span class="token operator">:</span> <span class="token number">28</span>        line <span class="token number">19</span><span class="token operator">:</span> <span class="token number">35</span>        line <span class="token number">20</span><span class="token operator">:</span> <span class="token number">42</span>        line <span class="token number">22</span><span class="token operator">:</span> <span class="token number">50</span>        line <span class="token number">23</span><span class="token operator">:</span> <span class="token number">57</span>        line <span class="token number">24</span><span class="token operator">:</span> <span class="token number">65</span>      LocalVariableTable<span class="token operator">:</span>        Start  Length  Slot  Name   Signature            <span class="token number">0</span>      <span class="token number">66</span>     <span class="token number">0</span>  args   <span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span>            <span class="token number">4</span>      <span class="token number">62</span>     <span class="token number">1</span> systemClassLoader   Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span>           <span class="token number">16</span>      <span class="token number">50</span>     <span class="token number">2</span> parent   Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span>           <span class="token number">28</span>      <span class="token number">38</span>     <span class="token number">3</span> boostrap   Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span>           <span class="token number">42</span>      <span class="token number">24</span>     <span class="token number">4</span> classLoader   Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span>           <span class="token number">57</span>       <span class="token number">9</span>     <span class="token number">5</span> strClassLoader   Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>ClassLoader<span class="token punctuation">;</span><span class="token punctuation">}</span>SourceFile<span class="token operator">:</span> <span class="token string">"ClassLoaderTest1.java"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/fu-lu/"/>
      <url>/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/fu-lu/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="JVM大图"><a href="#JVM大图" class="headerlink" title="JVM大图"></a>JVM大图</h2><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218110318.png" alt></p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p>在jvm中有很多的参数可以进行设置,这样可以让JVM在各种环境中都能够高效的运行。绝大部分的参数保持默认即可。</p><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>JVM的参数类型分为三类,分别是: </p><ol><li><code>-</code>前缀标准参数，如<code>-help</code>、<code>-version</code></li><li><code>-X</code>前缀参数 (非标准参数)，如：<code>-Xint</code>、<code>-Xcomp</code></li><li><code>-XX:</code>前缀参数(使用率较高)，如：<code>-XX:newSize</code>、<code>-XX:+UseSerialGC</code></li></ol><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><p>jvm的标准参数,一般都是很稳定的,在未来的JVM版本中不会改变,可以使用<code>java -help</code>检索出所有的标准参数。</p><pre class="line-numbers language-shell"><code class="language-shell">zhonghongpeng@bogon classes % java -help                             用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32          使用 32 位数据模型 (如果可用)    -d64          使用 64 位数据模型 (如果可用)    -server       选择 "server" VM                  默认 VM 是 server,                  因为您是在服务器类计算机上运行。    -cp <目录和 zip/jar 文件的类搜索路径>    -classpath <目录和 zip/jar 文件的类搜索路径>                  用 : 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D<名称>=<值>                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出    -version      输出产品版本并退出    -version:<值>                  警告: 此功能已过时, 将在                  未来发行版中删除。                  需要指定的版本才能运行    -showversion  输出产品版本并继续    -jre-restrict-search | -no-jre-restrict-search                  警告: 此功能已过时, 将在                  未来发行版中删除。                  在版本搜索中包括/排除用户专用 JRE    -? -help      输出此帮助消息    -X            输出非标准选项的帮助    -ea[:<packagename>...|:<classname>]    -enableassertions[:<packagename>...|:<classname>]                  按指定的粒度启用断言    -da[:<packagename>...|:<classname>]    -disableassertions[:<packagename>...|:<classname>]                  禁用具有指定粒度的断言    -esa | -enablesystemassertions                  启用系统断言    -dsa | -disablesystemassertions                  禁用系统断言    -agentlib:<libname>[=<选项>]                  加载本机代理库 <libname>, 例如 -agentlib:hprof                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help    -agentpath:<pathname>[=<选项>]                  按完整路径名加载本机代理库    -javaagent:<jarpath>[=<选项>]                  加载 Java 编程语言代理, 请参阅 java.lang.instrument    -splash:<imagepath>                  使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="X参数"><a href="#X参数" class="headerlink" title="-X参数"></a>-X参数</h4><p>JVM的<code>-X</code>参数是非标准参数,在不同版本的JVM中,参数可能会有所不同,可以通过<code>java -X</code>查看非标准参数。</p><pre class="line-numbers language-java"><code class="language-java">zhonghongpeng<span class="token annotation punctuation">@bogon</span> classes <span class="token operator">%</span> java <span class="token operator">-</span>X                                    <span class="token operator">-</span>Xmixed           混合模式执行 <span class="token punctuation">(</span>默认<span class="token punctuation">)</span>    <span class="token operator">-</span>Xint             仅解释模式执行    <span class="token operator">-</span>Xbootclasspath<span class="token operator">:</span><span class="token operator">&lt;</span>用 <span class="token operator">:</span> 分隔的目录和 zip<span class="token operator">/</span>jar 文件<span class="token operator">></span>                      设置搜索路径以引导类和资源    <span class="token operator">-</span>Xbootclasspath<span class="token operator">/</span>a<span class="token operator">:</span><span class="token operator">&lt;</span>用 <span class="token operator">:</span> 分隔的目录和 zip<span class="token operator">/</span>jar 文件<span class="token operator">></span>                      附加在引导类路径末尾    <span class="token operator">-</span>Xbootclasspath<span class="token operator">/</span>p<span class="token operator">:</span><span class="token operator">&lt;</span>用 <span class="token operator">:</span> 分隔的目录和 zip<span class="token operator">/</span>jar 文件<span class="token operator">></span>                      置于引导类路径之前    <span class="token operator">-</span>Xdiag            显示附加诊断消息    <span class="token operator">-</span>Xnoclassgc       禁用类垃圾收集    <span class="token operator">-</span>Xincgc           启用增量垃圾收集    <span class="token operator">-</span>Xloggc<span class="token operator">:</span><span class="token operator">&lt;</span>file<span class="token operator">></span>    将 GC 状态记录在文件中 <span class="token punctuation">(</span>带时间戳<span class="token punctuation">)</span>    <span class="token operator">-</span>Xbatch           禁用后台编译    <span class="token operator">-</span>Xms<span class="token operator">&lt;</span>size<span class="token operator">></span>        设置初始 Java 堆大小    <span class="token operator">-</span>Xmx<span class="token operator">&lt;</span>size<span class="token operator">></span>        设置最大 Java 堆大小    <span class="token operator">-</span>Xss<span class="token operator">&lt;</span>size<span class="token operator">></span>        设置 Java 线程堆栈大小    <span class="token operator">-</span>Xprof            输出 cpu 配置文件数据    <span class="token operator">-</span>Xfuture          启用最严格的检查<span class="token punctuation">,</span> 预期将来的默认值    <span class="token operator">-</span>Xrs              减少 Java<span class="token operator">/</span>VM 对操作系统信号的使用 <span class="token punctuation">(</span>请参阅文档<span class="token punctuation">)</span>    <span class="token operator">-</span>Xcheck<span class="token operator">:</span>jni       对 JNI 函数执行其他检查    <span class="token operator">-</span>Xshare<span class="token operator">:</span>off       不尝试使用共享类数据    <span class="token operator">-</span>Xshare<span class="token operator">:</span>auto      在可能的情况下使用共享类数据 <span class="token punctuation">(</span>默认<span class="token punctuation">)</span>    <span class="token operator">-</span>Xshare<span class="token operator">:</span>on        要求使用共享类数据<span class="token punctuation">,</span> 否则将失败。    <span class="token operator">-</span>XshowSettings    显示所有设置并继续    <span class="token operator">-</span>XshowSettings<span class="token operator">:</span>all                      显示所有设置并继续    <span class="token operator">-</span>XshowSettings<span class="token operator">:</span>vm 显示所有与 vm 相关的设置并继续    <span class="token operator">-</span>XshowSettings<span class="token operator">:</span>properties                      显示所有属性设置并继续    <span class="token operator">-</span>XshowSettings<span class="token operator">:</span>locale                      显示所有与区域设置相关的设置并继续<span class="token operator">-</span>X 选项是非标准选项<span class="token punctuation">,</span> 如有更改<span class="token punctuation">,</span> 恕不另行通知。以下选项为 Mac OS X 特定的选项<span class="token operator">:</span>    <span class="token operator">-</span>XstartOnFirstThread                      在第一个 <span class="token punctuation">(</span>AppKit<span class="token punctuation">)</span> 线程上运行 <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法    <span class="token operator">-</span>Xdock<span class="token operator">:</span>name<span class="token operator">=</span><span class="token operator">&lt;</span>应用程序名称<span class="token operator">></span>"                      覆盖停靠栏中显示的默认应用程序名称    <span class="token operator">-</span>Xdock<span class="token operator">:</span>icon<span class="token operator">=</span><span class="token operator">&lt;</span>图标文件的路径<span class="token operator">></span>                      覆盖停靠栏中显示的默认图标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="XX参数"><a href="#XX参数" class="headerlink" title="-XX参数"></a>-XX参数</h4><p><code>-XX</code>参数也是非标准参数,主要用于JVM的调优和debug操作。</p><p><code>-XX</code>参数的使用有2种方式,一种是boolean类型,一种是非boolean类型:</p><ul><li>boolean类型<ul><li>格式：<code>-XX:[+-]</code></li><li>如：<code>-XX:+DisableExplicitGC</code>表示禁用手动调用gc操作,也就是说调用<code>System.gc()</code>无效 </li></ul></li><li>非boolean类型<ul><li>格式：<code>-XX:</code></li><li>如：<code>-XX:NewRatio=1</code> 表示新生代和老年代的比值</li></ul></li></ul><h3 id="常用参数参考附录"><a href="#常用参数参考附录" class="headerlink" title="常用参数参考附录"></a>常用参数参考附录</h3><pre class="line-numbers language-shell"><code class="language-shell">指定虚拟机以解释模式运行-Xint指定虚拟机以编译模式运行-Xcomp解释+编译模式运行，默认-Xmixed设置系统属性-D<名称>=<值>以服务器模式运行-server以客户端模式运行-client设置栈空间大小-Xss128k自旋锁升级前最大次数-XX:PreBlockSpin自旋锁开关-XX:-UseBiasedLocking=falsejvm 启动自旋锁立即激活-XX:BiasedLockingStartupDelay=0-XX:MaxMetaspaceSize:设置元空间最大值,默认是-1,即不限制,或者说只受限于本地内存大小。-XX:MetaspaceSize:指定元空间的初始空间大小,以字节为单位,达到该值就会触发垃圾收集进行类型卸载,同时收集器会对该值进行调整:如果释放了大量的空间,就适当降低该值;如果释放了很少的空间,那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下,适当提高该值。-XX:MinMetaspaceFreeRatio:作用是在垃圾收集之后控制最小的元空间剩余容量的百分比,可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX:Max-MetaspaceFreeRatio,用于控制最大的元空间剩余容量的百分比。-Xnoclassgc参数进行控制是否允许对方法区内方法信息进行垃圾回收,还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息,其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用,-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。显式开启逃逸分析-XX:+DoEscapeAnalysis查看逃逸分析的筛选结果-XX:+PrintEscapeAnalysis是否开启栈上分配-XX:+/-UseTLAB开启同步省略-XX:+EliminateLocks开启标量替换-XX:+EliminateAllocations查看替换情况-XX:+PrintEliminateAllocations代码执行次数会被JIT优化编译-XX:CompileThreshold = 10000 计算因子-XX:OnStackReplacePercentage = 140-XX:InterpreterProfilePercentage = 33客户端下某段循环体中的代码循环次数会被JIT优化编译(回边计数器阈值) = CompileThreshold * OnStackReplacePercentage / 100服务端下某段循环体中的代码循环次数会被JIT优化编译(回边计数器阈值) = (CompileThreshold * (OnStackReplacePercentage - InterpreterProfilePercentage)) / 100 = 10700关闭JIT代码运行计数器热度衰减-XX:-UseCounterDecay参数设置半衰周期的时间(代码空闲多少秒进行半衰)，单位是秒-XX:CounterHalfLife=<N>禁止后台线程编译，执行线程阻塞等待编译结果，得到结果后再执行编译得到的本地代码-XX:-BackgroundCompilation打印所有的参数默认初始值-XX:+PrintFlagsInitial打印所有的参数的实际值，输出赋值操作符有=或:=,分别代表默认值和被修改的值。-XX:+PrintFlagsFinal# 在JVM运行期间查看设置参数步骤：# 1. jps：查看当前运行中的进程id# 2. jinfo -flag SurvivorRatio 进程id：查看具体JVM进程的指定参数值初始化堆空间内存（默认为物理内存的1/64）-Xms128m最大堆空间内存（默认为物理内存的1/4）-Xmx128m设置新生代大小（初始值及最大值）-Xmn128m配置新生代与老年代在堆结构的占比-XX:NewRatio=3设置新生代中Eden和S0/S1空间的比例-XX:SurvivorRatio=4设置新生代垃圾的最大年龄-XX:MaxTenuringThreshold=15设置多大的对象直接进入老年代，默认值为0，代表不管多大都是先在Eden中分配内存-XX:PretenureSizeThreshold=0输出详细的GC处理日志-XX:+PrintGCDetails打印GC简要信息-XX:+PrintGC、-verbose:gc设置是否空间分配担保-XX:HandlePromotionFailure在退出的时候打印StringTable的信息-XX:+PrintStringTableStatistics# 开启G1 string去重,默认是不开启的,需要手动开启。-XX:+/-UseStringDeduplication# 打印详细的去重统计信息-XX:+/-PrintStringDeduplicationStatistics# 达到这个年龄的 string对象被认为是去重的候选对象-XX:StringDeduplicationAgeThreshold=<N># 开启先检查记忆集卡表是否已经变脏然后再更新卡表-XX:+UseCondCardMark# 开启指针压缩。ZGC不可用-XX: +UseCompressedOops# 解锁诊断性质的VM参数、打印汇编代码-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly# 出现 OOME 时生成堆 dump:-XX:+HeapDumpOnOutOfMemoryError# 生成堆文件地址: -XX:HeapDumpPath=/home/hadoop/dump/# 使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件-XX:+HeapDumpOnCtrlBreak# 查看安全点日志-XX:+PrintSafepointStatistics-XX:PrintSafepointStatisticsCount=1# 让虚拟机在等到线程进入安全点的时间超过2000毫秒时就认定为超时,这样就会输出迟迟无法进入安全点的线程名称-XX: +SafepointTimeout-XX:SafepointTimeoutDelay=2000# 关闭类加载的链接过程中的验证阶段，这个阶段占据大部分时间-Xverify:none# JDK6开启分层编译-XX:+TieredCompilation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JDK-9前后日志参数变化"><a href="#JDK-9前后日志参数变化" class="headerlink" title="JDK 9前后日志参数变化"></a>JDK 9前后日志参数变化</h3><table><thead><tr><th>JDK9前日志参数</th><th>JDK9后配置形式</th></tr></thead><tbody><tr><td>G1PrintHeapRegions</td><td>Xlog: gc+region=trace</td></tr><tr><td>G1PrintRegionLiveness Info</td><td>Xlog: gc+liveness=trace</td></tr><tr><td>G1Summarize Concmark</td><td>Xlog: gc+marking=trace</td></tr><tr><td>G1SummarizeRSetStats</td><td>Xlog: gc+remset*=trace</td></tr><tr><td>GCLogFileSize, NumberOfGCLogFiles, UseGCLogFileRotation</td><td><code>Xlog: gc*:file&lt;file&gt;::filecount=&lt;count&gt;,filesize=file size in kb&gt;</code></td></tr><tr><td>PrintAdaptiveSizePolicy</td><td>Xlog: gc+ergo*=trace</td></tr><tr><td>PrintClassHistogramAfterFullGC</td><td>Xlog: classhisto*=trace</td></tr><tr><td>PrintClassHistogramBeforeFullGC</td><td>Xlog: classhisto*=trace</td></tr><tr><td>PrintGCApplicationConcurrentTime</td><td>Xlog: safepoint</td></tr><tr><td>PrintGCApplicationStoppedTime</td><td>Xlog: safepoint</td></tr><tr><td>PrintGCDateStamps</td><td>使用time修饰器</td></tr><tr><td>PrintGCTaskTimeStamps</td><td>Xlog: gc+task=trace</td></tr><tr><td>PrintGCtimeStamps</td><td>使用 uptime修饰器</td></tr><tr><td>PrintHeapAtGC</td><td>Xlog: gc+heap=debug</td></tr><tr><td>PrintHeapAtGCExtended</td><td>Xlog: gc+heap=trace</td></tr><tr><td>PrintJNIGCStalls</td><td>Xlog: gc+jni=debug</td></tr><tr><td>PrintOldPLAB</td><td>Xlog: gc+plab=trace</td></tr><tr><td>PrintParallelOldGCPhaseTimes</td><td>Xlog: gc+phases=trace</td></tr><tr><td>PrintPLAB</td><td>Xlog: gc+plab=trace</td></tr><tr><td>PrintPromotionFailure</td><td>Xlog: gc+promotion=debug</td></tr><tr><td>PrintReferenceGC</td><td>Xlog: gc+ref=debug</td></tr><tr><td>PrintStringDeduplicationStatistics</td><td>Xlog: gc+stringdedup</td></tr><tr><td>PrintTaskqueue</td><td>Xlog: gc+task+stats=trace</td></tr><tr><td>PrintTenuringDistribution</td><td>Xlog: gc+age=trace</td></tr><tr><td>PrintTerminationStats</td><td>Xlog: gc+task+stats=debug</td></tr><tr><td>PrintTLAB</td><td>Xlog: gc+tlab=trace</td></tr><tr><td>TraceAdaptiveGCBoundary</td><td>Xlog: heap+ergo=debug</td></tr><tr><td>TraceDynamicGCThreads</td><td>Xlog: gc+task=trace</td></tr><tr><td>TraceMetadataHumongousAllocation</td><td>Xlog: gc+metaspace+alloc=debug</td></tr><tr><td>G1TraceConcRefinement</td><td>Xlog: gc+refine=debug</td></tr><tr><td>G1TraceEagerReclaimHumongousObjects</td><td>Xlog: gc+humongous=debug</td></tr><tr><td>G1TraceStringSymbolTableScrubbing</td><td>Xlog: gc+stringtable=trace</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="垃圾收集器相关参数"><a href="#垃圾收集器相关参数" class="headerlink" title="垃圾收集器相关参数"></a>垃圾收集器相关参数</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UseSerialGC</td><td>虚拟机运行在 Client模式下的默认值,打开此开关后.使用 Serial+ Serial Old的收集器组合进行内存回收</td></tr><tr><td>UseParNewGC</td><td>打开此开关后,使用 Pardew+ Serial Old的收集器组合进行内存回收,在JDK9后不再支持</td></tr><tr><td>UseConcMarkSweepGC</td><td>打开此开关后,使用 Pardew+CMS+ Serial Old的收集器组合进行内存 回收。Serial Old收集器将作为CMS收集器出现“Concurrent Mode Failure” 失败后的后备收集器使用</td></tr><tr><td>UseParallelGC</td><td>JDK9之前虚拟机运行在 Server模式下的默认值,打开此开关后,使用Parallel Scavenge+ Serial Old( PS Marksweep)的收集器组合进行内存回收</td></tr><tr><td>UseParallelOldGC</td><td>打开此开关后,使用 Parallel Scavenge+ Parallel Old的收集器组合进行内存回收</td></tr><tr><td>SurvivorRatio</td><td>新生代中Eden区域与 Survivor区域的容量比值,.默认为8,代表Eden Survivor=8: 1</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小,设置这个参数后,大于这个参数的对象将直接在老年代分配</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄。每个对象在坚持过一次 Minor GC之后,年龄就增加1,当超过这个参数值时就进入老年代</td></tr><tr><td>UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td>HandlePromotionFailure</td><td>是否允许分配担保失败,即老年代的剩余空间不足以应付新生代的整个 Eden和 Survivor区的所有对象都存活的极端情况</td></tr><tr><td>ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>GcTimeRatio</td><td>GC时间占总时间的比率,默认值为99,即允许1%的GC时间。仅在使用 Parallel Scavenge收集器时生效</td></tr><tr><td>MaxGCPauseMillis</td><td>设置GC的最大停顿时间。仅在使用 Parallel Scavenge收集器时生效设置</td></tr><tr><td>CMSInitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为 68%,仅在使用CMS收集器时生效</td></tr><tr><td>UseCMSCompactAtFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效,此参数从JDK9开始废弃</td></tr><tr><td>CMSFullGCsBeforeCompaction</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效,此参数从JDK9开始废弃</td></tr><tr><td>UseG1GC</td><td>使用G1收集器,这个是JDK9后的 Server模式默认值</td></tr><tr><td>G1heapRegionsize=N</td><td>设置 Region大小,并非最终值</td></tr><tr><td>MaxGCPauseMillis</td><td>设置G1收集过程目标时间,默认值是200ms,不是硬性条件</td></tr><tr><td>G1NewSizePereent</td><td>新生代最小值,默认值是5%</td></tr><tr><td>G1MaxNewSizePercent</td><td>新生代最大值,默认值是60%</td></tr><tr><td>ParallelGCThreads</td><td>用户线程冻结期间并行执行的收集器线程数</td></tr><tr><td>ConcGCthreads=N</td><td>并发标记、并发整理的执行线程数,对不同的收集器,根据其能够并发的阶段,有不同的含义</td></tr><tr><td>InitiatingHeapOccupancyPercent</td><td>设置触发标记周期的Java堆占用率國值。默认值是45%。这里的java堆占比指的是 non young capacity bytes,包括 old+humongous</td></tr><tr><td>UseShenandoahGC</td><td>使用 Shenandoah 收集器。这个选项在 Oraclejdk中不被支持,只能在 OPENJDK12或者某些支持 Shenandoah的 Backport发行版本使用。目前仍然要配合<code>-XX:+ UnlockExperimentalVMOptions</code></td></tr><tr><td>ShenandoahGCHeuristics</td><td>使用Shenandoah何时启动一次GC过程,其可选值有 adaptive、 static、 compact、 passive、 aggressive</td></tr><tr><td>UesZGC</td><td>使用ZGC收集器,目前仍然要配合<code>-XX:+ UnlockExperimentalVMOptions</code>使用</td></tr><tr><td>UseNUMA</td><td>启用NUMA内存分配支持,目前只有 Parallel和ZGC支持,以后G1收 集器可能也会支持该选项</td></tr></tbody></table><h3 id="官方网址"><a href="#官方网址" class="headerlink" title="官方网址"></a>官方网址</h3><blockquote><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/12-lei-jia-zai-zi-xi-tong/"/>
      <url>/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/12-lei-jia-zai-zi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM类加载的特性"><a href="#JVM类加载的特性" class="headerlink" title="JVM类加载的特性"></a>JVM类加载的特性</h1><p>那些在编译时需要进行连接的语言不同,在Java语言里面,类型的加载、连接和初始化过程都是在程序运行期间完成的,这种策略让Java语言进行提前编译会面临额外的困难,也会让类加载时稍微增加一些性能开销, 但是却为Java应用提供了极高的扩展性和灵活性,Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><p>例如,编写一个面向接口的应用程序,可以等到运行时再指定其实际的实现类,用户可以通过Java预置的或自定义类加载器,让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。这种动态组装应用的方式目前已广泛应用于Java程序之中,从最基础的Applet、JSP到相对复杂的OSGi技术,都依赖着Java语言运行期类加载才得以诞生。</p><h1 id="类加载子系统图示"><a href="#类加载子系统图示" class="headerlink" title="类加载子系统图示"></a>类加载子系统图示</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120053.png" alt="image-20200910152333208"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120108.png" alt="image-20200910152446215"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120117.png" alt="image-20200910152532755"></p><h1 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h1><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120126.png" alt="image-20200910153524052"></p><h3 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h3><p>可以认为不同的类加载器的作用拥有<strong>从不同数据源</strong>找到class文件并从该数据源获取class文件为数据流的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120134.png" alt="image-20200910153734911"></p><h3 id="类型的生命周期"><a href="#类型的生命周期" class="headerlink" title="类型的生命周期"></a>类型的生命周期</h3><p>一个类型从被加载到虚拟机内存中开始,到卸载出内存为止,它的整个生命周期将会经历加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)七个阶段,其中验证、准备、解析三个部分统称为连接(Linking)。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120141.png" alt="image-20200921164724467"></p><p><strong>加载、验证、准备、初始化和卸载</strong>这五个阶段的顺序是确定的,类型的加载过程必须按照这种顺序按部就班地开始,而<strong>解析阶段则不一定</strong>:它在某些情况下可以在初始化阶段之后再开始, 这是为了支持Java语言的<strong>运行时绑定特性</strong>(也称为<strong>动态绑定或晚期绑定</strong>)。请注意,这里的按部就班地“开始”,而不是按部就班地“进行”或按部就班地“完成”,强调这点是因为这些阶段通常都是互相交叉地混合进行的,会在一个阶段执行的过程中调用、激活另一个阶段。</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”,《Java虚拟机规范》中并没有进行强制约束,这点可以交给虚拟机的具体实现来自由把握。</p><h4 id="JVM规范严格定义的类初始化时机：主动引用"><a href="#JVM规范严格定义的类初始化时机：主动引用" class="headerlink" title="JVM规范严格定义的类初始化时机：主动引用"></a>JVM规范严格定义的<strong>类初始化时机</strong>：主动引用</h4><p>但是对于<strong>初始化阶段</strong>,《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”(<strong>而加载、验证、准备自然需要在此之前开始</strong>): </p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时,如果类型没有进行过初始化,则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有: <ul><li>使用new关键字实例化对象的时候。</li><li>读取或设置一个类型的静态字段(<strong>被final修饰、已在编译期把结果放入常量池的静态字段除外</strong>) 的时候。</li><li>调用一个类型的静态方法的时候。</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候,如果类型没有进行过初始化,则需要先触发其初始化。</li><li>当初始化类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化。</li><li>当虚拟机启动时,用户需要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化,那该接口要在其之前被初始化。</li></ol><p>对于这六种会触发类型进行初始化的场景,《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”,这六种场景中的行为称为对一个类型进行<strong>主动引用</strong>。</p><blockquote><p>在类加载器中有一个<code>loadClass()</code>方法进行类加载，这是一个重载方法，其中一个重载参数是boolean类型，表示是否需要对类进行链接，注意，这是也仅仅是链接，所以<code>loadClass()</code>中是不会对类进行初始化的，之后真正发生主动引用的地方才会发生初始化（包括类成员初始化、静态方法调用等）。</p></blockquote><h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>除此以上之外,所有引用类型的方式都不会触发初始化,称为<strong>被动引用</strong>。</p><ol><li><p>通过子类调用父类的静态字段,不会导致子类初始化</p><p>JVM没有规定是否需要对子类进行<strong>加载</strong>，通过<code>-XX: +TraceClassLoading</code>参数观察到此操作是会导致<strong>HotSpot</strong>对子类进行加载的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被动使用类字段演示一:  通过子类访问父类的静态字段,不会导致子类初始化 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 非主动使用类字段演示：SubClass的静态方法没有调用 **/</span><span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过数组定义来引用类,不会触发此类的初始化</p><p>这段代码里面触发了另一个名为<code>[john.classloader.SuperClass</code>的类的初始化阶段,对于用户代码来说,这并不是一个合法的类型名称,它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类,创建动作由字节码指令newarray触发。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被动使用类字段演示一:  通过子类访问父类的静态字段,不会导致子类初始化 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 非主动使用类字段演示：SuperClass的静态方法没有调用 **/</span><span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SuperClass<span class="token punctuation">[</span><span class="token punctuation">]</span> sca <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperClass</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>常量在编译阶段会存入调用类的常量池中</strong>,本质上没有直接引用到定义常量的类,因此不会触发定义常量的类的初始化</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被动使用类字段演示一:  通过子类访问父类的静态字段,不会导致子类初始化 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 非主动使用类字段演示：SuperClass的静态方法没有调用 **/</span><span class="token keyword">class</span> <span class="token class-name">NotInitialization</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h3><p>接口的加载过程与类加载过程稍有不同,针对接口需要做一些特殊说明:接口也有初始化过程, 这点与类是一致的,接口中不能定义静态代码块，但是虚拟机仍然会为其生成<code>&lt;clinit&gt;</code>类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种: 当一个类在初始化时,要求其父类全部都已经初始化过了,但是<strong>一个接口在初始化时,并不要求其父接口全部都完成了初始化,只有在真正使用到父接口的时候</strong>(如引用接口中定义的常量)才会初始化。</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h4><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。<ul><li>开发人员通过定义自己的类加载器去控制字节流的获取方式(重写一个类加载器的<code>findClass()</code>或<code>loadClass()</code>方法),实现根据自己的想法来赋予应用程序获取运行代码的动态性。</li></ul></li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象,作为方法区这个类的各种数据的访问入口</li></ol><p>加载.class文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h5 id="数组的加载"><a href="#数组的加载" class="headerlink" title="数组的加载"></a>数组的加载</h5><p>对于数组类而言,情况就有所不同,数组类本身不通过类加载器创建,它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系,因为数组类的元素类型(Element Type,指的是数组去掉所有维度的类型)最终还是要靠类加载器来完成加载,一个数组类(下面简称为C)创建过程遵循以下规则: </p><ul><li>如果数组的组件类型(Component Type,指的是数组去掉一个维度的类型,注意和前面的元素类型区分开来)是引用类型,那就递归采用本节中定义的加载过程去加载这个组件类型,数组C将被<strong>标识在加载该组件类型的类加载器的类名称空间上</strong>(一个类型必须与类加载器一起确定唯一性)。</li><li>如果数组的组件类型不是引用类型(例如<code>int[]</code>数组的组件类型为<code>int</code>),Java虚拟机将会把数组C 标记为与引导类加载器关联。</li><li>数组类的可访问性与它的组件类型的可访问性一致,如果组件类型不是引用类型,它的数组类的可访问性将默认为<code>public</code>,可被所有的类和接口访问到。</li><li>加载阶段结束后,Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了,方法区中的数据存储格式完全由虚拟机实现自行定义,《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后,会在Java堆内存中实例化一个<code>java.lang.Class</code>类的对象, 这个对象将作为程序访问方法区中的类型数据的外部接口。</li></ul><h5 id="加载与链接的顺序"><a href="#加载与链接的顺序" class="headerlink" title="加载与链接的顺序"></a>加载与链接的顺序</h5><p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的,加载阶段尚未完成,连接阶段可能已经开始,但这些夹在加载阶段之中进行的动作,仍然属于连接阶段的一部分,这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h4 id="2、链接"><a href="#2、链接" class="headerlink" title="2、链接"></a>2、链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证是连接阶段的第一步,这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求,保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段大致上会完成下面四个阶段的检验动作:文件格式验证、元数据验证、字节码验证和符号引用验证。</p><h6 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h6><p>第一阶段要验证字节流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点:</p><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>… …</li></ul><p>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内,格式上符合描述一个Java类型信息的要求。<strong>这阶段的验证主要是对class二进制流的格式进行验证</strong>,只有通过了这个阶段的验证之后,这段字节流才被允许进入Java虚拟机内存的方法区中进行存储,所以<strong>后面的三个验证阶段全部是基于方法区的存储结构上进行的,不会再直接读取、操作字节流了。</strong></p><h6 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h6><p>第二阶段是对字节码描述的信息进行语义分析,以保证其描述的信息符合《Java语言规范》的要求,这个阶段可能包括的验证点如下:</p><ul><li>这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)。</li><li>这个类的父类是否继承了不允许被继承的类(被final修饰的类)。</li><li>如果这个类不是抽象类,是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段,或者出现不符合规则的方法重载,例如方法参数都一致,但返回值类型却不同等)。</li><li>… …</li></ul><p>第二阶段的<strong>主要目的是对类的元数据信息进行语义校验,保证不存在与《Java语言规范》定义相悖的元数据信息。</strong></p><h6 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h6><p>第三阶段是整个验证过程中最复杂的一个阶段,<strong>主要目的是通过数据流分析和控制流分析,确定程序语义是合法的、符合逻辑的</strong>。在第二阶段对元数据信息中的数据类型校验完毕以后,这阶段就要对类的方法体(Class文件中的Code属性)进行校验分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为,例如: </p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作,例如不会出现类似于“在操作栈放置了一个int类型的数据,使用时却按long类型来加载入本地变量表中”这样的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的,例如可以把一个子类对象赋值给父类数据类型,这是安全的,但是把父类对象赋值给子类数据类型,甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型,则是危险和不合法的。</li><li>……</li></ul><p>由于数据流分析和控制流分析的高度复杂性,Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中,在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化,把尽可能多的校验辅助措施挪到Javac编译器里进行。具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性,这项属性描述了方法体所有的基本块(Basic Block,指按照控制流拆分的代码块)开始时本地变量表和操作栈应有的状态,在字节码验证期间,Java虚拟机就不需要根据程序推导这些状态的合法性,只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的类型推导转变为类型检查,从而节省了大量校验时间。理论上StackMapTable属性也存在错误或被篡改的可能,所以是否有可能在恶意篡改了Code属性的同时,也生成相应的StackMapTable属性来骗过虚拟机的类型校验,则是虚拟机设计者们需要仔细思考的问题。</p><h6 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h6><p>最后一个阶段的校验行为<strong>发生在虚拟机将符号引用转化为直接引用的时候,这个转化动作将在连接的第三阶段——解析阶段中发生</strong>。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验,通俗来说就是,该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容:</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性(private、protected、public、package)是否可被当前类访问。</li><li>……</li></ul><p>符号引用验证的主要目的是确保解析行为能正常执行,如果无法通过符号引用验证,Java虚拟机将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常,典型的如: <code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。</p><p>验证阶段对于虚拟机的类加载机制来说,是一个非常重要的、但却不是必须要执行的阶段,因为验证阶段只有通过或者不通过的差别,只要通过了验证,其后就对程序运行期没有任何影响了。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过,在生产环境的实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间。</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><h6 id="调用类构造器-lt-clinit-gt-方法对类变量赋”零值”"><a href="#调用类构造器-lt-clinit-gt-方法对类变量赋”零值”" class="headerlink" title="调用类构造器&lt;clinit&gt;()方法对类变量赋”零值”"></a>调用类构造器<code>&lt;clinit&gt;()</code>方法对类变量赋”零值”</h6><p>准备阶段是正式为类中定义的变量(即静态变量,被static修饰的变量)分配内存并设置类变量初始值的阶段,从概念上讲,这些变量所使用的内存都在方法区中(逻辑概念，JDK7及之前在堆、JDK8及之后在直接内存)进行分配。</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>flase</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><h6 id="根据ConstantValue对常量初始化"><a href="#根据ConstantValue对常量初始化" class="headerlink" title="根据ConstantValue对常量初始化"></a>根据ConstantValue对常量初始化</h6><p>Javac编译时会为所有被<code>final</code>、<code>static</code>修饰的字段生成ConstantValue属性, 准备阶段如果类字段的字段属性表中存在ConstantValue属性, 那就会将字段值初始化为ConstantValue属性所指定的初始值.例如：</p><pre class="line-numbers language-shell"><code class="language-shell">public static final int value = 123; //value会被在当前阶段初始化为123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行,分别对应于常量池中：</p><ul><li>CONSTANT_Class_info</li><li>CONSTANT_Fieldref_info</li><li>CONSTANT_Methodref_info</li><li>CONSTANT_InterfaceMethodref_info</li><li>CONSTANT_MethodType_info</li><li>CONSTANT_MethodHandle_info</li><li>CONSTANT_Dynamic_info</li><li>CONSTANT_InvokeDynamic_info </li></ul><p>8种常量类型。</p><ul><li>符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关,引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同, 但是它们能接受的符号引用必须都是一致的,因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li><li>直接引用(Direct References):直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的,同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用,那引用的目标必定已经在虚拟机的内存中存在。</li></ul><h6 id="触发解析的时机"><a href="#触发解析的时机" class="headerlink" title="触发解析的时机"></a>触发解析的时机</h6><p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间,只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前,先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断,到底是在类被加载器加载时就对常量池中的符号引用进行解析,还是等到一个符号引用将要被使用前才去解析它。</p><blockquote><p>对于invokedynamic指令，它本来就是用于动态语言支持,它对应的引用称为“动态调用点限定符(Dynamically-Computed Call Site Specifier)”,这里“动态”的含义是指必须等到程序实际运行到这条指令时,解析动作才能进行。相对地,其余可触发解析的指令都是“静态”的,可以在刚刚完成加载阶段,还没有开始执行代码时就提前进行解析。</p></blockquote><h6 id="1-gt-类或接口的解析"><a href="#1-gt-类或接口的解析" class="headerlink" title="1&gt;类或接口的解析"></a>1&gt;类或接口的解析</h6><p>假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用,那虚拟机完成整个解析的过程需要包括以下3个步骤: </p><ol><li>如果C不是一个数组类型,那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中,由于元数据验证、字节码验证的需要,又可能触发其他相关类的加载动作,例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常,解析过程就将宣告失败。</li><li>如果C是一个数组类型,并且数组的元素类型为对象,也就是N的描述符会是类似<code>[Ljava/lang/Integer</code>的形式,那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式,需要加载的元素类型就是<code>java.lang.Integer</code>,接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li><li>如果上面两步没有出现任何异常,那么C在虚拟机中实际上已经成为一个有效的类或接口了, 但在解析完成前还要进行符号引用验证,确认D是否具备对C的访问权限(public、protected、private… …)。如果发现不具备访问权限, 将抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol><h6 id="2-gt-字段解析"><a href="#2-gt-字段解析" class="headerlink" title="2&gt;字段解析"></a>2&gt;字段解析</h6><p>要解析一个未被解析过的字段符号引用，首先将会对对应的CONSTANT_Fieldref_info内class_index项中索引的CONSTANT_Class_info符号引用进行解析,也就是字段所属的类或接口的符号引用</p><ul><li>如果在解析这个类或接口符号引用的过程中出现了任何异常,都会导致字段符号引用解析的失败。</li><li>如果解析成功完成,那把这个字段所属的类或接口用C表示,《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索: <ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束。</li><li>否则,如果在C中实现了接口,将会按照继承关系从下往上递归搜索各个接口和它的父接口, 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束。</li><li>否则,如果C不是<code>java.lang.Object</code>的话,将会按照继承关系从下往上递归搜索其父类,如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束。</li><li>否则,查找失败,抛出<code>java.lang.NoSuchFieldError</code>异常。</li><li>如果查找过程成功返回了引用,将会对这个字段进行权限验证,如果发现不具备对字段的访问权限,将抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol></li></ul><p>以上解析规则能够确保Java虚拟机获得字段唯一的解析结果,但在实际情况中,Javac编译器往往会采取比上述规范更加严格一些的约束,譬如有一个同名字段同时出现在某个类的接口和父类当中, 或者同时在自己或父类的多个接口中出现,按照解析规则仍是可以确定唯一的访问字段,但Javac编译器就<strong>可能</strong>直接拒绝其编译为Class文件。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldResolution</span> <span class="token punctuation">{</span>    <span class="token keyword">interface</span> <span class="token class-name">Interface0</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">Interface1</span> <span class="token keyword">extends</span> <span class="token class-name">Interface0</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">Interface2</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">implements</span> <span class="token class-name">Interface1</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token keyword">implements</span> <span class="token class-name">Interface2</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果注释这行代码，接口与父类同时存在字段A,那Oracle公司实现的Javac编译器将提示“The field Sub.A is ambiguous”,并且会拒绝编译这段代码。</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3-gt-方法解析"><a href="#3-gt-方法解析" class="headerlink" title="3&gt;方法解析"></a>3&gt;方法解析</h6><p>方法解析的第一个步骤与字段解析一样,也是需要先解析出对应的CONSTANT_Methodref_info的class_index项中索引的方法所属的类或接口的符号引用。如果解析成功,那么我们依然用C表示这个类,接下来虚拟机将会按照如下步骤进行后续的方法搜索:</p><ol><li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的,如果在类的方法表中发现class_index中索引的C是个接口的话,那就直接抛出<code>java.lang.IncompatibleClassChangeError</code> 异常。</li><li>如果通过了第一步,在类C中查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束。</li><li>否则,在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束。</li><li>否则,在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法,如果存在匹配的方法,说明类C是一个抽象类,这时候查找结束,抛出<code>java.lang.AbstractMethodError</code>异常。</li><li>否则,宣告方法查找失败,抛出<code>java.lang.NoSuchMethodError</code>。</li><li>最后,如果查找过程成功返回了直接引用,将会对这个方法进行权限验证,如果发现不具备对此方法的访问权限,将抛出<code>java.lang.IllegalAccessError</code>异常。</li></ol><h6 id="4-gt-接口方法解析"><a href="#4-gt-接口方法解析" class="headerlink" title="4&gt;接口方法解析"></a>4&gt;接口方法解析</h6><p>接口方法也是需要先解析出对应的CONSTANT_InterfaceMethodref_info的class_index项中索引的方法所属的类或接口的符号引用,如果解析成功,依然用C表示这个接口,接下来虚拟机将会按照如下步骤进行后续的接口方法搜索:</p><ol><li>与类的方法解析相反,如果在接口方法表中发现class_index中的索引C是个类而不是接口,那么就直接抛出<code>java.lang.IncompatibleClassChangeError</code>异常。</li><li>否则,在接口C中查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束。</li><li>否则,在接口C的父接口中递归查找,直到java.lang.Object类(接口方法的查找范围也会包括Object类中的方法)为止,看是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束。</li><li>对于规则3,由于Java的接口允许多重继承,如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法,那将会从这多个方法中返回其中一个并结束查找,《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地,不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li><li>否则,宣告方法查找失败,抛出<code>java.lang.NoSuchMethodError</code>异常。</li></ol><h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>类的初始化阶段是类加载过程的最后一个步骤。初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法,它是Javac编译器的自动生成物，<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的：</p><ul><li>编译器收集的顺序是<strong>由语句在源文件中出现的顺序决定的(包括类字段赋值及静态代码块的顺序)</strong></li><li>静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问。</li></ul><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//  给变量复制可以正常编译通过</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这句编译器会提示“非法向前引用”。</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//看了往上的一些答案，说是为了解决循环引用，例如下面的例子。所以只允许将出现在后面的静态变量作为左值不能作为右值，但是感觉有点怪怪的，变量不是都在链接的准备阶段赋零值了吗。</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这种写法也会提示“非法向前引用”</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;clinit&gt;()</code>方法与类的构造函数(即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法)不同,它不需要显式地调用父类构造器,Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前(加载子类之前保证父类已经加载),父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是<code>java.lang.Object</code>。</li><li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的,<strong>如果一个类中没有静态语句块,也没有对变量的赋值操作,那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</strong>。</li><li>接口中不能使用静态语句块,但仍然有变量初始化的赋值操作,因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是,执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法, 因为只有当父接口中定义的变量被使用时,父接口才会被初始化。<strong>此外,接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</strong></li><li>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步,如果多个线程同时去初始化一个类,那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法,其他线程都需要阻塞等待,直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作,那就可能造成多个进程阻塞[2],在实际应用中这种阻塞往往是很隐蔽的。</li></ul><h1 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h1><p>JVM支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)。从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有<strong>派生于抽象类ClassLoader的类加载器</strong>都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120158.png" alt="image-20200910170353512"></p><p>类加载器之间的父子关系一般不是以继承(Inheritance)的关系来实现的,而是通常使用组合(Composition)关系来复用父加载器的代码。</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120205.png" alt="image-20200910170517036"></p><h3 id="类加载器包含关系-双亲委派关系"><a href="#类加载器包含关系-双亲委派关系" class="headerlink" title="类加载器包含关系(双亲委派关系)"></a>类加载器包含关系(双亲委派关系)</h3><p>包含关系指的是包含加载器加载的类包含但不限于被包含加载器加载的类(包含加载器是被包含加载器的parent，被包含加载器在加载类的时候尝试交由包含加载器加载，当包含加载器无法加载的时候，再由被包含加载器加载)。</p><h3 id="类加载代码演示"><a href="#类加载代码演示" class="headerlink" title="类加载代码演示"></a>类加载代码演示</h3><pre class="line-numbers language-java"><code class="language-java">        ClassLoader systemClassLoader <span class="token operator">=</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        ClassLoader parent <span class="token operator">=</span> systemClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sun.misc.Launcher$ExtClassLoader@4dc63996</span>        ClassLoader boostrap <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>boostrap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//null</span>        ClassLoader classLoader <span class="token operator">=</span> ClassLoaderTest1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        ClassLoader strClassLoader <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>strClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户代码默认是”System ClassLoader”来加载，而”System ClassLoader”默认就是”AppClassLoader”应用程序类加载器，而应用程序类加载器的父亲就是拓展类加载器，拓展类加载器的父亲是引导类加载器，使用<code>getParent</code>方法得到的是null，因为该加载器使用的是C/C++实现。</p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><ul><li>启动类加载器(引导类加载器，Boostrap ClassLoader)<ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载<code>JAVA_HOME/jre/lib/rt.jar</code>、resources.jar或sun.boot.class.path路径、<code>-Xbootclasspath</code>参数所指定的路径下的，而且是Java虚拟机能够识别的(按照文件名识别,如rt.jar、tools.jar,名字不符合的类库即使放在lib目录中也不会被加载)Java的核心类库</li><li>并不继承<code>java.lang.ClassLoader</code>，没有父加载器</li><li>加载拓展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，Boostrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul></li><li>扩展类加载器(Extension ClassLoader)<ul><li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li><li>派生于<code>ClassLoader</code>类</li><li>父类加载器为启动类加载器</li><li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>&lt;JAVA_HOME&gt;\lib\ext</code>子目录（扩展目录）下加载类库。如果用于创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul></li><li>应用程序类加载器(系统类加载器，AppClassLoader)<ul><li>java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现。</li><li>派生于<code>ClassLoader</code>类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性<code>java.class.path</code>指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取到该类加载器</li></ul></li></ul><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>为什么要自定义类加载器？<ul><li>隔离加载类。在动态环境中，例如依赖了多个中间件的应用程序，可能会遇到不同依赖下的类名冲突，为了避免默认类加载器的不确定性，此时中间件一般会自定义类加载器实现自己的类的加载逻辑在反射的时候使用该类加载器加载自己的类(在JVM中类加载器+类本身唯一确定一个类，即类全限定名重复，但是类加载器不同，是可以同时存在的)。</li><li>修改类加载的方式。例如懒加载或者缓存等。</li><li>扩展加载源。实现可以从网络、数据库等不同的数据源中动态获取class文件流。</li><li>防止源码泄露。在编译源文件之后对class文件加密，然后在执行的时候通过自定义类加载器进行解密。</li></ul></li></ul><h4 id="用户自定义类加载器实现步骤："><a href="#用户自定义类加载器实现步骤：" class="headerlink" title="用户自定义类加载器实现步骤："></a>用户自定义类加载器实现步骤：</h4><ol><li>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承<code>ClassLoader</code>类并重写<code>loadClass()</code>方法，从而实现自定义的加载类，但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<code>URLClassLoader</code>类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="ClassLoader类的常用方法"><a href="#ClassLoader类的常用方法" class="headerlink" title="ClassLoader类的常用方法"></a>ClassLoader类的常用方法</h2><p>ClassLoader类是一个抽象类，除了引导类加载都需要继承自ClassLoader。</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>getParent()</code></td><td>返回该类加载器的超类加载器</td></tr><tr><td><code>loadClass(String name)</code></td><td>加载名称为name的类，返回结果为<code>java.lang.Class</code>类的实例，如果类已经加载，将直接返回已经加载的类；如果还没加载，就会调用<code>findClass</code>去获取，自定义加载类一般不要重写这个方法</td></tr><tr><td><code>findClass(String name)</code></td><td>查找名称为name的类，返回结果为<code>java.lang.Class</code>类的实例，自定义加载类一般将查找类逻辑重写在这个方法里面</td></tr><tr><td><code>findLoadedClass(String name)</code></td><td>查找名称为name的已经被加载过的类，返回结果为<code>java.lang.Class</code>类的实例</td></tr><tr><td><code>defineClass(String name, byte[] b, int off, int len)</code></td><td>把字节数组b中的内容转换为一个Java类，返回结果为<code>java.lang.Class</code>类的实例</td></tr><tr><td><code>resolveClass(Class&lt;?&gt; c)</code></td><td>连接指定的一个Java类</td></tr></tbody></table><h2 id="获取ClassLoader的几种方式"><a href="#获取ClassLoader的几种方式" class="headerlink" title="获取ClassLoader的几种方式"></a>获取ClassLoader的几种方式</h2><p>一般是根据指定方式来获取对应的类加载器来加载自己本身无法加载的类，例如在破坏双亲委派模型的情况下，父类通过约定的方式获取对应的类加载器加载其无法加载的类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//方式一：获取当前类的ClassLoader</span>clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式二：获取当前线程上下文的ClassLoader</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式三：获取系统的ClassLoader</span>ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式四：获取调用者的ClassLoader</span>DriverManager<span class="token punctuation">.</span><span class="token function">getCallerClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是說当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><p>工作原理：</p><ol><li>如果一个类加载器收到了JVM对它发起的类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120216.png" alt="image-20200910182810609"></p><p>作用：</p><ol><li><p>避免核心库中的类被用户自定义的完全一样的全限定名的类覆盖(即使用户定义了<code>java.lang.CustomerClass</code>这样的自定义类，但是包名是核心库下的包，最终委派到引导类加载器的时候会抛出异常，这也称为”<strong>沙箱安全机制</strong>“)</p><p>即使自定义了自己的类加载器,强行用defineClass()方法去加载一个自定义的以“java.lang”开头的类也不会成功。如果读者尝试这样做的话,将会收到一个由Java虚拟机内部抛出的“java.lang.SecurityException: Prohibited package name:java.lang”异常。</p></li><li><p>避免类的重复加载</p></li><li><p>在遇到类名完全一样的情况下，如果加载器不同也不会有问题，由加载器-全限定类名唯一确定一个类</p></li></ol><h3 id="破坏双亲委派机制-反向委派"><a href="#破坏双亲委派机制-反向委派" class="headerlink" title="破坏双亲委派机制(反向委派)"></a>破坏双亲委派机制(反向委派)</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120223.png" alt="image-20200910201806151"></p><p>类似JDBC，接口类是由引导类加载器加载的，但是后续的<code>Class.forName(&quot;具体的服务实现类全限定名&quot;)</code>中指定的具体服务实现类引导类加载器却无法加载，此时需要委派到子类加载器进行加载。</p><h2 id="JDK9后的类加载器"><a href="#JDK9后的类加载器" class="headerlink" title="JDK9后的类加载器"></a>JDK9后的类加载器</h2><p>在JDK 9中引入的Java模块化系统(Java Platform Module System,JPMS)是对Java技术的一次重要升级,为了能够实现模块化的关键目标——可配置的封装隔离机制,Java虚拟机对类加载架构也做出了相应的变动调整,才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器,除了代码外,Java的模块定义还包含以下内容: </p><ul><li>依赖其他模块的列表。</li><li>导出的包列表,即其他模块可以使用的列表。</li><li>开放的包列表,即其他模块可反射访问模块的列表。</li><li>使用的服务列表。</li><li>提供服务的实现列表。</li></ul><p>配置的封装隔离机制首先要解决JDK 9之前基于类路径(ClassPath)来查找依赖的可靠性问题。此前,如果类路径中缺失了运行时依赖的类型,那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常。而在JDK 9以后,如果启用了模块化进行封装,模块就可以声明对其他模块的显式依赖,这样Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备,如有缺失那就直接启动失败,从而避免了<strong>很大一部分</strong>由于类型依赖而引发的运行时异常。</p><p>可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们,模块提供了更精细的可访问性控制,必须明确声明其中哪一些public的类型可以被其他哪一些模块访问,这种访问控制也主要是在类加载过程中完成的（链接-验证的符号引用验证部分）。</p><h3 id="加入模块化系统之后向前兼容JAR包访"><a href="#加入模块化系统之后向前兼容JAR包访" class="headerlink" title="加入模块化系统之后向前兼容JAR包访"></a>加入模块化系统之后向前兼容JAR包访</h3><p>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制,JDK 9提出了与“类路径”(ClassPath)相对应的“模块路径”(ModulePath)的概念。简单来说,就是某个类库到底是模块还是传统的JAR包,只取决于它存放在哪种路径上。只要是放在类路径上的JAR文件,无论其中是否包含模块化信息(是否包含了module-info.class文件),它都会被当作传统的JAR包来对待;相应地,只要放在模块路径上的JAR文件,即使没有使用JMOD后缀,甚至说其中并不包含module-info.class文件,它也仍然会被当作一个模块来对待。</p><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上,即使这些版本的JDK已经使用模块来封装了Java SE的标准类库,模块化系统的这套规则也仍然保证了传统程序可以访问到所有标准类库模块中导出的包。</p><ul><li>JAR文件在类路径的访问规则:所有类路径下的JAR文件及其他资源文件,都被视为自动打包在一个匿名模块(Unnamed Module)里,这个匿名模块几乎是没有任何隔离的,它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包,以及模块路径上所有模块中导出的包。</li><li>模块在模块路径的访问规则:模块路径下的具名模块(Named Module)只能访问到它依赖定义中列明依赖的模块和包,匿名模块里所有的内容对具名模块来说都是不可见的,即具名模块看不见传统JAR包的内容。</li><li>JAR文件在模块路径的访问规则:如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中,它就会变成一个自动模块(Automatic Module)。尽管不包含module-info.class,但自动模块将默认依赖于整个模块路径中的所有模块,因此可以访问到所有模块导出的包,自动模块也默认导出自己所有的包。</li></ul><p>以上3条规则保证了即使Java应用依然使用传统的类路径,升级到JDK 9对应用来说几乎(类加载器上的变动还是可能会导致少许可见的影响,将在下节介绍)不会有任何感觉,项目也不需要专门为了升级JDK版本而去把传统JAR包升级成模块。</p><h3 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h3><ul><li><p>首先,是扩展类加载器(Extension Class Loader)被平台类加载器(Platform Class Loader)取代。这其实是一个很顺理成章的变动,既然整个JDK都基于模块化进行构建(原来的<code>rt.jar</code>和<code>tools.jar</code>被拆分成数十个JMOD文件),其中的Java类库就已天然地满足了可扩展的需求,那自然无须再保留<jav a_home>\lib\ext目录</jav></p></li><li><p>其次,平台类加载器和应用程序类加载器都不再派生自<code>java.net.URLClassLoader</code>,如果有程序直接依赖了这种继承关系,或者依赖了<code>URLClassLoader</code>类的特定方法,那代码很可能会在JDK 9及更高版本的JDK中崩溃。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code></p></li><li><p>启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器,尽管有了<code>BootClassLoader</code>这样的Java类,但为了与之前的代码保持兼容,所有在获取启动类加载器的场景(譬如<code>Object.class.getClassLoader()</code>)中仍然会返回null来代替,而不会得到<code>BootClassLoader</code>的实例。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120234.png" alt="image-20200921211450487"></p><p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构,但类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求,在委派给父加载器加载前,要先判断该类是否能够归属到某一个系统模块中,如果可以找到这样的归属关系,就要优先委派给负责那个模块的加载器完成加载,也许这可以算是对双亲委派的又一次破坏。</p><p>在Java模块化系统明确规定了三个类加载器负责各自加载的模块,即前面所说的归属关系,如下所示：</p><h4 id="启动类加载器负责加载的模块"><a href="#启动类加载器负责加载的模块" class="headerlink" title="启动类加载器负责加载的模块"></a>启动类加载器负责加载的模块</h4><pre class="line-numbers language-java"><code class="language-java">java<span class="token punctuation">.</span>basejava<span class="token punctuation">.</span>security<span class="token punctuation">.</span>sasl java<span class="token punctuation">.</span>datatransferjava<span class="token punctuation">.</span>xml java<span class="token punctuation">.</span>desktopjdk<span class="token punctuation">.</span>httpserver java<span class="token punctuation">.</span>instrument                      jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>cijava<span class="token punctuation">.</span>loggingjdk<span class="token punctuation">.</span>management java<span class="token punctuation">.</span>management                  jdk<span class="token punctuation">.</span>management<span class="token punctuation">.</span>agent java<span class="token punctuation">.</span>management<span class="token punctuation">.</span>rmi              jdk<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>rmi java<span class="token punctuation">.</span>namingjdk<span class="token punctuation">.</span>netjava<span class="token punctuation">.</span>prefsjdk<span class="token punctuation">.</span>sctpjava<span class="token punctuation">.</span>rmijdk<span class="token punctuation">.</span>unsupported<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="平台类加载器负责加载的模块"><a href="#平台类加载器负责加载的模块" class="headerlink" title="平台类加载器负责加载的模块"></a>平台类加载器负责加载的模块</h4><pre class="line-numbers language-java"><code class="language-java">java<span class="token punctuation">.</span>activation<span class="token operator">*</span>jdk<span class="token punctuation">.</span>accessibility java<span class="token punctuation">.</span>compiler<span class="token operator">*</span>jdk<span class="token punctuation">.</span>charsets java<span class="token punctuation">.</span>corba<span class="token operator">*</span>jdk<span class="token punctuation">.</span>crypto<span class="token punctuation">.</span>cryptoki java<span class="token punctuation">.</span>scriptingjdk<span class="token punctuation">.</span>crypto<span class="token punctuation">.</span>ecjava<span class="token punctuation">.</span>sejdk<span class="token punctuation">.</span>dynalinkjava<span class="token punctuation">.</span>se<span class="token punctuation">.</span>eejdk<span class="token punctuation">.</span>incubator<span class="token punctuation">.</span>httpclient java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>jgssjdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>compiler<span class="token operator">*</span>java<span class="token punctuation">.</span>smartcardio                jdk<span class="token punctuation">.</span>jsobjectjava<span class="token punctuation">.</span>sqljdk<span class="token punctuation">.</span>localedata java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>rowsetjdk<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>dns java<span class="token punctuation">.</span>transaction<span class="token operator">*</span>jdk<span class="token punctuation">.</span>scripting<span class="token punctuation">.</span>nashorn java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token operator">*</span>jdk<span class="token punctuation">.</span>security<span class="token punctuation">.</span>authjava<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>cryptojdk<span class="token punctuation">.</span>security<span class="token punctuation">.</span>jgss java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>ws<span class="token operator">*</span>jdk<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>dom java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>ws<span class="token punctuation">.</span>annotation<span class="token operator">*</span>jdk<span class="token punctuation">.</span>zipfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用程序类加载器负责加载的模块"><a href="#应用程序类加载器负责加载的模块" class="headerlink" title="应用程序类加载器负责加载的模块"></a>应用程序类加载器负责加载的模块</h4><pre class="line-numbers language-java"><code class="language-java">jdk<span class="token punctuation">.</span>aotjdk<span class="token punctuation">.</span>jdeps jdk<span class="token punctuation">.</span>attach                      jdk<span class="token punctuation">.</span>jdi jdk<span class="token punctuation">.</span>compiler           jdk<span class="token punctuation">.</span>jdwp<span class="token punctuation">.</span>agent jdk<span class="token punctuation">.</span>editpad   jdk<span class="token punctuation">.</span>jlink jdk<span class="token punctuation">.</span>hotspot<span class="token punctuation">.</span>agent  jdk<span class="token punctuation">.</span>jshelljdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>ed     jdk<span class="token punctuation">.</span>jstatd jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>jvmstat       jdk<span class="token punctuation">.</span>pack jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>le  jdk<span class="token punctuation">.</span>policytool jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>opt  jdk<span class="token punctuation">.</span>rmic jdk<span class="token punctuation">.</span>jartool  jdk<span class="token punctuation">.</span>scripting<span class="token punctuation">.</span>nashorn<span class="token punctuation">.</span>shelljdk<span class="token punctuation">.</span>javadoc         jdk<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>bind<span class="token operator">*</span> jdk<span class="token punctuation">.</span>jcmd        jdk<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>ws<span class="token operator">*</span> jdk<span class="token punctuation">.</span>jconsole<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>在JVM中表示通过以下方式唯一确定一个Class对象：</p><ol><li><p>类的完整类名必须一致，包括包名。</p></li><li><p>加载这个类的ClassLoader（指ClassLoader实例对象）必须是同一个</p><p>换句话说，在JVM中，即使这两个类对象(class对象)来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。这里所指的“相等”,包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance() 方法的返回结果,也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p></li></ol></li><li><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中(<code>clzz.getClassLoader()</code>)。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p></li></ul><h1 id="类加载器案例"><a href="#类加载器案例" class="headerlink" title="类加载器案例"></a>类加载器案例</h1><h2 id="TOMCAT"><a href="#TOMCAT" class="headerlink" title="TOMCAT"></a>TOMCAT</h2><p>主流的Java Web服务器,如Tomcat、Jetty、WebLogic、WebSphere或其他笔者没有列举的服务器, 都实现了自己定义的类加载器,而且一般还都不止一个。因为一个功能健全的Web服务器,都要解决如下的这些问题: </p><ul><li><p>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。这是最基本的需求,两个不同的应用程序可能会依赖同一个第三方类库的不同版本,不能要求每个类库在一个服务器中只能有一份,服务器应当能够保证两个独立应用程序的类库可以互相独立使用。</p></li><li><p>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。这个需求与前面一点正好相反,但是也很常见,例如用户可能有10个使用Spring组织的应用程序部署在同一台服务器上,如果把10份Spring分别存放在各个应用程序的隔离目录中,将会是很大的资源浪费——这主要倒不是浪费磁盘空间的问题,而是指类库在使用时都要被加载到服务器内存,如果类库不能共享,虚拟机的方法区就会很容易出现过度膨胀的风险。</p></li><li><p>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。目前,有许多主流的Java Web服务器自身也是使用Java语言来实现的。因此服务器本身也有类库依赖的问题,一般来说,基于安全考虑,服务器所使用的类库应该与应用程序的类库互相独立。</p></li><li><p>支持JSP应用的Web服务器,十有八九都需要支持HotSwap功能。我们知道JSP文件最终要被编译成Java的Class文件才能被虚拟机执行,但JSP文件由于其纯文本存储的特性,被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待,因此“主流”的Web服务器都会支持JSP生成类的热替换,当然也有“非主流”的,如运行在生产模式(Production Mode)下的WebLogic服务器默认就不会处理JSP文件的变化。</p></li></ul><p>由于存在上述问题,在部署Web应用时,单独的一个ClassPath就不能满足需求了,所以各种Web服务器都不约而同地提供了好几个有着不同含义的ClassPath路径供用户存放第三方类库,这些路径一般会以“lib”或“classes”命名。被放置到不同路径中的类库,具备不同的访问范围和服务对象,通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。</p><p>在Tomcat目录结构中,可以设置3组目录(<code>/common/*</code>、<code>/server/*</code>和<code>/shared/*</code>,但默认不一定是开放的,可能只有<code>/lib/*</code>目录存在)用于存放Java类库,另外还应该加上Web应用程序自身的<code>/WEB- INF/*</code>目录,一共4组。把Java类库放置在这4组目录中,每一组都有独立的含义,分别是:</p><ul><li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li><li>放置在/server目录中。类库可被Tomcat使用,对所有的Web应用程序都不可见。</li><li>放置在/shared目录中。类库可被所有的Web应用程序共同使用,但对Tomcat自己不可见。</li><li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用,对Tomcat和其他Web应用程序都不可见。</li></ul><p>为了支持这套目录结构,并对目录里面的类库进行加载和隔离,Tomcat自定义了多个类加载器, 这些类加载器按照经典的双亲委派模型来实现</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120248.png" alt="image-20200922151032313"></p><p>灰色背景的3个类加载器是JDK(以JDK 9之前经典的三层类加载器为例)默认提供的类加载器。下面则是Tomcat自己定义的类加载器</p><ul><li>Common类加载器：加载<code>/common/*</code>中的Java类库</li><li>Catalina类加载器(也称为Server类加载器)：加载<code>/server/*</code>中的Java类库</li><li>Shared类加载器：加载<code>/shared/*</code>中的Java类库</li><li>Webapp类加载器：加载<code>/WebApp/WEB-INF/*</code>中的Java类库<ul><li>存在多个实例：每一个Web应用程序对应一个WebApp类加载器</li></ul></li><li>JSP类加载器：加载JSP文件<ul><li>存在多个实例：每一个JSP文件对应一个JasperLoader类加载器</li></ul></li></ul><p>Common类加载器能加载的类都可以被Catalina类加载器和Shared 类加载器使用,而Catalina类加载器和Shared类加载器自己能加载的类则与对方相互隔离。WebApp类加载器可以使用Shared类加载器加载到的类,但各个WebApp类加载器实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件,它存在的目的就是为了被丢弃:当服务器检测到JSP文件被修改时,会替换掉目前的JasperLoader的实例,并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。</p><p>本例中的类加载结构在Tomcat 6以前是它默认的类加载器结构,在Tomcat 6及之后的版本简化了默认的目录结构,只有指定了<code>tomcat/conf/catalina.properties</code>配置文件的<code>server.loader</code>和<code>share.loader</code>项后才会真正建立Catalina类加载器和Shared类加载器的实例,否则会用到这两个类加载器的地方都会用Common类加载器的实例代替,而默认的配置文件中并没有设置这两个loader项,所以Tomcat 6之后也顺理成章地把<code>/common</code>、<code>/server</code>和<code>/shared</code>这3个目录默认合并到一起变成1个<code>/lib</code>目录,这个目录里的类库相当于以前<code>/common</code>目录中类库的作用,是Tomcat的开发团队为了简化大多数的部署场景所做的一项易用性改进。如果默认设置不能满足需要,用户可以通过修改配置文件指定<code>server.loader</code>和<code>share.loader</code> 的方式重新启用原来完整的加载器架构。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>被Common类加载器或Shared类加载器加载的Spring如何访问并不在其加载范围内的用户程序呢？其实就是类似破坏双亲委派模型，通过调用子类加载器(委派)将对应的<code>Class</code>对象加载出来。</p><p>例子：以下代码中通过将<code>john.classloader.TestClassLoader.java</code>编译后得到的<code>TestClassLoader.class</code>文件在标准库目录和指定目录之间移动将得到不同的效果。当移动到指定目录之后，<code>TestCall</code>由应用程序类加载器加载，它通过指定的类加载器<code>Loader</code>在指定目录对类进行加载之后即可进行访问：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>MalformedURLException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLStreamHandlerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/10 17:14 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> MalformedURLException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> InvocationTargetException<span class="token punctuation">,</span> InstantiationException <span class="token punctuation">{</span>        TestCall testCall <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        testCall<span class="token punctuation">.</span><span class="token function">testWithClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        testCall<span class="token punctuation">.</span><span class="token function">testWithSymbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Loader</span> <span class="token keyword">extends</span> <span class="token class-name">URLClassLoader</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token function">Loader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> MalformedURLException <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//自定义类路径，非标准路径</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span> <span class="token string">"file:///Users/zhonghongpeng/IdeaProjects/tech-learning/jvm/src/main/java/"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Loader</span><span class="token punctuation">(</span>URL<span class="token punctuation">[</span><span class="token punctuation">]</span> urls<span class="token punctuation">,</span> ClassLoader parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>urls<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">Loader</span><span class="token punctuation">(</span>URL<span class="token punctuation">[</span><span class="token punctuation">]</span> urls<span class="token punctuation">,</span> ClassLoader parent<span class="token punctuation">,</span> URLStreamHandlerFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>urls<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestCall</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWithClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> String methodName <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>                Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Loader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"john.classloader.TestClassLoader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                aClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>aClass<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//当 TestClassLoader.class移动到了指定目录。输出："hello! 我的类加载器是john.classloader.ClassLoaderTest2$Loader@d716361"</span>            <span class="token comment" spellcheck="true">//当 TestClassLoader.class移动到了指定目录 存在标准目录。输出："hello! 我的类加载器是sun.misc.Launcher$AppClassLoader@18b4aac2"</span>        <span class="token punctuation">}</span>        TestClassLoader test<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果在标准类路径中不存在 TestClassLoader.class，这里会在编译期报错，无法通过编译，该符号引用无效。此时只能通过指定类加载器进行加载</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWithSymbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            test<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/22 14:59 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello! 我的类加载器是"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h2><p>OSGi[1](Open Service Gateway Initiative)是OSGi联盟(OSGi Alliance)制订的一个基于Java语言的动态模块化规范(在JDK 9引入的JPMS是静态的模块系统)。</p><p>OSGi中的每个模块(称为Bundle)与普通的Java类库区别并不太大,两者一般都以JAR格式进行封装,并且内部存储的都是Java的Package和Class。但是一个Bundle可以声明它所依赖的Package(通过Import-Package描述),也可以声明它允许导出发布的Package(通过Export-Package描述)。在OSGi 里面,Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖,而且类库的可见性能得到非常精确的控制,一个模块里只有被Export过的Package才可能被外界访问,其他的Package和Class将会被隐藏起来。</p><p>OSGi现在着重向动态模块化系统的方向发展。在今天,通常引入OSGi的主要理由是基于OSGi架构的程序很可能(只是很可能,并不是一定会,需要考虑热插拔后的内存管理、上下文状态维护问题等复杂因素)会实现模块级的热插拔功能,当程序升级更新或调试除错时,可以只停用、重新安装然后启用程序的其中一部分,这对大型软件、企业级程序开发来说是一个非常有诱惑力的特性,譬如Eclipse中安装、卸载、更新插件而不需要重启动,就使用到了这种特性。</p><p>OSGi之所以能有上述诱人的特点,必须要归功于它灵活的类加载器架构。OSGi的Bundle类加载器之间只有规则,没有固定的委派关系。例如,某个Bundle声明了一个它依赖的Package,如果有其他Bundle声明了发布这个Package后,那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时,各个Bundle加载器都是平级的关系,只有具体使用到某个Package和Class的时候,才会根据Package导入导出定义来构造Bundle间的委派和依赖。</p><p>另外,一个Bundle类加载器为其他Bundle提供服务时,会根据Export-Package列表严格控制访问范围。如果一个类存在于Bundle的类库中但是没有被Export,那么这个Bundle的类加载器能找到这个类, 但不会提供给其他Bundle使用,而且OSGi框架也不会把其他Bundle的类加载请求分配给这个Bundle来处理。</p><p>我们可以举一个更具体些的简单例子来解释上面的规则,假设存在Bundle A、Bundle B、Bundle C3个模块,并且这3个Bundle定义的依赖关系如下所示。</p><ul><li>Bundle A:声明发布了packageA,依赖了<code>java.*</code>的包; </li><li>Bundle B:声明依赖了packageA和packageC,同时也依赖了<code>java.*</code>的包; </li><li>Bundle C:声明发布了packageC,依赖了packageA。</li></ul><p>那么,这3个Bundle之间的类加载器及父类加载器之间的关系如</p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218120259.png" alt="image-20200922155054517"></p><p>在OSGi中,加载器之间的关系不再是双亲委派模型的树形结构,而是已经进一步发展成一种更为复杂的、运行时才能确定的网状结构。这种网状的类加载器架构在带来更优秀的灵活性的同时,也可能会产生许多新的隐患。例如死锁。</p><h2 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h2><p>动态代理中所说的“动态”,是相对<strong>使用Java代码实际编写了代理类</strong>的“静态”代理而言的,它的优势不在于省去了编写代理类那一点编码工作量,而是实现了可以在原始类和接口还未知的时候,就确定代理类的代理行为,当代理类与原始类脱离直接联系后,就可以很灵活地重用于不同的应用场景之中。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author: honphan.john * @date: 2020/9/22 15:57 * @description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">interface</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>        Object originalObj<span class="token punctuation">;</span>        Object <span class="token function">bind</span><span class="token punctuation">(</span>Object originalObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>originalObj <span class="token operator">=</span> originalObj<span class="token punctuation">;</span>            <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> originalObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"welcome"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>originalObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        IHello hello <span class="token operator">=</span> <span class="token punctuation">(</span>IHello<span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出</span><span class="token comment" spellcheck="true">//welcome</span><span class="token comment" spellcheck="true">//hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Proxy::newProxyInstance()方法返回一个实现了<code>IHello</code>的接口,并且代理了<code>new Hello()</code>实例行为的对象。跟踪这个方法的源码,可以看到程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作,前面的步骤并不是我们关注的重点,这里只分析它最后调用<code>sun.misc.ProxyGenerator::generateProxyClass()</code>方法来完成生成字节码的动作,这个方法会在运行时产生一个描述代理类的字节码byte[]数组。如果想看一看这个在运行时产生的代理类中写了些什么,可以在main()方法中加入下面这句:</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>磁盘中将会产生一个名为“$Proxy0.class”的代理类Class文件,反编译后可以看见：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Source code recreated from a .class file by IntelliJ IDEA</span><span class="token comment" spellcheck="true">// (powered by FernFlower decompiler)</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">package</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>UndeclaredThrowableException<span class="token punctuation">;</span><span class="token keyword">import</span> john<span class="token punctuation">.</span>classloader<span class="token punctuation">.</span>DynamicProxyTest<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">class</span> $Proxy0 <span class="token keyword">extends</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Method m1<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Method m3<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Method m2<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Method m0<span class="token punctuation">;</span>    <span class="token keyword">public</span> $<span class="token function">Proxy0</span><span class="token punctuation">(</span>InvocationHandler var1<span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m1<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>var1<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var3<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m3<span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m2<span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m0<span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            m1 <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"equals"</span><span class="token punctuation">,</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m3 <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"john.classloader.DynamicProxyTest$IHello"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m2 <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m0 <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"hashCode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchMethodError</span><span class="token punctuation">(</span>var2<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoClassDefFoundError</span><span class="token punctuation">(</span>var3<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代理类的实现代码也很简单,它为传入接口中的每一个方法,以及从java.lang.Object中继承来的equals()、hashCode()、toString()方法都生成了对应的实现,并且统一调用了InvocationHandler对象的invoke()方法(代码中的“this.h”就是父类Proxy中保存的InvocationHandler实例变量)来实现这些方法的内容,各个方法的区别不过是传入的参数和Method对象有所不同而已,所以无论调用动态代理的哪一个方法,实际上都是在执行InvocationHandler::invoke()中的代理逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/00-qian-yan/"/>
      <url>/2020/09/10/jvm/shen-ru-li-jie-java-xu-ni-ji-bi-ji/00-qian-yan/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111156.png" alt="JDK_JRE_JVM"></p><h1 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111157.png" alt="image-20200910105340576"></p><ul><li>整个结构分为上、中、下层。</li><li>第一层类装载器子系统负责将class文件从文件系统加载到内存中成为一个JVM的class对象结构，分为加载、链接、初始化。</li><li>方法区、堆所有线程共享；虚拟机栈(Java栈)、本地方法栈、程序计数器线程私有。</li><li>生成Class文件的过程是前端编译，执行引擎中涉及的翻译字节码解释执行和JIT中的即使编译执行为后端编译</li></ul><h1 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h1><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111158.png" alt="image-20200910111130207"></p><h1 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h1><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令架构。</p><p>具体来说，这两种架构之间的区别：</p><ul><li>基于栈式架构的特点：<ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul></li></ul><blockquote><p>栈式架构即函数(方法)的实现是将函数中每一行代码要操作的所有变量不断压栈或者弹栈，使得待操作的变量永远存在栈顶，而操作指令则永远操作栈顶即可，所以无需在指令中包含操作数的地址，而是仅仅包含操作指令即可。</p><p>而寄存器架构则是将方法中的变量按照语言自己设计的一套规则分配到不同的寄存器中，这样函数中访问变量的代码也要按照这套规则去获取具体变量的寄存器地址进行访问。</p><p>很明显，前者确实更通用(不依赖具体硬件下可能不同的寄存器组)、容易实现(无需额外设计一套寄存器分配规则)。但是因为要将变量压栈入栈使得待操作数永远存在栈顶也使得增添了一些额外操作使得效率没有后者高。</p></blockquote><ul><li>栈式架构的指令集中指令为8位指令；寄存器架构的指令集中指令大多为16位指令。</li></ul><h3 id="Java字节码指令架构和x86指令架构区别示例"><a href="#Java字节码指令架构和x86指令架构区别示例" class="headerlink" title="Java字节码指令架构和x86指令架构区别示例"></a>Java字节码指令架构和x86指令架构区别示例</h3><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111159.png" alt="image-20200910112820981"></p><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111200.png" alt="image-20200910113850389"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111201.png" alt="image-20200910113925569"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111202.png" alt="image-20200910113941979"></p><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111203.png" alt="image-20200910113957240"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><h1 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h1><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作</li><li>除此之外，JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li></ul><h1 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h1><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111204.png" alt="image-20200910115805813"></p><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111205.png" alt="image-20200910120035259"></p><h3 id="Hotspot-VM"><a href="#Hotspot-VM" class="headerlink" title="Hotspot VM"></a>Hotspot VM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111206.png" alt="image-20200910120152236"></p><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111207.png" alt="image-20200910145619170"></p><p>被Oracle收购，合并到Hotspot中。</p><h3 id="J9"><a href="#J9" class="headerlink" title="J9"></a>J9</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111208.png" alt="image-20200910145943301"></p><h3 id="KVM、CDC-CLDC-Hotspot"><a href="#KVM、CDC-CLDC-Hotspot" class="headerlink" title="KVM、CDC/CLDC Hotspot"></a>KVM、CDC/CLDC Hotspot</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111209.png" alt="image-20200910150204775"></p><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111210.png" alt="image-20200910150424663"></p><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111211.png" alt="image-20200910150523369"></p><h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111212.png" alt="image-20200910150654952"></p><h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111213.png" alt="image-20200910150944249"></p><h3 id="TaobaoJVM"><a href="#TaobaoJVM" class="headerlink" title="TaobaoJVM"></a>TaobaoJVM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111214.png" alt="image-20200910151043002"></p><h3 id="DalvikVM"><a href="#DalvikVM" class="headerlink" title="DalvikVM"></a>DalvikVM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111215.png" alt="image-20200910151317561"></p><h3 id="其他JVM"><a href="#其他JVM" class="headerlink" title="其他JVM"></a>其他JVM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111216.png" alt="image-20200910151532648"></p><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p><img src="https://cdn.jsdelivr.net/gh/JohnZhongg/blog_images/image/20201218111217.png" alt="image-20200910151904547"></p><h1 id="JVM规范主要内容"><a href="#JVM规范主要内容" class="headerlink" title="JVM规范主要内容"></a><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">JVM规范</a>主要内容</h1><ol><li><p>字节码指令集（相当于中央处理器CPU）</p></li><li><p>Class文件的格式</p></li><li><p>数据类型和值(范围、实现方式)</p></li><li><p>运行时数据区</p></li><li><p>栈帧</p></li><li><p>特殊方法的实现</p><ol><li><p><code>&lt;init&gt;</code>：这个不是我们定义的构造方法，是虚拟机内置的一个创建实例的方法，如果我们有给一个类定义实例成员变量并且赋值，那么这些实例成员变量将会在这个方法里面进行真正的赋值。通过JVM的<code>invokespecial</code>指令来调用。</p><p>虚拟机会在我们写的构造方法中将对<code>&lt;init&gt;</code>方法的调用代码以及构造代码块中的代码合并到构造方法的最前面，<code>&lt;init&gt;</code>作为这个特殊方法的符号引用存在。所以new一个对象的过程为：</p><ol><li>为对象分配内存</li><li>调用<code>&lt;init&gt;</code>方法初始化我们赋值的成员变量</li><li>执行构造代码块中代码</li><li>执行构造函数中代码</li></ol></li><li><p><code>&lt;clinit&gt;</code>：类或者接口的初始化方法，不包含参数，返回void，不是我们写的静态代码块，虚拟机会根据我们是否定义了静态代码块或者对静态变量进行了赋值而构造一个该方法进行执行。</p></li></ol></li><li><p>需要支持一些类库</p><ol><li>反射</li><li>加载和创建类或接口，如ClassLoader</li><li>连接和初始化类和接口的类</li><li>安全，如security</li><li>多线程</li><li>弱引用</li></ol></li><li><p>异常处理</p></li><li><p>虚拟机的启动、加载、链接和初始化，包括字节码的执行引擎</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/2020/02/16/untitled/"/>
      <url>/2020/02/16/untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 测试分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
